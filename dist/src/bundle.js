!function(n){var t={};function g(I){if(t[I])return t[I].exports;var l=t[I]={i:I,l:!1,exports:{}};return n[I].call(l.exports,l,l.exports,g),l.l=!0,l.exports}g.m=n,g.c=t,g.d=function(n,t,I){g.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:I})},g.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},g.t=function(n,t){if(1&t&&(n=g(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(g.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var l in n)g.d(I,l,function(t){return n[t]}.bind(null,l));return I},g.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return g.d(t,"a",t),t},g.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},g.p="./dist/src",g(g.s=31)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return LOG_SCALE; });\n/* unused harmony export LN_TEN */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return log10; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return logRangeFraction; });\n/* unused harmony export DOTTED_LINE */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return DASHED_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return DOT_DASH_LINE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return HORIZONTAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return VERTICAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return getContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return addEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return removeEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return cancelEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return hsvToRGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return findPos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return pageX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return pageY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return dragGetX_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return dragGetY_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return isOK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return isValidPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return floatFormat; });\n/* unused harmony export zeropad */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return DateAccessorsLocal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return DateAccessorsUTC; });\n/* unused harmony export hmsString_ */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return dateString_; });\n/* unused harmony export round_ */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return binarySearch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return dateParser; });\n/* unused harmony export dateStrToMillis */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R\", function() { return update; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S\", function() { return updateDeep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return isArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return isDateLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return createCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return getContextPixelRatio; });\n/* unused harmony export Iterator */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return createIterator; });\n/* unused harmony export requestAnimFrame */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return repeatAndCleanup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return isPixelChangingOptionList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Circles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return detectLineDelimiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return isNodeContainedBy; });\n/* unused harmony export pow */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Q\", function() { return toRGB_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return isCanvasSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return parseFloat_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return numberValueFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return numberAxisLabelFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return dateAxisLabelFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return dateValueFormatter; });\n/* harmony import */ var _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains utility functions used by dygraphs. These\n * are typically static (i.e. not related to any particular dygraph). Examples\n * include date/time formatting functions, basic algorithms (e.g. binary\n * search) and generic DOM-manipulation functions.\n */\n\n/*global Dygraph:false, Node:false */\n\n\n\n\nvar LOG_SCALE = 10;\nvar LN_TEN = Math.log(LOG_SCALE);\n\n/**\n * @private\n * @param {number} x\n * @return {number}\n */\nvar log10 = function(x) {\n  return Math.log(x) / LN_TEN;\n};\n\n/**\n * @private\n * @param {number} r0\n * @param {number} r1\n * @param {number} pct\n * @return {number}\n */\nvar logRangeFraction = function(r0, r1, pct) {\n  // Computing the inverse of toPercentXCoord. The function was arrived at with\n  // the following steps:\n  //\n  // Original calcuation:\n  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));\n  //\n  // Multiply both sides by the right-side denominator.\n  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])\n  //\n  // add log(xRange[0]) to both sides\n  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);\n  //\n  // Swap both sides of the equation,\n  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))\n  //\n  // Use both sides as the exponent in 10^exp and we're done.\n  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))\n\n  var logr0 = log10(r0);\n  var logr1 = log10(r1);\n  var exponent = logr0 + (pct * (logr1 - logr0));\n  var value = Math.pow(LOG_SCALE, exponent);\n  return value;\n};\n\n/** A dotted line stroke pattern. */\nvar DOTTED_LINE = [2, 2];\n/** A dashed line stroke pattern. */\nvar DASHED_LINE = [7, 3];\n/** A dot dash stroke pattern. */\nvar DOT_DASH_LINE = [7, 2, 2, 2];\n\n// Directions for panning and zooming. Use bit operations when combined\n// values are possible.\nvar HORIZONTAL = 1;\nvar VERTICAL = 2;\n\n/**\n * Return the 2d context for a dygraph canvas.\n *\n * This method is only exposed for the sake of replacing the function in\n * automated tests.\n *\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n * @private\n */\nvar getContext = function(canvas) {\n  return /** @type{!CanvasRenderingContext2D}*/(canvas.getContext(\"2d\"));\n};\n\n/**\n * Add an event handler.\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nvar addEvent = function addEvent(elem, type, fn) {\n  elem.addEventListener(type, fn, false);\n};\n\n/**\n * Remove an event handler.\n * @param {!Node} elem The element to remove the event from.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n */\nfunction removeEvent(elem, type, fn) {\n  elem.removeEventListener(type, fn, false);\n};\n\n/**\n * Cancels further processing of an event. This is useful to prevent default\n * browser actions, e.g. highlighting text on a double-click.\n * Based on the article at\n * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel\n * @param {!Event} e The event whose normal behavior should be canceled.\n * @private\n */\nfunction cancelEvent(e) {\n  e = e ? e : window.event;\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  e.cancelBubble = true;\n  e.cancel = true;\n  e.returnValue = false;\n  return false;\n};\n\n/**\n * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This\n * is used to generate default series colors which are evenly spaced on the\n * color wheel.\n * @param { number } hue Range is 0.0-1.0.\n * @param { number } saturation Range is 0.0-1.0.\n * @param { number } value Range is 0.0-1.0.\n * @return { string } \"rgb(r,g,b)\" where r, g and b range from 0-255.\n * @private\n */\nfunction hsvToRGB(hue, saturation, value) {\n  var red;\n  var green;\n  var blue;\n  if (saturation === 0) {\n    red = value;\n    green = value;\n    blue = value;\n  } else {\n    var i = Math.floor(hue * 6);\n    var f = (hue * 6) - i;\n    var p = value * (1 - saturation);\n    var q = value * (1 - (saturation * f));\n    var t = value * (1 - (saturation * (1 - f)));\n    switch (i) {\n      case 1: red = q; green = value; blue = p; break;\n      case 2: red = p; green = value; blue = t; break;\n      case 3: red = p; green = q; blue = value; break;\n      case 4: red = t; green = p; blue = value; break;\n      case 5: red = value; green = p; blue = q; break;\n      case 6: // fall through\n      case 0: red = value; green = t; blue = p; break;\n    }\n  }\n  red = Math.floor(255 * red + 0.5);\n  green = Math.floor(255 * green + 0.5);\n  blue = Math.floor(255 * blue + 0.5);\n  return 'rgb(' + red + ',' + green + ',' + blue + ')';\n};\n\n/**\n * Find the coordinates of an object relative to the top left of the page.\n *\n * @param {Node} obj\n * @return {{x:number,y:number}}\n * @private\n */\nfunction findPos(obj) {\n  var p = obj.getBoundingClientRect(),\n      w = window,\n      d = document.documentElement;\n\n  return {\n    x: p.left + (w.pageXOffset || d.scrollLeft),\n    y: p.top  + (w.pageYOffset || d.scrollTop)\n  }\n};\n\n/**\n * Returns the x-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageX(e) {\n  return (!e.pageX || e.pageX < 0) ? 0 : e.pageX;\n};\n\n/**\n * Returns the y-coordinate of the event in a coordinate system where the\n * top-left corner of the page (not the window) is (0,0).\n * Taken from MochiKit.Signal\n * @param {!Event} e\n * @return {number}\n * @private\n */\nfunction pageY(e) {\n  return (!e.pageY || e.pageY < 0) ? 0 : e.pageY;\n};\n\n/**\n * Converts page the x-coordinate of the event to pixel x-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved to the right.\n */\nfunction dragGetX_(e, context) {\n  return pageX(e) - context.px;\n};\n\n/**\n * Converts page the y-coordinate of the event to pixel y-coordinates on the\n * canvas (i.e. DOM Coords).\n * @param {!Event} e Drag event.\n * @param {!DygraphInteractionContext} context Interaction context object.\n * @return {number} The amount by which the drag has moved down.\n */\nfunction dragGetY_(e, context) {\n  return pageY(e) - context.py;\n};\n\n/**\n * This returns true unless the parameter is 0, null, undefined or NaN.\n * TODO(danvk): rename this function to something like 'isNonZeroNan'.\n *\n * @param {number} x The number to consider.\n * @return {boolean} Whether the number is zero or NaN.\n * @private\n */\nfunction isOK(x) {\n  return !!x && !isNaN(x);\n};\n\n/**\n * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid\n *     points are {x, y} objects\n * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid\n * @return {boolean} Whether the point has numeric x and y.\n * @private\n */\nfunction isValidPoint(p, opt_allowNaNY) {\n  if (!p) return false;  // null or undefined object\n  if (p.yval === null) return false;  // missing point\n  if (p.x === null || p.x === undefined) return false;\n  if (p.y === null || p.y === undefined) return false;\n  if (isNaN(p.x) || (!opt_allowNaNY && isNaN(p.y))) return false;\n  return true;\n};\n\n/**\n * Number formatting function which mimics the behavior of %g in printf, i.e.\n * either exponential or fixed format (without trailing 0s) is used depending on\n * the length of the generated string.  The advantage of this format is that\n * there is a predictable upper bound on the resulting string length,\n * significant figures are not dropped, and normal numbers are not displayed in\n * exponential notation.\n *\n * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.\n * It creates strings which are too long for absolute values between 10^-4 and\n * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for\n * output examples.\n *\n * @param {number} x The number to format\n * @param {number=} opt_precision The precision to use, default 2.\n * @return {string} A string formatted like %g in printf.  The max generated\n *                  string length should be precision + 6 (e.g 1.123e+300).\n */\nfunction floatFormat(x, opt_precision) {\n  // Avoid invalid precision values; [1, 21] is the valid range.\n  var p = Math.min(Math.max(1, opt_precision || 2), 21);\n\n  // This is deceptively simple.  The actual algorithm comes from:\n  //\n  // Max allowed length = p + 4\n  // where 4 comes from 'e+n' and '.'.\n  //\n  // Length of fixed format = 2 + y + p\n  // where 2 comes from '0.' and y = # of leading zeroes.\n  //\n  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is\n  // 1.0e-3.\n  //\n  // Since the behavior of toPrecision() is identical for larger numbers, we\n  // don't have to worry about the other bound.\n  //\n  // Finally, the argument for toExponential() is the number of trailing digits,\n  // so we take off 1 for the value before the '.'.\n  return (Math.abs(x) < 1.0e-3 && x !== 0.0) ?\n      x.toExponential(p - 1) : x.toPrecision(p);\n};\n\n/**\n * Converts '9' to '09' (useful for dates)\n * @param {number} x\n * @return {string}\n * @private\n */\nfunction zeropad(x) {\n  if (x < 10) return \"0\" + x; else return \"\" + x;\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day, hour, minute, second and millisecond) according to local time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsLocal = {\n  getFullYear:     d => d.getFullYear(),\n  getMonth:        d => d.getMonth(),\n  getDate:         d => d.getDate(),\n  getHours:        d => d.getHours(),\n  getMinutes:      d => d.getMinutes(),\n  getSeconds:      d => d.getSeconds(),\n  getMilliseconds: d => d.getMilliseconds(),\n  getDay:          d => d.getDay(),\n  makeDate:        function(y, m, d, hh, mm, ss, ms) {\n    return new Date(y, m, d, hh, mm, ss, ms);\n  }\n};\n\n/**\n * Date accessors to get the parts of a calendar date (year, month,\n * day of month, hour, minute, second and millisecond) according to UTC time,\n * and factory method to call the Date constructor with an array of arguments.\n */\nvar DateAccessorsUTC = {\n  getFullYear:     d => d.getUTCFullYear(),\n  getMonth:        d => d.getUTCMonth(),\n  getDate:         d => d.getUTCDate(),\n  getHours:        d => d.getUTCHours(),\n  getMinutes:      d => d.getUTCMinutes(),\n  getSeconds:      d => d.getUTCSeconds(),\n  getMilliseconds: d => d.getUTCMilliseconds(),\n  getDay:          d => d.getUTCDay(),\n  makeDate:        function(y, m, d, hh, mm, ss, ms) {\n    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));\n  }\n};\n\n/**\n * Return a string version of the hours, minutes and seconds portion of a date.\n * @param {number} hh The hours (from 0-23)\n * @param {number} mm The minutes (from 0-59)\n * @param {number} ss The seconds (from 0-59)\n * @return {string} A time of the form \"HH:MM\" or \"HH:MM:SS\"\n * @private\n */\nfunction hmsString_(hh, mm, ss, ms) {\n  var ret = zeropad(hh) + \":\" + zeropad(mm);\n  if (ss) {\n    ret += \":\" + zeropad(ss);\n    if (ms) {\n      var str = \"\" + ms;\n      ret += \".\" + ('000'+str).substring(str.length);\n    }\n  }\n  return ret;\n};\n\n/**\n * Convert a JS date (millis since epoch) to a formatted string.\n * @param {number} time The JavaScript time value (ms since epoch)\n * @param {boolean} utc Whether output UTC or local time\n * @return {string} A date of one of these forms:\n *     \"YYYY/MM/DD\", \"YYYY/MM/DD HH:MM\" or \"YYYY/MM/DD HH:MM:SS\"\n * @private\n */\nfunction dateString_(time, utc) {\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n  var date = new Date(time);\n  var y = accessors.getFullYear(date);\n  var m = accessors.getMonth(date);\n  var d = accessors.getDate(date);\n  var hh = accessors.getHours(date);\n  var mm = accessors.getMinutes(date);\n  var ss = accessors.getSeconds(date);\n  var ms = accessors.getMilliseconds(date);\n  // Get a year string:\n  var year = \"\" + y;\n  // Get a 0 padded month string\n  var month = zeropad(m + 1);  //months are 0-offset, sigh\n  // Get a 0 padded day string\n  var day = zeropad(d);\n  var frac = hh * 3600 + mm * 60 + ss + 1e-3 * ms;\n  var ret = year + \"/\" + month + \"/\" + day;\n  if (frac) {\n    ret += \" \" + hmsString_(hh, mm, ss, ms);\n  }\n  return ret;\n};\n\n/**\n * Round a number to the specified number of digits past the decimal point.\n * @param {number} num The number to round\n * @param {number} places The number of decimals to which to round\n * @return {number} The rounded number\n * @private\n */\nfunction round_(num, places) {\n  var shift = Math.pow(10, places);\n  return Math.round(num * shift)/shift;\n};\n\n/**\n * Implementation of binary search over an array.\n * Currently does not work when val is outside the range of arry's values.\n * @param {number} val the value to search for\n * @param {Array.<number>} arry is the value over which to search\n * @param {number} abs If abs > 0, find the lowest entry greater than val\n *     If abs < 0, find the highest entry less than val.\n *     If abs == 0, find the entry that equals val.\n * @param {number=} low The first index in arry to consider (optional)\n * @param {number=} high The last index in arry to consider (optional)\n * @return {number} Index of the element, or -1 if it isn't found.\n * @private\n */\nfunction binarySearch(val, arry, abs, low, high) {\n  if (low === null || low === undefined ||\n      high === null || high === undefined) {\n    low = 0;\n    high = arry.length - 1;\n  }\n  if (low > high) {\n    return -1;\n  }\n  if (abs === null || abs === undefined) {\n    abs = 0;\n  }\n  var validIndex = function(idx) {\n    return idx >= 0 && idx < arry.length;\n  };\n  var mid = parseInt((low + high) / 2, 10);\n  var element = arry[mid];\n  var idx;\n  if (element == val) {\n    return mid;\n  } else if (element > val) {\n    if (abs > 0) {\n      // Accept if element > val, but also if prior element < val.\n      idx = mid - 1;\n      if (validIndex(idx) && arry[idx] < val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, low, mid - 1);\n  } else if (element < val) {\n    if (abs < 0) {\n      // Accept if element < val, but also if prior element > val.\n      idx = mid + 1;\n      if (validIndex(idx) && arry[idx] > val) {\n        return mid;\n      }\n    }\n    return binarySearch(val, arry, abs, mid + 1, high);\n  }\n  return -1;  // can't actually happen, but makes closure compiler happy\n};\n\n/**\n * Parses a date, returning the number of milliseconds since epoch. This can be\n * passed in as an xValueParser in the Dygraph constructor.\n * TODO(danvk): enumerate formats that this understands.\n *\n * @param {string} dateStr A date in a variety of possible string formats.\n * @return {number} Milliseconds since epoch.\n * @private\n */\nfunction dateParser(dateStr) {\n  var dateStrSlashed;\n  var d;\n\n  // Let the system try the format first, with one caveat:\n  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.\n  // dygraphs displays dates in local time, so this will result in surprising\n  // inconsistencies. But if you specify \"T\" or \"Z\" (i.e. YYYY-MM-DDTHH:MM:SS),\n  // then you probably know what you're doing, so we'll let you go ahead.\n  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255\n  if (dateStr.search(\"-\") == -1 ||\n      dateStr.search(\"T\") != -1 || dateStr.search(\"Z\") != -1) {\n    d = dateStrToMillis(dateStr);\n    if (d && !isNaN(d)) return d;\n  }\n\n  if (dateStr.search(\"-\") != -1) {  // e.g. '2009-7-12' or '2009-07-12'\n    dateStrSlashed = dateStr.replace(\"-\", \"/\", \"g\");\n    while (dateStrSlashed.search(\"-\") != -1) {\n      dateStrSlashed = dateStrSlashed.replace(\"-\", \"/\");\n    }\n    d = dateStrToMillis(dateStrSlashed);\n  } else if (dateStr.length == 8) {  // e.g. '20090712'\n    // TODO(danvk): remove support for this format. It's confusing.\n    dateStrSlashed = dateStr.substr(0,4) + \"/\" + dateStr.substr(4,2) + \"/\" +\n        dateStr.substr(6,2);\n    d = dateStrToMillis(dateStrSlashed);\n  } else {\n    // Any format that Date.parse will accept, e.g. \"2009/07/12\" or\n    // \"2009/07/12 12:34:56\"\n    d = dateStrToMillis(dateStr);\n  }\n\n  if (!d || isNaN(d)) {\n    console.error(\"Couldn't parse \" + dateStr + \" as a date\");\n  }\n  return d;\n};\n\n/**\n * This is identical to JavaScript's built-in Date.parse() method, except that\n * it doesn't get replaced with an incompatible method by aggressive JS\n * libraries like MooTools or Joomla.\n * @param {string} str The date string, e.g. \"2011/05/06\"\n * @return {number} millis since epoch\n * @private\n */\nfunction dateStrToMillis(str) {\n  return new Date(str).getTime();\n};\n\n// These functions are all based on MochiKit.\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n */\nfunction update(self, o) {\n  if (typeof(o) != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        self[k] = o[k];\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * Copies all the properties from o to self.\n *\n * @param {!Object} self\n * @param {!Object} o\n * @return {!Object}\n * @private\n */\nfunction updateDeep(self, o) {\n  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  function isNode(o) {\n    return (\n      typeof Node === \"object\" ? o instanceof Node :\n      typeof o === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName===\"string\"\n    );\n  }\n\n  if (typeof(o) != 'undefined' && o !== null) {\n    for (var k in o) {\n      if (o.hasOwnProperty(k)) {\n        if (o[k] === null) {\n          self[k] = null;\n        } else if (isArrayLike(o[k])) {\n          self[k] = o[k].slice();\n        } else if (isNode(o[k])) {\n          // DOM objects are shallowly-copied.\n          self[k] = o[k];\n        } else if (typeof(o[k]) == 'object') {\n          if (typeof(self[k]) != 'object' || self[k] === null) {\n            self[k] = {};\n          }\n          updateDeep(self[k], o[k]);\n        } else {\n          self[k] = o[k];\n        }\n      }\n    }\n  }\n  return self;\n};\n\n/**\n * @param {*} o\n * @return {boolean}\n * @private\n */\nfunction isArrayLike(o) {\n  var typ = typeof(o);\n  if (\n      (typ != 'object' && !(typ == 'function' &&\n        typeof(o.item) == 'function')) ||\n      o === null ||\n      typeof(o.length) != 'number' ||\n      o.nodeType === 3\n     ) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @param {Object} o\n * @return {boolean}\n * @private\n */\nfunction isDateLike(o) {\n  if (typeof(o) != \"object\" || o === null ||\n      typeof(o.getTime) != 'function') {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Note: this only seems to work for arrays.\n * @param {!Array} o\n * @return {!Array}\n * @private\n */\nfunction clone(o) {\n  // TODO(danvk): figure out how MochiKit's version works\n  var r = [];\n  for (var i = 0; i < o.length; i++) {\n    if (isArrayLike(o[i])) {\n      r.push(clone(o[i]));\n    } else {\n      r.push(o[i]);\n    }\n  }\n  return r;\n};\n\n/**\n * Create a new canvas element.\n *\n * @return {!HTMLCanvasElement}\n * @private\n */\nfunction createCanvas() {\n  return document.createElement('canvas');\n};\n\n/**\n * Returns the context's pixel ratio, which is the ratio between the device\n * pixel ratio and the backing store ratio. Typically this is 1 for conventional\n * displays, and > 1 for HiDPI displays (such as the Retina MBP).\n * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.\n *\n * @param {!CanvasRenderingContext2D} context The canvas's 2d context.\n * @return {number} The ratio of the device pixel ratio and the backing store\n * ratio for the specified context.\n */\nfunction getContextPixelRatio(context) {\n  try {\n    var devicePixelRatio = window.devicePixelRatio;\n    var backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                            context.mozBackingStorePixelRatio ||\n                            context.msBackingStorePixelRatio ||\n                            context.oBackingStorePixelRatio ||\n                            context.backingStorePixelRatio || 1;\n    if (devicePixelRatio !== undefined) {\n      return devicePixelRatio / backingStoreRatio;\n    } else {\n      // At least devicePixelRatio must be defined for this ratio to make sense.\n      // We default backingStoreRatio to 1: this does not exist on some browsers\n      // (i.e. desktop Chrome).\n      return 1;\n    }\n  } catch (e) {\n    return 1;\n  }\n};\n\n/**\n * TODO(danvk): use @template here when it's better supported for classes.\n * @param {!Array} array\n * @param {number} start\n * @param {number} length\n * @param {function(!Array,?):boolean=} predicate\n * @constructor\n */\nfunction Iterator(array, start, length, predicate) {\n  start = start || 0;\n  length = length || array.length;\n  this.hasNext = true; // Use to identify if there's another element.\n  this.peek = null; // Use for look-ahead\n  this.start_ = start;\n  this.array_ = array;\n  this.predicate_ = predicate;\n  this.end_ = Math.min(array.length, start + length);\n  this.nextIdx_ = start - 1; // use -1 so initial advance works.\n  this.next(); // ignoring result.\n};\n\n/**\n * @return {Object}\n */\nIterator.prototype.next = function() {\n  if (!this.hasNext) {\n    return null;\n  }\n  var obj = this.peek;\n\n  var nextIdx = this.nextIdx_ + 1;\n  var found = false;\n  while (nextIdx < this.end_) {\n    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {\n      this.peek = this.array_[nextIdx];\n      found = true;\n      break;\n    }\n    nextIdx++;\n  }\n  this.nextIdx_ = nextIdx;\n  if (!found) {\n    this.hasNext = false;\n    this.peek = null;\n  }\n  return obj;\n};\n\n/**\n * Returns a new iterator over array, between indexes start and\n * start + length, and only returns entries that pass the accept function\n *\n * @param {!Array} array the array to iterate over.\n * @param {number} start the first index to iterate over, 0 if absent.\n * @param {number} length the number of elements in the array to iterate over.\n *     This, along with start, defines a slice of the array, and so length\n *     doesn't imply the number of elements in the iterator when accept doesn't\n *     always accept all values. array.length when absent.\n * @param {function(?):boolean=} opt_predicate a function that takes\n *     parameters array and idx, which returns true when the element should be\n *     returned.  If omitted, all elements are accepted.\n * @private\n */\nfunction createIterator(array, start, length, opt_predicate) {\n  return new Iterator(array, start, length, opt_predicate);\n};\n\n// Shim layer with setTimeout fallback.\n// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// Should be called with the window context:\n//   Dygraph.requestAnimFrame.call(window, function() {})\nvar requestAnimFrame = (function() {\n  return window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          window.oRequestAnimationFrame      ||\n          window.msRequestAnimationFrame     ||\n          function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n          };\n})();\n\n/**\n * Call a function at most maxFrames times at an attempted interval of\n * framePeriodInMillis, then call a cleanup function once. repeatFn is called\n * once immediately, then at most (maxFrames - 1) times asynchronously. If\n * maxFrames==1, then cleanup_fn() is also called synchronously.  This function\n * is used to sequence animation.\n * @param {function(number)} repeatFn Called repeatedly -- takes the frame\n *     number (from 0 to maxFrames-1) as an argument.\n * @param {number} maxFrames The max number of times to call repeatFn\n * @param {number} framePeriodInMillis Max requested time between frames.\n * @param {function()} cleanupFn A function to call after all repeatFn calls.\n * @private\n */\nfunction repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis,\n    cleanupFn) {\n  var frameNumber = 0;\n  var previousFrameNumber;\n  var startTime = new Date().getTime();\n  repeatFn(frameNumber);\n  if (maxFrames == 1) {\n    cleanupFn();\n    return;\n  }\n  var maxFrameArg = maxFrames - 1;\n\n  (function loop() {\n    if (frameNumber >= maxFrames) return;\n    requestAnimFrame.call(window, function() {\n      // Determine which frame to draw based on the delay so far.  Will skip\n      // frames if necessary.\n      var currentTime = new Date().getTime();\n      var delayInMillis = currentTime - startTime;\n      previousFrameNumber = frameNumber;\n      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);\n      var frameDelta = frameNumber - previousFrameNumber;\n      // If we predict that the subsequent repeatFn call will overshoot our\n      // total frame target, so our last call will cause a stutter, then jump to\n      // the last call immediately.  If we're going to cause a stutter, better\n      // to do it faster than slower.\n      var predictOvershootStutter = (frameNumber + frameDelta) > maxFrameArg;\n      if (predictOvershootStutter || (frameNumber >= maxFrameArg)) {\n        repeatFn(maxFrameArg);  // Ensure final call with maxFrameArg.\n        cleanupFn();\n      } else {\n        if (frameDelta !== 0) {  // Don't call repeatFn with duplicate frames.\n          repeatFn(frameNumber);\n        }\n        loop();\n      }\n    });\n  })();\n};\n\n// A whitelist of options that do not change pixel positions.\nvar pixelSafeOptions = {\n  'annotationClickHandler': true,\n  'annotationDblClickHandler': true,\n  'annotationMouseOutHandler': true,\n  'annotationMouseOverHandler': true,\n  'axisLineColor': true,\n  'axisLineWidth': true,\n  'clickCallback': true,\n  'drawCallback': true,\n  'drawHighlightPointCallback': true,\n  'drawPoints': true,\n  'drawPointCallback': true,\n  'drawGrid': true,\n  'fillAlpha': true,\n  'gridLineColor': true,\n  'gridLineWidth': true,\n  'hideOverlayOnMouseOut': true,\n  'highlightCallback': true,\n  'highlightCircleSize': true,\n  'interactionModel': true,\n  'labelsDiv': true,\n  'labelsKMB': true,\n  'labelsKMG2': true,\n  'labelsSeparateLines': true,\n  'labelsShowZeroValues': true,\n  'legend': true,\n  'panEdgeFraction': true,\n  'pixelsPerYLabel': true,\n  'pointClickCallback': true,\n  'pointSize': true,\n  'rangeSelectorPlotFillColor': true,\n  'rangeSelectorPlotFillGradientColor': true,\n  'rangeSelectorPlotStrokeColor': true,\n  'rangeSelectorBackgroundStrokeColor': true,\n  'rangeSelectorBackgroundLineWidth': true,\n  'rangeSelectorPlotLineWidth': true,\n  'rangeSelectorForegroundStrokeColor': true,\n  'rangeSelectorForegroundLineWidth': true,\n  'rangeSelectorAlpha': true,\n  'showLabelsOnHighlight': true,\n  'showRoller': true,\n  'strokeWidth': true,\n  'underlayCallback': true,\n  'unhighlightCallback': true,\n  'zoomCallback': true\n};\n\n/**\n * This function will scan the option list and determine if they\n * require us to recalculate the pixel positions of each point.\n * TODO: move this into dygraph-options.js\n * @param {!Array.<string>} labels a list of options to check.\n * @param {!Object} attrs\n * @return {boolean} true if the graph needs new points else false.\n * @private\n */\nfunction isPixelChangingOptionList(labels, attrs) {\n  // Assume that we do not require new points.\n  // This will change to true if we actually do need new points.\n\n  // Create a dictionary of series names for faster lookup.\n  // If there are no labels, then the dictionary stays empty.\n  var seriesNamesDictionary = { };\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      seriesNamesDictionary[labels[i]] = true;\n    }\n  }\n\n  // Scan through a flat (i.e. non-nested) object of options.\n  // Returns true/false depending on whether new points are needed.\n  var scanFlatOptions = function(options) {\n    for (var property in options) {\n      if (options.hasOwnProperty(property) &&\n          !pixelSafeOptions[property]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Iterate through the list of updated options.\n  for (var property in attrs) {\n    if (!attrs.hasOwnProperty(property)) continue;\n\n    // Find out of this field is actually a series specific options list.\n    if (property == 'highlightSeriesOpts' ||\n        (seriesNamesDictionary[property] && !attrs.series)) {\n      // This property value is a list of options for this series.\n      if (scanFlatOptions(attrs[property])) return true;\n    } else if (property == 'series' || property == 'axes') {\n      // This is twice-nested options list.\n      var perSeries = attrs[property];\n      for (var series in perSeries) {\n        if (perSeries.hasOwnProperty(series) &&\n            scanFlatOptions(perSeries[series])) {\n          return true;\n        }\n      }\n    } else {\n      // If this was not a series specific option list, check if it's a pixel\n      // changing property.\n      if (!pixelSafeOptions[property]) return true;\n    }\n  }\n\n  return false;\n};\n\nvar Circles = {\n  DEFAULT : function(g, name, ctx, canvasx, canvasy, color, radius) {\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n  }\n  // For more shapes, include extras/shapes.js\n};\n\n/**\n * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.\n * @param {string} data\n * @return {?string} the delimiter that was detected (or null on failure).\n */\nfunction detectLineDelimiter(data) {\n  for (var i = 0; i < data.length; i++) {\n    var code = data.charAt(i);\n    if (code === '\\r') {\n      // Might actually be \"\\r\\n\".\n      if (((i + 1) < data.length) && (data.charAt(i + 1) === '\\n')) {\n        return '\\r\\n';\n      }\n      return code;\n    }\n    if (code === '\\n') {\n      // Might actually be \"\\n\\r\".\n      if (((i + 1) < data.length) && (data.charAt(i + 1) === '\\r')) {\n        return '\\n\\r';\n      }\n      return code;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Is one node contained by another?\n * @param {Node} containee The contained node.\n * @param {Node} container The container node.\n * @return {boolean} Whether containee is inside (or equal to) container.\n * @private\n */\nfunction isNodeContainedBy(containee, container) {\n  if (container === null || containee === null) {\n    return false;\n  }\n  var containeeNode = /** @type {Node} */ (containee);\n  while (containeeNode && containeeNode !== container) {\n    containeeNode = containeeNode.parentNode;\n  }\n  return (containeeNode === container);\n};\n\n// This masks some numeric issues in older versions of Firefox,\n// where 1.0/Math.pow(10,2) != Math.pow(10,-2).\n/** @type {function(number,number):number} */\nfunction pow(base, exp) {\n  if (exp < 0) {\n    return 1.0 / Math.pow(base, -exp);\n  }\n  return Math.pow(base, exp);\n};\n\nvar RGBA_RE = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})(?:,\\s*([01](?:\\.\\d+)?))?\\)$/;\n\n/**\n * Helper for toRGB_ which parses strings of the form:\n * rgb(123, 45, 67)\n * rgba(123, 45, 67, 0.5)\n * @return parsed {r,g,b,a?} tuple or null.\n */\nfunction parseRGBA(rgbStr) {\n  var bits = RGBA_RE.exec(rgbStr);\n  if (!bits) return null;\n  var r = parseInt(bits[1], 10),\n      g = parseInt(bits[2], 10),\n      b = parseInt(bits[3], 10);\n  if (bits[4]) {\n    return {r: r, g: g, b: b, a: parseFloat(bits[4])};\n  } else {\n    return {r: r, g: g, b: b};\n  }\n}\n\n/**\n * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.\n *\n * @param {!string} colorStr Any valid CSS color string.\n * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.\n * @private\n */\nfunction toRGB_(colorStr) {\n  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM\n  // manipulation.  If that fails (e.g. for named colors like 'red'), then\n  // create a hidden DOM element and parse its computed color.\n  var rgb = parseRGBA(colorStr);\n  if (rgb) return rgb;\n\n  var div = document.createElement('div');\n  div.style.backgroundColor = colorStr;\n  div.style.visibility = 'hidden';\n  document.body.appendChild(div);\n  var rgbStr = window.getComputedStyle(div, null).backgroundColor;\n  document.body.removeChild(div);\n  return parseRGBA(rgbStr);\n};\n\n/**\n * Checks whether the browser supports the &lt;canvas&gt; tag.\n * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an\n *     optimization if you have one.\n * @return {boolean} Whether the browser supports canvas.\n */\nfunction isCanvasSupported(opt_canvasElement) {\n  try {\n    var canvas = opt_canvasElement || document.createElement(\"canvas\");\n    canvas.getContext(\"2d\");\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Parses the value as a floating point number. This is like the parseFloat()\n * built-in, but with a few differences:\n * - the empty string is parsed as null, rather than NaN.\n * - if the string cannot be parsed at all, an error is logged.\n * If the string can't be parsed, this method returns null.\n * @param {string} x The string to be parsed\n * @param {number=} opt_line_no The line number from which the string comes.\n * @param {string=} opt_line The text of the line from which the string comes.\n */\nfunction parseFloat_(x, opt_line_no, opt_line) {\n  var val = parseFloat(x);\n  if (!isNaN(val)) return val;\n\n  // Try to figure out what happeend.\n  // If the value is the empty string, parse it as null.\n  if (/^ *$/.test(x)) return null;\n\n  // If it was actually \"NaN\", return it as NaN.\n  if (/^ *nan *$/i.test(x)) return NaN;\n\n  // Looks like a parsing error.\n  var msg = \"Unable to parse '\" + x + \"' as a number\";\n  if (opt_line !== undefined && opt_line_no !== undefined) {\n    msg += \" on line \" + (1+(opt_line_no||0)) + \" ('\" + opt_line + \"') of CSV.\";\n  }\n  console.error(msg);\n\n  return null;\n};\n\n\n// Label constants for the labelsKMB and labelsKMG2 options.\n// (i.e. '100000' -> '100K')\nvar KMB_LABELS = [ 'K', 'M', 'B', 'T', 'Q' ];\nvar KMG2_BIG_LABELS = [ 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y' ];\nvar KMG2_SMALL_LABELS = [ 'm', 'u', 'n', 'p', 'f', 'a', 'z', 'y' ];\n\n/**\n * @private\n * Return a string version of a number. This respects the digitsAfterDecimal\n * and maxNumberWidth options.\n * @param {number} x The number to be formatted\n * @param {Dygraph} opts An options view\n */\nfunction numberValueFormatter(x, opts) {\n  var sigFigs = opts('sigFigs');\n\n  if (sigFigs !== null) {\n    // User has opted for a fixed number of significant figures.\n    return floatFormat(x, sigFigs);\n  }\n\n  var digits = opts('digitsAfterDecimal');\n  var maxNumberWidth = opts('maxNumberWidth');\n\n  var kmb = opts('labelsKMB');\n  var kmg2 = opts('labelsKMG2');\n\n  var label;\n\n  // switch to scientific notation if we underflow or overflow fixed display.\n  if (x !== 0.0 &&\n      (Math.abs(x) >= Math.pow(10, maxNumberWidth) ||\n       Math.abs(x) < Math.pow(10, -digits))) {\n    label = x.toExponential(digits);\n  } else {\n    label = '' + round_(x, digits);\n  }\n\n  if (kmb || kmg2) {\n    var k;\n    var k_labels = [];\n    var m_labels = [];\n    if (kmb) {\n      k = 1000;\n      k_labels = KMB_LABELS;\n    }\n    if (kmg2) {\n      if (kmb) console.warn(\"Setting both labelsKMB and labelsKMG2. Pick one!\");\n      k = 1024;\n      k_labels = KMG2_BIG_LABELS;\n      m_labels = KMG2_SMALL_LABELS;\n    }\n\n    var absx = Math.abs(x);\n    var n = pow(k, k_labels.length);\n    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {\n      if (absx >= n) {\n        label = round_(x / n, digits) + k_labels[j];\n        break;\n      }\n    }\n    if (kmg2) {\n      // TODO(danvk): clean up this logic. Why so different than kmb?\n      var x_parts = String(x.toExponential()).split('e-');\n      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {\n        if (x_parts[1] % 3 > 0) {\n          label = round_(x_parts[0] /\n              pow(10, (x_parts[1] % 3)),\n              digits);\n        } else {\n          label = Number(x_parts[0]).toFixed(2);\n        }\n        label += m_labels[Math.floor(x_parts[1] / 3) - 1];\n      }\n    }\n  }\n\n  return label;\n};\n\n/**\n * variant for use as an axisLabelFormatter.\n * @private\n */\nfunction numberAxisLabelFormatter(x, granularity, opts) {\n  return numberValueFormatter.call(this, x, opts);\n};\n\n/**\n * @type {!Array.<string>}\n * @private\n * @constant\n */\nvar SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n\n/**\n * Convert a JS date to a string appropriate to display on an axis that\n * is displaying values at the stated granularity. This respects the\n * labelsUTC option.\n * @param {Date} date The date to format\n * @param {number} granularity One of the Dygraph granularity constants\n * @param {Dygraph} opts An options view\n * @return {string} The date formatted as local time\n * @private\n */\nfunction dateAxisLabelFormatter(date, granularity, opts) {\n  var utc = opts('labelsUTC');\n  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;\n\n  var year = accessors.getFullYear(date),\n      month = accessors.getMonth(date),\n      day = accessors.getDate(date),\n      hours = accessors.getHours(date),\n      mins = accessors.getMinutes(date),\n      secs = accessors.getSeconds(date),\n      millis = accessors.getMilliseconds(date);\n\n  if (granularity >= _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* Granularity */ \"a\"].DECADAL) {\n    return '' + year;\n  } else if (granularity >= _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* Granularity */ \"a\"].MONTHLY) {\n    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;\n  } else {\n    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;\n    if (frac === 0 || granularity >= _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* Granularity */ \"a\"].DAILY) {\n      // e.g. '21 Jan' (%d%b)\n      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];\n    } else if (granularity < _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* Granularity */ \"a\"].SECONDLY) {\n      // e.g. 40.310 (meaning 40 seconds and 310 milliseconds)\n      var str = \"\" + millis;\n      return zeropad(secs) + \".\" + ('000'+str).substring(str.length);\n    } else if (granularity > _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* Granularity */ \"a\"].MINUTELY) {\n      return hmsString_(hours, mins, secs, 0);\n    } else {\n      return hmsString_(hours, mins, secs, millis);\n    }\n  }\n};\n// alias in case anyone is referencing the old method.\n// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;\n\n/**\n * Return a string version of a JS date for a value label. This respects the\n * labelsUTC option.\n * @param {Date} date The date to be formatted\n * @param {Dygraph} opts An options view\n * @private\n */\nfunction dateValueFormatter(d, opts) {\n  return dateString_(d, opts('labelsUTC'));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC11dGlscy5qcz9iZGU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGJ5IGR5Z3JhcGhzLiBUaGVzZVxuICogYXJlIHR5cGljYWxseSBzdGF0aWMgKGkuZS4gbm90IHJlbGF0ZWQgdG8gYW55IHBhcnRpY3VsYXIgZHlncmFwaCkuIEV4YW1wbGVzXG4gKiBpbmNsdWRlIGRhdGUvdGltZSBmb3JtYXR0aW5nIGZ1bmN0aW9ucywgYmFzaWMgYWxnb3JpdGhtcyAoZS5nLiBiaW5hcnlcbiAqIHNlYXJjaCkgYW5kIGdlbmVyaWMgRE9NLW1hbmlwdWxhdGlvbiBmdW5jdGlvbnMuXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSwgTm9kZTpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIER5Z3JhcGhUaWNrZXJzIGZyb20gJy4vZHlncmFwaC10aWNrZXJzJztcblxuZXhwb3J0IHZhciBMT0dfU0NBTEUgPSAxMDtcbmV4cG9ydCB2YXIgTE5fVEVOID0gTWF0aC5sb2coTE9HX1NDQUxFKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBsb2cxMCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTE5fVEVOO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIwXG4gKiBAcGFyYW0ge251bWJlcn0gcjFcbiAqIEBwYXJhbSB7bnVtYmVyfSBwY3RcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBsb2dSYW5nZUZyYWN0aW9uID0gZnVuY3Rpb24ocjAsIHIxLCBwY3QpIHtcbiAgLy8gQ29tcHV0aW5nIHRoZSBpbnZlcnNlIG9mIHRvUGVyY2VudFhDb29yZC4gVGhlIGZ1bmN0aW9uIHdhcyBhcnJpdmVkIGF0IHdpdGhcbiAgLy8gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgLy9cbiAgLy8gT3JpZ2luYWwgY2FsY3VhdGlvbjpcbiAgLy8gcGN0ID0gKGxvZyh4KSAtIGxvZyh4UmFuZ2VbMF0pKSAvIChsb2coeFJhbmdlWzFdKSAtIGxvZyh4UmFuZ2VbMF0pKSk7XG4gIC8vXG4gIC8vIE11bHRpcGx5IGJvdGggc2lkZXMgYnkgdGhlIHJpZ2h0LXNpZGUgZGVub21pbmF0b3IuXG4gIC8vIHBjdCAqIChsb2coeFJhbmdlWzFdIC0gbG9nKHhSYW5nZVswXSkpKSA9IGxvZyh4KSAtIGxvZyh4UmFuZ2VbMF0pXG4gIC8vXG4gIC8vIGFkZCBsb2coeFJhbmdlWzBdKSB0byBib3RoIHNpZGVzXG4gIC8vIGxvZyh4UmFuZ2VbMF0pICsgKHBjdCAqIChsb2coeFJhbmdlWzFdKSAtIGxvZyh4UmFuZ2VbMF0pKSA9IGxvZyh4KTtcbiAgLy9cbiAgLy8gU3dhcCBib3RoIHNpZGVzIG9mIHRoZSBlcXVhdGlvbixcbiAgLy8gbG9nKHgpID0gbG9nKHhSYW5nZVswXSkgKyAocGN0ICogKGxvZyh4UmFuZ2VbMV0pIC0gbG9nKHhSYW5nZVswXSkpXG4gIC8vXG4gIC8vIFVzZSBib3RoIHNpZGVzIGFzIHRoZSBleHBvbmVudCBpbiAxMF5leHAgYW5kIHdlJ3JlIGRvbmUuXG4gIC8vIHggPSAxMCBeIChsb2coeFJhbmdlWzBdKSArIChwY3QgKiAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkpXG5cbiAgdmFyIGxvZ3IwID0gbG9nMTAocjApO1xuICB2YXIgbG9ncjEgPSBsb2cxMChyMSk7XG4gIHZhciBleHBvbmVudCA9IGxvZ3IwICsgKHBjdCAqIChsb2dyMSAtIGxvZ3IwKSk7XG4gIHZhciB2YWx1ZSA9IE1hdGgucG93KExPR19TQ0FMRSwgZXhwb25lbnQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKiogQSBkb3R0ZWQgbGluZSBzdHJva2UgcGF0dGVybi4gKi9cbmV4cG9ydCB2YXIgRE9UVEVEX0xJTkUgPSBbMiwgMl07XG4vKiogQSBkYXNoZWQgbGluZSBzdHJva2UgcGF0dGVybi4gKi9cbmV4cG9ydCB2YXIgREFTSEVEX0xJTkUgPSBbNywgM107XG4vKiogQSBkb3QgZGFzaCBzdHJva2UgcGF0dGVybi4gKi9cbmV4cG9ydCB2YXIgRE9UX0RBU0hfTElORSA9IFs3LCAyLCAyLCAyXTtcblxuLy8gRGlyZWN0aW9ucyBmb3IgcGFubmluZyBhbmQgem9vbWluZy4gVXNlIGJpdCBvcGVyYXRpb25zIHdoZW4gY29tYmluZWRcbi8vIHZhbHVlcyBhcmUgcG9zc2libGUuXG5leHBvcnQgdmFyIEhPUklaT05UQUwgPSAxO1xuZXhwb3J0IHZhciBWRVJUSUNBTCA9IDI7XG5cbi8qKlxuICogUmV0dXJuIHRoZSAyZCBjb250ZXh0IGZvciBhIGR5Z3JhcGggY2FudmFzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgZXhwb3NlZCBmb3IgdGhlIHNha2Ugb2YgcmVwbGFjaW5nIHRoZSBmdW5jdGlvbiBpblxuICogYXV0b21hdGVkIHRlc3RzLlxuICpcbiAqIEBwYXJhbSB7IUhUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEByZXR1cm4geyFDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgdmFyIGdldENvbnRleHQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZXshQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSovKGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7IU5vZGV9IGVsZW0gVGhlIGVsZW1lbnQgdG8gYWRkIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW1vdmUnLlxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCk6KGJvb2xlYW58dW5kZWZpbmVkKX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBvbiB0aGUgZXZlbnQuIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyOiB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uIGFkZEV2ZW50KGVsZW0sIHR5cGUsIGZuKSB7XG4gIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7IU5vZGV9IGVsZW0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBldmVudCBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50LCBlLmcuICdjbGljaycgb3IgJ21vdXNlbW92ZScuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50KTooYm9vbGVhbnx1bmRlZmluZWQpfSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogICAgIG9uIHRoZSBldmVudC4gVGhlIGZ1bmN0aW9uIHRha2VzIG9uZSBwYXJhbWV0ZXI6IHRoZSBldmVudCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFdmVudChlbGVtLCB0eXBlLCBmbikge1xuICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2FuY2VscyBmdXJ0aGVyIHByb2Nlc3Npbmcgb2YgYW4gZXZlbnQuIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgZGVmYXVsdFxuICogYnJvd3NlciBhY3Rpb25zLCBlLmcuIGhpZ2hsaWdodGluZyB0ZXh0IG9uIGEgZG91YmxlLWNsaWNrLlxuICogQmFzZWQgb24gdGhlIGFydGljbGUgYXRcbiAqIGh0dHA6Ly93d3cuc3dpdGNob250aGVjb2RlLmNvbS90dXRvcmlhbHMvamF2YXNjcmlwdC10dXRvcmlhbC10aGUtc2Nyb2xsLXdoZWVsXG4gKiBAcGFyYW0geyFFdmVudH0gZSBUaGUgZXZlbnQgd2hvc2Ugbm9ybWFsIGJlaGF2aW9yIHNob3VsZCBiZSBjYW5jZWxlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxFdmVudChlKSB7XG4gIGUgPSBlID8gZSA6IHdpbmRvdy5ldmVudDtcbiAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gIGUuY2FuY2VsID0gdHJ1ZTtcbiAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgaHN2IHZhbHVlcyB0byBhbiByZ2IocixnLGIpIHN0cmluZy4gVGFrZW4gZnJvbSBNb2NoaUtpdC5Db2xvci4gVGhpc1xuICogaXMgdXNlZCB0byBnZW5lcmF0ZSBkZWZhdWx0IHNlcmllcyBjb2xvcnMgd2hpY2ggYXJlIGV2ZW5seSBzcGFjZWQgb24gdGhlXG4gKiBjb2xvciB3aGVlbC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IGh1ZSBSYW5nZSBpcyAwLjAtMS4wLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gc2F0dXJhdGlvbiBSYW5nZSBpcyAwLjAtMS4wLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gdmFsdWUgUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEByZXR1cm4geyBzdHJpbmcgfSBcInJnYihyLGcsYilcIiB3aGVyZSByLCBnIGFuZCBiIHJhbmdlIGZyb20gMC0yNTUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHN2VG9SR0IoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSkge1xuICB2YXIgcmVkO1xuICB2YXIgZ3JlZW47XG4gIHZhciBibHVlO1xuICBpZiAoc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgIHJlZCA9IHZhbHVlO1xuICAgIGdyZWVuID0gdmFsdWU7XG4gICAgYmx1ZSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcihodWUgKiA2KTtcbiAgICB2YXIgZiA9IChodWUgKiA2KSAtIGk7XG4gICAgdmFyIHAgPSB2YWx1ZSAqICgxIC0gc2F0dXJhdGlvbik7XG4gICAgdmFyIHEgPSB2YWx1ZSAqICgxIC0gKHNhdHVyYXRpb24gKiBmKSk7XG4gICAgdmFyIHQgPSB2YWx1ZSAqICgxIC0gKHNhdHVyYXRpb24gKiAoMSAtIGYpKSk7XG4gICAgc3dpdGNoIChpKSB7XG4gICAgICBjYXNlIDE6IHJlZCA9IHE7IGdyZWVuID0gdmFsdWU7IGJsdWUgPSBwOyBicmVhaztcbiAgICAgIGNhc2UgMjogcmVkID0gcDsgZ3JlZW4gPSB2YWx1ZTsgYmx1ZSA9IHQ7IGJyZWFrO1xuICAgICAgY2FzZSAzOiByZWQgPSBwOyBncmVlbiA9IHE7IGJsdWUgPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDQ6IHJlZCA9IHQ7IGdyZWVuID0gcDsgYmx1ZSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgNTogcmVkID0gdmFsdWU7IGdyZWVuID0gcDsgYmx1ZSA9IHE7IGJyZWFrO1xuICAgICAgY2FzZSA2OiAvLyBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgMDogcmVkID0gdmFsdWU7IGdyZWVuID0gdDsgYmx1ZSA9IHA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZWQgPSBNYXRoLmZsb29yKDI1NSAqIHJlZCArIDAuNSk7XG4gIGdyZWVuID0gTWF0aC5mbG9vcigyNTUgKiBncmVlbiArIDAuNSk7XG4gIGJsdWUgPSBNYXRoLmZsb29yKDI1NSAqIGJsdWUgKyAwLjUpO1xuICByZXR1cm4gJ3JnYignICsgcmVkICsgJywnICsgZ3JlZW4gKyAnLCcgKyBibHVlICsgJyknO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb29yZGluYXRlcyBvZiBhbiBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gb2JqXG4gKiBAcmV0dXJuIHt7eDpudW1iZXIseTpudW1iZXJ9fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQb3Mob2JqKSB7XG4gIHZhciBwID0gb2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdyA9IHdpbmRvdyxcbiAgICAgIGQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBwLmxlZnQgKyAody5wYWdlWE9mZnNldCB8fCBkLnNjcm9sbExlZnQpLFxuICAgIHk6IHAudG9wICArICh3LnBhZ2VZT2Zmc2V0IHx8IGQuc2Nyb2xsVG9wKVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgaW4gYSBjb29yZGluYXRlIHN5c3RlbSB3aGVyZSB0aGVcbiAqIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcGFnZSAobm90IHRoZSB3aW5kb3cpIGlzICgwLDApLlxuICogVGFrZW4gZnJvbSBNb2NoaUtpdC5TaWduYWxcbiAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFnZVgoZSkge1xuICByZXR1cm4gKCFlLnBhZ2VYIHx8IGUucGFnZVggPCAwKSA/IDAgOiBlLnBhZ2VYO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlcmUgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHBhZ2UgKG5vdCB0aGUgd2luZG93KSBpcyAoMCwwKS5cbiAqIFRha2VuIGZyb20gTW9jaGlLaXQuU2lnbmFsXG4gKiBAcGFyYW0geyFFdmVudH0gZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VZKGUpIHtcbiAgcmV0dXJuICghZS5wYWdlWSB8fCBlLnBhZ2VZIDwgMCkgPyAwIDogZS5wYWdlWTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgcGFnZSB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBldmVudCB0byBwaXhlbCB4LWNvb3JkaW5hdGVzIG9uIHRoZVxuICogY2FudmFzIChpLmUuIERPTSBDb29yZHMpLlxuICogQHBhcmFtIHshRXZlbnR9IGUgRHJhZyBldmVudC5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhJbnRlcmFjdGlvbkNvbnRleHR9IGNvbnRleHQgSW50ZXJhY3Rpb24gY29udGV4dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIGRyYWcgaGFzIG1vdmVkIHRvIHRoZSByaWdodC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYWdHZXRYXyhlLCBjb250ZXh0KSB7XG4gIHJldHVybiBwYWdlWChlKSAtIGNvbnRleHQucHg7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHBhZ2UgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgdG8gcGl4ZWwgeS1jb29yZGluYXRlcyBvbiB0aGVcbiAqIGNhbnZhcyAoaS5lLiBET00gQ29vcmRzKS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIERyYWcgZXZlbnQuXG4gKiBAcGFyYW0geyFEeWdyYXBoSW50ZXJhY3Rpb25Db250ZXh0fSBjb250ZXh0IEludGVyYWN0aW9uIGNvbnRleHQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBkcmFnIGhhcyBtb3ZlZCBkb3duLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhZ0dldFlfKGUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHBhZ2VZKGUpIC0gY29udGV4dC5weTtcbn07XG5cbi8qKlxuICogVGhpcyByZXR1cm5zIHRydWUgdW5sZXNzIHRoZSBwYXJhbWV0ZXIgaXMgMCwgbnVsbCwgdW5kZWZpbmVkIG9yIE5hTi5cbiAqIFRPRE8oZGFudmspOiByZW5hbWUgdGhpcyBmdW5jdGlvbiB0byBzb21ldGhpbmcgbGlrZSAnaXNOb25aZXJvTmFuJy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbnVtYmVyIGlzIHplcm8gb3IgTmFOLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT0soeCkge1xuICByZXR1cm4gISF4ICYmICFpc05hTih4KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHt7eDo/bnVtYmVyLHk6P251bWJlcix5dmFsOj9udW1iZXJ9fSBwIFRoZSBwb2ludCB0byBjb25zaWRlciwgdmFsaWRcbiAqICAgICBwb2ludHMgYXJlIHt4LCB5fSBvYmplY3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfYWxsb3dOYU5ZIFRyZWF0IHBvaW50IHdpdGggeT1OYU4gYXMgdmFsaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBvaW50IGhhcyBudW1lcmljIHggYW5kIHkuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFBvaW50KHAsIG9wdF9hbGxvd05hTlkpIHtcbiAgaWYgKCFwKSByZXR1cm4gZmFsc2U7ICAvLyBudWxsIG9yIHVuZGVmaW5lZCBvYmplY3RcbiAgaWYgKHAueXZhbCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlOyAgLy8gbWlzc2luZyBwb2ludFxuICBpZiAocC54ID09PSBudWxsIHx8IHAueCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwLnkgPT09IG51bGwgfHwgcC55ID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzTmFOKHAueCkgfHwgKCFvcHRfYWxsb3dOYU5ZICYmIGlzTmFOKHAueSkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBOdW1iZXIgZm9ybWF0dGluZyBmdW5jdGlvbiB3aGljaCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mICVnIGluIHByaW50ZiwgaS5lLlxuICogZWl0aGVyIGV4cG9uZW50aWFsIG9yIGZpeGVkIGZvcm1hdCAod2l0aG91dCB0cmFpbGluZyAwcykgaXMgdXNlZCBkZXBlbmRpbmcgb25cbiAqIHRoZSBsZW5ndGggb2YgdGhlIGdlbmVyYXRlZCBzdHJpbmcuICBUaGUgYWR2YW50YWdlIG9mIHRoaXMgZm9ybWF0IGlzIHRoYXRcbiAqIHRoZXJlIGlzIGEgcHJlZGljdGFibGUgdXBwZXIgYm91bmQgb24gdGhlIHJlc3VsdGluZyBzdHJpbmcgbGVuZ3RoLFxuICogc2lnbmlmaWNhbnQgZmlndXJlcyBhcmUgbm90IGRyb3BwZWQsIGFuZCBub3JtYWwgbnVtYmVycyBhcmUgbm90IGRpc3BsYXllZCBpblxuICogZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKlxuICogTk9URTogSmF2YVNjcmlwdCdzIG5hdGl2ZSB0b1ByZWNpc2lvbigpIGlzIE5PVCBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yICVnLlxuICogSXQgY3JlYXRlcyBzdHJpbmdzIHdoaWNoIGFyZSB0b28gbG9uZyBmb3IgYWJzb2x1dGUgdmFsdWVzIGJldHdlZW4gMTBeLTQgYW5kXG4gKiAxMF4tNiwgZS5nLiAnMC4wMDAwMScgaW5zdGVhZCBvZiAnMWUtNScuIFNlZSB0ZXN0cy9udW1iZXItZm9ybWF0Lmh0bWwgZm9yXG4gKiBvdXRwdXQgZXhhbXBsZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3ByZWNpc2lvbiBUaGUgcHJlY2lzaW9uIHRvIHVzZSwgZGVmYXVsdCAyLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBmb3JtYXR0ZWQgbGlrZSAlZyBpbiBwcmludGYuICBUaGUgbWF4IGdlbmVyYXRlZFxuICogICAgICAgICAgICAgICAgICBzdHJpbmcgbGVuZ3RoIHNob3VsZCBiZSBwcmVjaXNpb24gKyA2IChlLmcgMS4xMjNlKzMwMCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9hdEZvcm1hdCh4LCBvcHRfcHJlY2lzaW9uKSB7XG4gIC8vIEF2b2lkIGludmFsaWQgcHJlY2lzaW9uIHZhbHVlczsgWzEsIDIxXSBpcyB0aGUgdmFsaWQgcmFuZ2UuXG4gIHZhciBwID0gTWF0aC5taW4oTWF0aC5tYXgoMSwgb3B0X3ByZWNpc2lvbiB8fCAyKSwgMjEpO1xuXG4gIC8vIFRoaXMgaXMgZGVjZXB0aXZlbHkgc2ltcGxlLiAgVGhlIGFjdHVhbCBhbGdvcml0aG0gY29tZXMgZnJvbTpcbiAgLy9cbiAgLy8gTWF4IGFsbG93ZWQgbGVuZ3RoID0gcCArIDRcbiAgLy8gd2hlcmUgNCBjb21lcyBmcm9tICdlK24nIGFuZCAnLicuXG4gIC8vXG4gIC8vIExlbmd0aCBvZiBmaXhlZCBmb3JtYXQgPSAyICsgeSArIHBcbiAgLy8gd2hlcmUgMiBjb21lcyBmcm9tICcwLicgYW5kIHkgPSAjIG9mIGxlYWRpbmcgemVyb2VzLlxuICAvL1xuICAvLyBFcXVhdGluZyB0aGUgdHdvIGFuZCBzb2x2aW5nIGZvciB5IHlpZWxkcyB5ID0gMiwgb3IgMC4wMHh4eHggd2hpY2ggaXNcbiAgLy8gMS4wZS0zLlxuICAvL1xuICAvLyBTaW5jZSB0aGUgYmVoYXZpb3Igb2YgdG9QcmVjaXNpb24oKSBpcyBpZGVudGljYWwgZm9yIGxhcmdlciBudW1iZXJzLCB3ZVxuICAvLyBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRoZSBvdGhlciBib3VuZC5cbiAgLy9cbiAgLy8gRmluYWxseSwgdGhlIGFyZ3VtZW50IGZvciB0b0V4cG9uZW50aWFsKCkgaXMgdGhlIG51bWJlciBvZiB0cmFpbGluZyBkaWdpdHMsXG4gIC8vIHNvIHdlIHRha2Ugb2ZmIDEgZm9yIHRoZSB2YWx1ZSBiZWZvcmUgdGhlICcuJy5cbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8IDEuMGUtMyAmJiB4ICE9PSAwLjApID9cbiAgICAgIHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvUHJlY2lzaW9uKHApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyAnOScgdG8gJzA5JyAodXNlZnVsIGZvciBkYXRlcylcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb3BhZCh4KSB7XG4gIGlmICh4IDwgMTApIHJldHVybiBcIjBcIiArIHg7IGVsc2UgcmV0dXJuIFwiXCIgKyB4O1xufTtcblxuLyoqXG4gKiBEYXRlIGFjY2Vzc29ycyB0byBnZXQgdGhlIHBhcnRzIG9mIGEgY2FsZW5kYXIgZGF0ZSAoeWVhciwgbW9udGgsXG4gKiBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIGFuZCBtaWxsaXNlY29uZCkgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUsXG4gKiBhbmQgZmFjdG9yeSBtZXRob2QgdG8gY2FsbCB0aGUgRGF0ZSBjb25zdHJ1Y3RvciB3aXRoIGFuIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IHZhciBEYXRlQWNjZXNzb3JzTG9jYWwgPSB7XG4gIGdldEZ1bGxZZWFyOiAgICAgZCA9PiBkLmdldEZ1bGxZZWFyKCksXG4gIGdldE1vbnRoOiAgICAgICAgZCA9PiBkLmdldE1vbnRoKCksXG4gIGdldERhdGU6ICAgICAgICAgZCA9PiBkLmdldERhdGUoKSxcbiAgZ2V0SG91cnM6ICAgICAgICBkID0+IGQuZ2V0SG91cnMoKSxcbiAgZ2V0TWludXRlczogICAgICBkID0+IGQuZ2V0TWludXRlcygpLFxuICBnZXRTZWNvbmRzOiAgICAgIGQgPT4gZC5nZXRTZWNvbmRzKCksXG4gIGdldE1pbGxpc2Vjb25kczogZCA9PiBkLmdldE1pbGxpc2Vjb25kcygpLFxuICBnZXREYXk6ICAgICAgICAgIGQgPT4gZC5nZXREYXkoKSxcbiAgbWFrZURhdGU6ICAgICAgICBmdW5jdGlvbih5LCBtLCBkLCBoaCwgbW0sIHNzLCBtcykge1xuICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkLCBoaCwgbW0sIHNzLCBtcyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGF0ZSBhY2Nlc3NvcnMgdG8gZ2V0IHRoZSBwYXJ0cyBvZiBhIGNhbGVuZGFyIGRhdGUgKHllYXIsIG1vbnRoLFxuICogZGF5IG9mIG1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCBhbmQgbWlsbGlzZWNvbmQpIGFjY29yZGluZyB0byBVVEMgdGltZSxcbiAqIGFuZCBmYWN0b3J5IG1ldGhvZCB0byBjYWxsIHRoZSBEYXRlIGNvbnN0cnVjdG9yIHdpdGggYW4gYXJyYXkgb2YgYXJndW1lbnRzLlxuICovXG5leHBvcnQgdmFyIERhdGVBY2Nlc3NvcnNVVEMgPSB7XG4gIGdldEZ1bGxZZWFyOiAgICAgZCA9PiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gIGdldE1vbnRoOiAgICAgICAgZCA9PiBkLmdldFVUQ01vbnRoKCksXG4gIGdldERhdGU6ICAgICAgICAgZCA9PiBkLmdldFVUQ0RhdGUoKSxcbiAgZ2V0SG91cnM6ICAgICAgICBkID0+IGQuZ2V0VVRDSG91cnMoKSxcbiAgZ2V0TWludXRlczogICAgICBkID0+IGQuZ2V0VVRDTWludXRlcygpLFxuICBnZXRTZWNvbmRzOiAgICAgIGQgPT4gZC5nZXRVVENTZWNvbmRzKCksXG4gIGdldE1pbGxpc2Vjb25kczogZCA9PiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICBnZXREYXk6ICAgICAgICAgIGQgPT4gZC5nZXRVVENEYXkoKSxcbiAgbWFrZURhdGU6ICAgICAgICBmdW5jdGlvbih5LCBtLCBkLCBoaCwgbW0sIHNzLCBtcykge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5LCBtLCBkLCBoaCwgbW0sIHNzLCBtcykpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBob3VycywgbWludXRlcyBhbmQgc2Vjb25kcyBwb3J0aW9uIG9mIGEgZGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaCBUaGUgaG91cnMgKGZyb20gMC0yMylcbiAqIEBwYXJhbSB7bnVtYmVyfSBtbSBUaGUgbWludXRlcyAoZnJvbSAwLTU5KVxuICogQHBhcmFtIHtudW1iZXJ9IHNzIFRoZSBzZWNvbmRzIChmcm9tIDAtNTkpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgdGltZSBvZiB0aGUgZm9ybSBcIkhIOk1NXCIgb3IgXCJISDpNTTpTU1wiXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaG1zU3RyaW5nXyhoaCwgbW0sIHNzLCBtcykge1xuICB2YXIgcmV0ID0gemVyb3BhZChoaCkgKyBcIjpcIiArIHplcm9wYWQobW0pO1xuICBpZiAoc3MpIHtcbiAgICByZXQgKz0gXCI6XCIgKyB6ZXJvcGFkKHNzKTtcbiAgICBpZiAobXMpIHtcbiAgICAgIHZhciBzdHIgPSBcIlwiICsgbXM7XG4gICAgICByZXQgKz0gXCIuXCIgKyAoJzAwMCcrc3RyKS5zdWJzdHJpbmcoc3RyLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBKUyBkYXRlIChtaWxsaXMgc2luY2UgZXBvY2gpIHRvIGEgZm9ybWF0dGVkIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSBKYXZhU2NyaXB0IHRpbWUgdmFsdWUgKG1zIHNpbmNlIGVwb2NoKVxuICogQHBhcmFtIHtib29sZWFufSB1dGMgV2hldGhlciBvdXRwdXQgVVRDIG9yIGxvY2FsIHRpbWVcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBkYXRlIG9mIG9uZSBvZiB0aGVzZSBmb3JtczpcbiAqICAgICBcIllZWVkvTU0vRERcIiwgXCJZWVlZL01NL0REIEhIOk1NXCIgb3IgXCJZWVlZL01NL0REIEhIOk1NOlNTXCJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlU3RyaW5nXyh0aW1lLCB1dGMpIHtcbiAgdmFyIGFjY2Vzc29ycyA9IHV0YyA/IERhdGVBY2Nlc3NvcnNVVEMgOiBEYXRlQWNjZXNzb3JzTG9jYWw7XG4gIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XG4gIHZhciB5ID0gYWNjZXNzb3JzLmdldEZ1bGxZZWFyKGRhdGUpO1xuICB2YXIgbSA9IGFjY2Vzc29ycy5nZXRNb250aChkYXRlKTtcbiAgdmFyIGQgPSBhY2Nlc3NvcnMuZ2V0RGF0ZShkYXRlKTtcbiAgdmFyIGhoID0gYWNjZXNzb3JzLmdldEhvdXJzKGRhdGUpO1xuICB2YXIgbW0gPSBhY2Nlc3NvcnMuZ2V0TWludXRlcyhkYXRlKTtcbiAgdmFyIHNzID0gYWNjZXNzb3JzLmdldFNlY29uZHMoZGF0ZSk7XG4gIHZhciBtcyA9IGFjY2Vzc29ycy5nZXRNaWxsaXNlY29uZHMoZGF0ZSk7XG4gIC8vIEdldCBhIHllYXIgc3RyaW5nOlxuICB2YXIgeWVhciA9IFwiXCIgKyB5O1xuICAvLyBHZXQgYSAwIHBhZGRlZCBtb250aCBzdHJpbmdcbiAgdmFyIG1vbnRoID0gemVyb3BhZChtICsgMSk7ICAvL21vbnRocyBhcmUgMC1vZmZzZXQsIHNpZ2hcbiAgLy8gR2V0IGEgMCBwYWRkZWQgZGF5IHN0cmluZ1xuICB2YXIgZGF5ID0gemVyb3BhZChkKTtcbiAgdmFyIGZyYWMgPSBoaCAqIDM2MDAgKyBtbSAqIDYwICsgc3MgKyAxZS0zICogbXM7XG4gIHZhciByZXQgPSB5ZWFyICsgXCIvXCIgKyBtb250aCArIFwiL1wiICsgZGF5O1xuICBpZiAoZnJhYykge1xuICAgIHJldCArPSBcIiBcIiArIGhtc1N0cmluZ18oaGgsIG1tLCBzcywgbXMpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJvdW5kIGEgbnVtYmVyIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRpZ2l0cyBwYXN0IHRoZSBkZWNpbWFsIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gcGxhY2VzIFRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdG8gd2hpY2ggdG8gcm91bmRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRfKG51bSwgcGxhY2VzKSB7XG4gIHZhciBzaGlmdCA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBzaGlmdCkvc2hpZnQ7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggb3ZlciBhbiBhcnJheS5cbiAqIEN1cnJlbnRseSBkb2VzIG5vdCB3b3JrIHdoZW4gdmFsIGlzIG91dHNpZGUgdGhlIHJhbmdlIG9mIGFycnkncyB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIHRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJ5IGlzIHRoZSB2YWx1ZSBvdmVyIHdoaWNoIHRvIHNlYXJjaFxuICogQHBhcmFtIHtudW1iZXJ9IGFicyBJZiBhYnMgPiAwLCBmaW5kIHRoZSBsb3dlc3QgZW50cnkgZ3JlYXRlciB0aGFuIHZhbFxuICogICAgIElmIGFicyA8IDAsIGZpbmQgdGhlIGhpZ2hlc3QgZW50cnkgbGVzcyB0aGFuIHZhbC5cbiAqICAgICBJZiBhYnMgPT0gMCwgZmluZCB0aGUgZW50cnkgdGhhdCBlcXVhbHMgdmFsLlxuICogQHBhcmFtIHtudW1iZXI9fSBsb3cgVGhlIGZpcnN0IGluZGV4IGluIGFycnkgdG8gY29uc2lkZXIgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtudW1iZXI9fSBoaWdoIFRoZSBsYXN0IGluZGV4IGluIGFycnkgdG8gY29uc2lkZXIgKG9wdGlvbmFsKVxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleCBvZiB0aGUgZWxlbWVudCwgb3IgLTEgaWYgaXQgaXNuJ3QgZm91bmQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHZhbCwgYXJyeSwgYWJzLCBsb3csIGhpZ2gpIHtcbiAgaWYgKGxvdyA9PT0gbnVsbCB8fCBsb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaGlnaCA9PT0gbnVsbCB8fCBoaWdoID09PSB1bmRlZmluZWQpIHtcbiAgICBsb3cgPSAwO1xuICAgIGhpZ2ggPSBhcnJ5Lmxlbmd0aCAtIDE7XG4gIH1cbiAgaWYgKGxvdyA+IGhpZ2gpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGFicyA9PT0gbnVsbCB8fCBhYnMgPT09IHVuZGVmaW5lZCkge1xuICAgIGFicyA9IDA7XG4gIH1cbiAgdmFyIHZhbGlkSW5kZXggPSBmdW5jdGlvbihpZHgpIHtcbiAgICByZXR1cm4gaWR4ID49IDAgJiYgaWR4IDwgYXJyeS5sZW5ndGg7XG4gIH07XG4gIHZhciBtaWQgPSBwYXJzZUludCgobG93ICsgaGlnaCkgLyAyLCAxMCk7XG4gIHZhciBlbGVtZW50ID0gYXJyeVttaWRdO1xuICB2YXIgaWR4O1xuICBpZiAoZWxlbWVudCA9PSB2YWwpIHtcbiAgICByZXR1cm4gbWlkO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQgPiB2YWwpIHtcbiAgICBpZiAoYWJzID4gMCkge1xuICAgICAgLy8gQWNjZXB0IGlmIGVsZW1lbnQgPiB2YWwsIGJ1dCBhbHNvIGlmIHByaW9yIGVsZW1lbnQgPCB2YWwuXG4gICAgICBpZHggPSBtaWQgLSAxO1xuICAgICAgaWYgKHZhbGlkSW5kZXgoaWR4KSAmJiBhcnJ5W2lkeF0gPCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaCh2YWwsIGFycnksIGFicywgbG93LCBtaWQgLSAxKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50IDwgdmFsKSB7XG4gICAgaWYgKGFicyA8IDApIHtcbiAgICAgIC8vIEFjY2VwdCBpZiBlbGVtZW50IDwgdmFsLCBidXQgYWxzbyBpZiBwcmlvciBlbGVtZW50ID4gdmFsLlxuICAgICAgaWR4ID0gbWlkICsgMTtcbiAgICAgIGlmICh2YWxpZEluZGV4KGlkeCkgJiYgYXJyeVtpZHhdID4gdmFsKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTZWFyY2godmFsLCBhcnJ5LCBhYnMsIG1pZCArIDEsIGhpZ2gpO1xuICB9XG4gIHJldHVybiAtMTsgIC8vIGNhbid0IGFjdHVhbGx5IGhhcHBlbiwgYnV0IG1ha2VzIGNsb3N1cmUgY29tcGlsZXIgaGFwcHlcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgZGF0ZSwgcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLiBUaGlzIGNhbiBiZVxuICogcGFzc2VkIGluIGFzIGFuIHhWYWx1ZVBhcnNlciBpbiB0aGUgRHlncmFwaCBjb25zdHJ1Y3Rvci5cbiAqIFRPRE8oZGFudmspOiBlbnVtZXJhdGUgZm9ybWF0cyB0aGF0IHRoaXMgdW5kZXJzdGFuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHIgQSBkYXRlIGluIGEgdmFyaWV0eSBvZiBwb3NzaWJsZSBzdHJpbmcgZm9ybWF0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVQYXJzZXIoZGF0ZVN0cikge1xuICB2YXIgZGF0ZVN0clNsYXNoZWQ7XG4gIHZhciBkO1xuXG4gIC8vIExldCB0aGUgc3lzdGVtIHRyeSB0aGUgZm9ybWF0IGZpcnN0LCB3aXRoIG9uZSBjYXZlYXQ6XG4gIC8vIFlZWVktTU0tRERbIEhIOk1NOlNTXSBpcyBpbnRlcnByZXRlZCBhcyBVVEMgYnkgYSB2YXJpZXR5IG9mIGJyb3dzZXJzLlxuICAvLyBkeWdyYXBocyBkaXNwbGF5cyBkYXRlcyBpbiBsb2NhbCB0aW1lLCBzbyB0aGlzIHdpbGwgcmVzdWx0IGluIHN1cnByaXNpbmdcbiAgLy8gaW5jb25zaXN0ZW5jaWVzLiBCdXQgaWYgeW91IHNwZWNpZnkgXCJUXCIgb3IgXCJaXCIgKGkuZS4gWVlZWS1NTS1ERFRISDpNTTpTUyksXG4gIC8vIHRoZW4geW91IHByb2JhYmx5IGtub3cgd2hhdCB5b3UncmUgZG9pbmcsIHNvIHdlJ2xsIGxldCB5b3UgZ28gYWhlYWQuXG4gIC8vIElzc3VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZHlncmFwaHMvaXNzdWVzL2RldGFpbD9pZD0yNTVcbiAgaWYgKGRhdGVTdHIuc2VhcmNoKFwiLVwiKSA9PSAtMSB8fFxuICAgICAgZGF0ZVN0ci5zZWFyY2goXCJUXCIpICE9IC0xIHx8IGRhdGVTdHIuc2VhcmNoKFwiWlwiKSAhPSAtMSkge1xuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0cik7XG4gICAgaWYgKGQgJiYgIWlzTmFOKGQpKSByZXR1cm4gZDtcbiAgfVxuXG4gIGlmIChkYXRlU3RyLnNlYXJjaChcIi1cIikgIT0gLTEpIHsgIC8vIGUuZy4gJzIwMDktNy0xMicgb3IgJzIwMDktMDctMTInXG4gICAgZGF0ZVN0clNsYXNoZWQgPSBkYXRlU3RyLnJlcGxhY2UoXCItXCIsIFwiL1wiLCBcImdcIik7XG4gICAgd2hpbGUgKGRhdGVTdHJTbGFzaGVkLnNlYXJjaChcIi1cIikgIT0gLTEpIHtcbiAgICAgIGRhdGVTdHJTbGFzaGVkID0gZGF0ZVN0clNsYXNoZWQucmVwbGFjZShcIi1cIiwgXCIvXCIpO1xuICAgIH1cbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHJTbGFzaGVkKTtcbiAgfSBlbHNlIGlmIChkYXRlU3RyLmxlbmd0aCA9PSA4KSB7ICAvLyBlLmcuICcyMDA5MDcxMidcbiAgICAvLyBUT0RPKGRhbnZrKTogcmVtb3ZlIHN1cHBvcnQgZm9yIHRoaXMgZm9ybWF0LiBJdCdzIGNvbmZ1c2luZy5cbiAgICBkYXRlU3RyU2xhc2hlZCA9IGRhdGVTdHIuc3Vic3RyKDAsNCkgKyBcIi9cIiArIGRhdGVTdHIuc3Vic3RyKDQsMikgKyBcIi9cIiArXG4gICAgICAgIGRhdGVTdHIuc3Vic3RyKDYsMik7XG4gICAgZCA9IGRhdGVTdHJUb01pbGxpcyhkYXRlU3RyU2xhc2hlZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQW55IGZvcm1hdCB0aGF0IERhdGUucGFyc2Ugd2lsbCBhY2NlcHQsIGUuZy4gXCIyMDA5LzA3LzEyXCIgb3JcbiAgICAvLyBcIjIwMDkvMDcvMTIgMTI6MzQ6NTZcIlxuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0cik7XG4gIH1cblxuICBpZiAoIWQgfHwgaXNOYU4oZCkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgcGFyc2UgXCIgKyBkYXRlU3RyICsgXCIgYXMgYSBkYXRlXCIpO1xuICB9XG4gIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gRGF0ZS5wYXJzZSgpIG1ldGhvZCwgZXhjZXB0IHRoYXRcbiAqIGl0IGRvZXNuJ3QgZ2V0IHJlcGxhY2VkIHdpdGggYW4gaW5jb21wYXRpYmxlIG1ldGhvZCBieSBhZ2dyZXNzaXZlIEpTXG4gKiBsaWJyYXJpZXMgbGlrZSBNb29Ub29scyBvciBKb29tbGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBkYXRlIHN0cmluZywgZS5nLiBcIjIwMTEvMDUvMDZcIlxuICogQHJldHVybiB7bnVtYmVyfSBtaWxsaXMgc2luY2UgZXBvY2hcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlU3RyVG9NaWxsaXMoc3RyKSB7XG4gIHJldHVybiBuZXcgRGF0ZShzdHIpLmdldFRpbWUoKTtcbn07XG5cbi8vIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxsIGJhc2VkIG9uIE1vY2hpS2l0LlxuLyoqXG4gKiBDb3BpZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gbyB0byBzZWxmLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2VsZlxuICogQHBhcmFtIHshT2JqZWN0fSBvXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlKHNlbGYsIG8pIHtcbiAgaWYgKHR5cGVvZihvKSAhPSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBzZWxmW2tdID0gb1trXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIENvcGllcyBhbGwgdGhlIHByb3BlcnRpZXMgZnJvbSBvIHRvIHNlbGYuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBzZWxmXG4gKiBAcGFyYW0geyFPYmplY3R9IG9cbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRGVlcChzZWxmLCBvKSB7XG4gIC8vIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvamF2YXNjcmlwdC1pc2RvbS1ob3ctZG8teW91LWNoZWNrLWlmLWEtamF2YXNjcmlwdC1vYmplY3QtaXMtYS1kb20tb2JqZWN0XG4gIGZ1bmN0aW9uIGlzTm9kZShvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBOb2RlID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIE5vZGUgOlxuICAgICAgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8ubm9kZVR5cGUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG8ubm9kZU5hbWU9PT1cInN0cmluZ1wiXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YobykgIT0gJ3VuZGVmaW5lZCcgJiYgbyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgaWYgKG9ba10gPT09IG51bGwpIHtcbiAgICAgICAgICBzZWxmW2tdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShvW2tdKSkge1xuICAgICAgICAgIHNlbGZba10gPSBvW2tdLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKG9ba10pKSB7XG4gICAgICAgICAgLy8gRE9NIG9iamVjdHMgYXJlIHNoYWxsb3dseS1jb3BpZWQuXG4gICAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKG9ba10pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZihzZWxmW2tdKSAhPSAnb2JqZWN0JyB8fCBzZWxmW2tdID09PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmW2tdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZURlZXAoc2VsZltrXSwgb1trXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGlrZShvKSB7XG4gIHZhciB0eXAgPSB0eXBlb2Yobyk7XG4gIGlmIChcbiAgICAgICh0eXAgIT0gJ29iamVjdCcgJiYgISh0eXAgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2Yoby5pdGVtKSA9PSAnZnVuY3Rpb24nKSkgfHxcbiAgICAgIG8gPT09IG51bGwgfHxcbiAgICAgIHR5cGVvZihvLmxlbmd0aCkgIT0gJ251bWJlcicgfHxcbiAgICAgIG8ubm9kZVR5cGUgPT09IDNcbiAgICAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVMaWtlKG8pIHtcbiAgaWYgKHR5cGVvZihvKSAhPSBcIm9iamVjdFwiIHx8IG8gPT09IG51bGwgfHxcbiAgICAgIHR5cGVvZihvLmdldFRpbWUpICE9ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE5vdGU6IHRoaXMgb25seSBzZWVtcyB0byB3b3JrIGZvciBhcnJheXMuXG4gKiBAcGFyYW0geyFBcnJheX0gb1xuICogQHJldHVybiB7IUFycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKG8pIHtcbiAgLy8gVE9ETyhkYW52ayk6IGZpZ3VyZSBvdXQgaG93IE1vY2hpS2l0J3MgdmVyc2lvbiB3b3Jrc1xuICB2YXIgciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNBcnJheUxpa2Uob1tpXSkpIHtcbiAgICAgIHIucHVzaChjbG9uZShvW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucHVzaChvW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHshSFRNTENhbnZhc0VsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQncyBwaXhlbCByYXRpbywgd2hpY2ggaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIGRldmljZVxuICogcGl4ZWwgcmF0aW8gYW5kIHRoZSBiYWNraW5nIHN0b3JlIHJhdGlvLiBUeXBpY2FsbHkgdGhpcyBpcyAxIGZvciBjb252ZW50aW9uYWxcbiAqIGRpc3BsYXlzLCBhbmQgPiAxIGZvciBIaURQSSBkaXNwbGF5cyAoc3VjaCBhcyB0aGUgUmV0aW5hIE1CUCkuXG4gKiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2hpZHBpLyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7IUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY2FudmFzJ3MgMmQgY29udGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJhdGlvIG9mIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gYW5kIHRoZSBiYWNraW5nIHN0b3JlXG4gKiByYXRpbyBmb3IgdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dFBpeGVsUmF0aW8oY29udGV4dCkge1xuICB0cnkge1xuICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZGV2aWNlUGl4ZWxSYXRpbyBtdXN0IGJlIGRlZmluZWQgZm9yIHRoaXMgcmF0aW8gdG8gbWFrZSBzZW5zZS5cbiAgICAgIC8vIFdlIGRlZmF1bHQgYmFja2luZ1N0b3JlUmF0aW8gdG8gMTogdGhpcyBkb2VzIG5vdCBleGlzdCBvbiBzb21lIGJyb3dzZXJzXG4gICAgICAvLyAoaS5lLiBkZXNrdG9wIENocm9tZSkuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUT0RPKGRhbnZrKTogdXNlIEB0ZW1wbGF0ZSBoZXJlIHdoZW4gaXQncyBiZXR0ZXIgc3VwcG9ydGVkIGZvciBjbGFzc2VzLlxuICogQHBhcmFtIHshQXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oIUFycmF5LD8pOmJvb2xlYW49fSBwcmVkaWNhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gSXRlcmF0b3IoYXJyYXksIHN0YXJ0LCBsZW5ndGgsIHByZWRpY2F0ZSkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGxlbmd0aCA9IGxlbmd0aCB8fCBhcnJheS5sZW5ndGg7XG4gIHRoaXMuaGFzTmV4dCA9IHRydWU7IC8vIFVzZSB0byBpZGVudGlmeSBpZiB0aGVyZSdzIGFub3RoZXIgZWxlbWVudC5cbiAgdGhpcy5wZWVrID0gbnVsbDsgLy8gVXNlIGZvciBsb29rLWFoZWFkXG4gIHRoaXMuc3RhcnRfID0gc3RhcnQ7XG4gIHRoaXMuYXJyYXlfID0gYXJyYXk7XG4gIHRoaXMucHJlZGljYXRlXyA9IHByZWRpY2F0ZTtcbiAgdGhpcy5lbmRfID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLCBzdGFydCArIGxlbmd0aCk7XG4gIHRoaXMubmV4dElkeF8gPSBzdGFydCAtIDE7IC8vIHVzZSAtMSBzbyBpbml0aWFsIGFkdmFuY2Ugd29ya3MuXG4gIHRoaXMubmV4dCgpOyAvLyBpZ25vcmluZyByZXN1bHQuXG59O1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmhhc05leHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgb2JqID0gdGhpcy5wZWVrO1xuXG4gIHZhciBuZXh0SWR4ID0gdGhpcy5uZXh0SWR4XyArIDE7XG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuICB3aGlsZSAobmV4dElkeCA8IHRoaXMuZW5kXykge1xuICAgIGlmICghdGhpcy5wcmVkaWNhdGVfIHx8IHRoaXMucHJlZGljYXRlXyh0aGlzLmFycmF5XywgbmV4dElkeCkpIHtcbiAgICAgIHRoaXMucGVlayA9IHRoaXMuYXJyYXlfW25leHRJZHhdO1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5leHRJZHgrKztcbiAgfVxuICB0aGlzLm5leHRJZHhfID0gbmV4dElkeDtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHRoaXMuaGFzTmV4dCA9IGZhbHNlO1xuICAgIHRoaXMucGVlayA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBpdGVyYXRvciBvdmVyIGFycmF5LCBiZXR3ZWVuIGluZGV4ZXMgc3RhcnQgYW5kXG4gKiBzdGFydCArIGxlbmd0aCwgYW5kIG9ubHkgcmV0dXJucyBlbnRyaWVzIHRoYXQgcGFzcyB0aGUgYWNjZXB0IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHshQXJyYXl9IGFycmF5IHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgdGhlIGZpcnN0IGluZGV4IHRvIGl0ZXJhdGUgb3ZlciwgMCBpZiBhYnNlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqICAgICBUaGlzLCBhbG9uZyB3aXRoIHN0YXJ0LCBkZWZpbmVzIGEgc2xpY2Ugb2YgdGhlIGFycmF5LCBhbmQgc28gbGVuZ3RoXG4gKiAgICAgZG9lc24ndCBpbXBseSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYXRvciB3aGVuIGFjY2VwdCBkb2Vzbid0XG4gKiAgICAgYWx3YXlzIGFjY2VwdCBhbGwgdmFsdWVzLiBhcnJheS5sZW5ndGggd2hlbiBhYnNlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOmJvb2xlYW49fSBvcHRfcHJlZGljYXRlIGEgZnVuY3Rpb24gdGhhdCB0YWtlc1xuICogICAgIHBhcmFtZXRlcnMgYXJyYXkgYW5kIGlkeCwgd2hpY2ggcmV0dXJucyB0cnVlIHdoZW4gdGhlIGVsZW1lbnQgc2hvdWxkIGJlXG4gKiAgICAgcmV0dXJuZWQuICBJZiBvbWl0dGVkLCBhbGwgZWxlbWVudHMgYXJlIGFjY2VwdGVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBvcHRfcHJlZGljYXRlKSB7XG4gIHJldHVybiBuZXcgSXRlcmF0b3IoYXJyYXksIHN0YXJ0LCBsZW5ndGgsIG9wdF9wcmVkaWNhdGUpO1xufTtcblxuLy8gU2hpbSBsYXllciB3aXRoIHNldFRpbWVvdXQgZmFsbGJhY2suXG4vLyBGcm9tOiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gU2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSB3aW5kb3cgY29udGV4dDpcbi8vICAgRHlncmFwaC5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHt9KVxuZXhwb3J0IHZhciByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBhdCBtb3N0IG1heEZyYW1lcyB0aW1lcyBhdCBhbiBhdHRlbXB0ZWQgaW50ZXJ2YWwgb2ZcbiAqIGZyYW1lUGVyaW9kSW5NaWxsaXMsIHRoZW4gY2FsbCBhIGNsZWFudXAgZnVuY3Rpb24gb25jZS4gcmVwZWF0Rm4gaXMgY2FsbGVkXG4gKiBvbmNlIGltbWVkaWF0ZWx5LCB0aGVuIGF0IG1vc3QgKG1heEZyYW1lcyAtIDEpIHRpbWVzIGFzeW5jaHJvbm91c2x5LiBJZlxuICogbWF4RnJhbWVzPT0xLCB0aGVuIGNsZWFudXBfZm4oKSBpcyBhbHNvIGNhbGxlZCBzeW5jaHJvbm91c2x5LiAgVGhpcyBmdW5jdGlvblxuICogaXMgdXNlZCB0byBzZXF1ZW5jZSBhbmltYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcil9IHJlcGVhdEZuIENhbGxlZCByZXBlYXRlZGx5IC0tIHRha2VzIHRoZSBmcmFtZVxuICogICAgIG51bWJlciAoZnJvbSAwIHRvIG1heEZyYW1lcy0xKSBhcyBhbiBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFtZXMgVGhlIG1heCBudW1iZXIgb2YgdGltZXMgdG8gY2FsbCByZXBlYXRGblxuICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lUGVyaW9kSW5NaWxsaXMgTWF4IHJlcXVlc3RlZCB0aW1lIGJldHdlZW4gZnJhbWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjbGVhbnVwRm4gQSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGFsbCByZXBlYXRGbiBjYWxscy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXRBbmRDbGVhbnVwKHJlcGVhdEZuLCBtYXhGcmFtZXMsIGZyYW1lUGVyaW9kSW5NaWxsaXMsXG4gICAgY2xlYW51cEZuKSB7XG4gIHZhciBmcmFtZU51bWJlciA9IDA7XG4gIHZhciBwcmV2aW91c0ZyYW1lTnVtYmVyO1xuICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHJlcGVhdEZuKGZyYW1lTnVtYmVyKTtcbiAgaWYgKG1heEZyYW1lcyA9PSAxKSB7XG4gICAgY2xlYW51cEZuKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXhGcmFtZUFyZyA9IG1heEZyYW1lcyAtIDE7XG5cbiAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgaWYgKGZyYW1lTnVtYmVyID49IG1heEZyYW1lcykgcmV0dXJuO1xuICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYW1lIHRvIGRyYXcgYmFzZWQgb24gdGhlIGRlbGF5IHNvIGZhci4gIFdpbGwgc2tpcFxuICAgICAgLy8gZnJhbWVzIGlmIG5lY2Vzc2FyeS5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdmFyIGRlbGF5SW5NaWxsaXMgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIHByZXZpb3VzRnJhbWVOdW1iZXIgPSBmcmFtZU51bWJlcjtcbiAgICAgIGZyYW1lTnVtYmVyID0gTWF0aC5mbG9vcihkZWxheUluTWlsbGlzIC8gZnJhbWVQZXJpb2RJbk1pbGxpcyk7XG4gICAgICB2YXIgZnJhbWVEZWx0YSA9IGZyYW1lTnVtYmVyIC0gcHJldmlvdXNGcmFtZU51bWJlcjtcbiAgICAgIC8vIElmIHdlIHByZWRpY3QgdGhhdCB0aGUgc3Vic2VxdWVudCByZXBlYXRGbiBjYWxsIHdpbGwgb3ZlcnNob290IG91clxuICAgICAgLy8gdG90YWwgZnJhbWUgdGFyZ2V0LCBzbyBvdXIgbGFzdCBjYWxsIHdpbGwgY2F1c2UgYSBzdHV0dGVyLCB0aGVuIGp1bXAgdG9cbiAgICAgIC8vIHRoZSBsYXN0IGNhbGwgaW1tZWRpYXRlbHkuICBJZiB3ZSdyZSBnb2luZyB0byBjYXVzZSBhIHN0dXR0ZXIsIGJldHRlclxuICAgICAgLy8gdG8gZG8gaXQgZmFzdGVyIHRoYW4gc2xvd2VyLlxuICAgICAgdmFyIHByZWRpY3RPdmVyc2hvb3RTdHV0dGVyID0gKGZyYW1lTnVtYmVyICsgZnJhbWVEZWx0YSkgPiBtYXhGcmFtZUFyZztcbiAgICAgIGlmIChwcmVkaWN0T3ZlcnNob290U3R1dHRlciB8fCAoZnJhbWVOdW1iZXIgPj0gbWF4RnJhbWVBcmcpKSB7XG4gICAgICAgIHJlcGVhdEZuKG1heEZyYW1lQXJnKTsgIC8vIEVuc3VyZSBmaW5hbCBjYWxsIHdpdGggbWF4RnJhbWVBcmcuXG4gICAgICAgIGNsZWFudXBGbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZyYW1lRGVsdGEgIT09IDApIHsgIC8vIERvbid0IGNhbGwgcmVwZWF0Rm4gd2l0aCBkdXBsaWNhdGUgZnJhbWVzLlxuICAgICAgICAgIHJlcGVhdEZuKGZyYW1lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsb29wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG59O1xuXG4vLyBBIHdoaXRlbGlzdCBvZiBvcHRpb25zIHRoYXQgZG8gbm90IGNoYW5nZSBwaXhlbCBwb3NpdGlvbnMuXG52YXIgcGl4ZWxTYWZlT3B0aW9ucyA9IHtcbiAgJ2Fubm90YXRpb25DbGlja0hhbmRsZXInOiB0cnVlLFxuICAnYW5ub3RhdGlvbkRibENsaWNrSGFuZGxlcic6IHRydWUsXG4gICdhbm5vdGF0aW9uTW91c2VPdXRIYW5kbGVyJzogdHJ1ZSxcbiAgJ2Fubm90YXRpb25Nb3VzZU92ZXJIYW5kbGVyJzogdHJ1ZSxcbiAgJ2F4aXNMaW5lQ29sb3InOiB0cnVlLFxuICAnYXhpc0xpbmVXaWR0aCc6IHRydWUsXG4gICdjbGlja0NhbGxiYWNrJzogdHJ1ZSxcbiAgJ2RyYXdDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3UG9pbnRzJzogdHJ1ZSxcbiAgJ2RyYXdQb2ludENhbGxiYWNrJzogdHJ1ZSxcbiAgJ2RyYXdHcmlkJzogdHJ1ZSxcbiAgJ2ZpbGxBbHBoYSc6IHRydWUsXG4gICdncmlkTGluZUNvbG9yJzogdHJ1ZSxcbiAgJ2dyaWRMaW5lV2lkdGgnOiB0cnVlLFxuICAnaGlkZU92ZXJsYXlPbk1vdXNlT3V0JzogdHJ1ZSxcbiAgJ2hpZ2hsaWdodENhbGxiYWNrJzogdHJ1ZSxcbiAgJ2hpZ2hsaWdodENpcmNsZVNpemUnOiB0cnVlLFxuICAnaW50ZXJhY3Rpb25Nb2RlbCc6IHRydWUsXG4gICdsYWJlbHNEaXYnOiB0cnVlLFxuICAnbGFiZWxzS01CJzogdHJ1ZSxcbiAgJ2xhYmVsc0tNRzInOiB0cnVlLFxuICAnbGFiZWxzU2VwYXJhdGVMaW5lcyc6IHRydWUsXG4gICdsYWJlbHNTaG93WmVyb1ZhbHVlcyc6IHRydWUsXG4gICdsZWdlbmQnOiB0cnVlLFxuICAncGFuRWRnZUZyYWN0aW9uJzogdHJ1ZSxcbiAgJ3BpeGVsc1BlcllMYWJlbCc6IHRydWUsXG4gICdwb2ludENsaWNrQ2FsbGJhY2snOiB0cnVlLFxuICAncG9pbnRTaXplJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGgnOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckFscGhhJzogdHJ1ZSxcbiAgJ3Nob3dMYWJlbHNPbkhpZ2hsaWdodCc6IHRydWUsXG4gICdzaG93Um9sbGVyJzogdHJ1ZSxcbiAgJ3N0cm9rZVdpZHRoJzogdHJ1ZSxcbiAgJ3VuZGVybGF5Q2FsbGJhY2snOiB0cnVlLFxuICAndW5oaWdobGlnaHRDYWxsYmFjayc6IHRydWUsXG4gICd6b29tQ2FsbGJhY2snOiB0cnVlXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBzY2FuIHRoZSBvcHRpb24gbGlzdCBhbmQgZGV0ZXJtaW5lIGlmIHRoZXlcbiAqIHJlcXVpcmUgdXMgdG8gcmVjYWxjdWxhdGUgdGhlIHBpeGVsIHBvc2l0aW9ucyBvZiBlYWNoIHBvaW50LlxuICogVE9ETzogbW92ZSB0aGlzIGludG8gZHlncmFwaC1vcHRpb25zLmpzXG4gKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gbGFiZWxzIGEgbGlzdCBvZiBvcHRpb25zIHRvIGNoZWNrLlxuICogQHBhcmFtIHshT2JqZWN0fSBhdHRyc1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ3JhcGggbmVlZHMgbmV3IHBvaW50cyBlbHNlIGZhbHNlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QobGFiZWxzLCBhdHRycykge1xuICAvLyBBc3N1bWUgdGhhdCB3ZSBkbyBub3QgcmVxdWlyZSBuZXcgcG9pbnRzLlxuICAvLyBUaGlzIHdpbGwgY2hhbmdlIHRvIHRydWUgaWYgd2UgYWN0dWFsbHkgZG8gbmVlZCBuZXcgcG9pbnRzLlxuXG4gIC8vIENyZWF0ZSBhIGRpY3Rpb25hcnkgb2Ygc2VyaWVzIG5hbWVzIGZvciBmYXN0ZXIgbG9va3VwLlxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbGFiZWxzLCB0aGVuIHRoZSBkaWN0aW9uYXJ5IHN0YXlzIGVtcHR5LlxuICB2YXIgc2VyaWVzTmFtZXNEaWN0aW9uYXJ5ID0geyB9O1xuICBpZiAobGFiZWxzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlcmllc05hbWVzRGljdGlvbmFyeVtsYWJlbHNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBTY2FuIHRocm91Z2ggYSBmbGF0IChpLmUuIG5vbi1uZXN0ZWQpIG9iamVjdCBvZiBvcHRpb25zLlxuICAvLyBSZXR1cm5zIHRydWUvZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgbmV3IHBvaW50cyBhcmUgbmVlZGVkLlxuICB2YXIgc2NhbkZsYXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxuICAgICAgICAgICFwaXhlbFNhZmVPcHRpb25zW3Byb3BlcnR5XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVkIG9wdGlvbnMuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluZCBvdXQgb2YgdGhpcyBmaWVsZCBpcyBhY3R1YWxseSBhIHNlcmllcyBzcGVjaWZpYyBvcHRpb25zIGxpc3QuXG4gICAgaWYgKHByb3BlcnR5ID09ICdoaWdobGlnaHRTZXJpZXNPcHRzJyB8fFxuICAgICAgICAoc2VyaWVzTmFtZXNEaWN0aW9uYXJ5W3Byb3BlcnR5XSAmJiAhYXR0cnMuc2VyaWVzKSkge1xuICAgICAgLy8gVGhpcyBwcm9wZXJ0eSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb3B0aW9ucyBmb3IgdGhpcyBzZXJpZXMuXG4gICAgICBpZiAoc2NhbkZsYXRPcHRpb25zKGF0dHJzW3Byb3BlcnR5XSkpIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT0gJ3NlcmllcycgfHwgcHJvcGVydHkgPT0gJ2F4ZXMnKSB7XG4gICAgICAvLyBUaGlzIGlzIHR3aWNlLW5lc3RlZCBvcHRpb25zIGxpc3QuXG4gICAgICB2YXIgcGVyU2VyaWVzID0gYXR0cnNbcHJvcGVydHldO1xuICAgICAgZm9yICh2YXIgc2VyaWVzIGluIHBlclNlcmllcykge1xuICAgICAgICBpZiAocGVyU2VyaWVzLmhhc093blByb3BlcnR5KHNlcmllcykgJiZcbiAgICAgICAgICAgIHNjYW5GbGF0T3B0aW9ucyhwZXJTZXJpZXNbc2VyaWVzXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBub3QgYSBzZXJpZXMgc3BlY2lmaWMgb3B0aW9uIGxpc3QsIGNoZWNrIGlmIGl0J3MgYSBwaXhlbFxuICAgICAgLy8gY2hhbmdpbmcgcHJvcGVydHkuXG4gICAgICBpZiAoIXBpeGVsU2FmZU9wdGlvbnNbcHJvcGVydHldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgdmFyIENpcmNsZXMgPSB7XG4gIERFRkFVTFQgOiBmdW5jdGlvbihnLCBuYW1lLCBjdHgsIGNhbnZhc3gsIGNhbnZhc3ksIGNvbG9yLCByYWRpdXMpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5hcmMoY2FudmFzeCwgY2FudmFzeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gRm9yIG1vcmUgc2hhcGVzLCBpbmNsdWRlIGV4dHJhcy9zaGFwZXMuanNcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgfGRhdGF8IGlzIGRlbGltaXRlZCBieSBDUiwgQ1JMRiwgTEYsIExGQ1IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybiB7P3N0cmluZ30gdGhlIGRlbGltaXRlciB0aGF0IHdhcyBkZXRlY3RlZCAob3IgbnVsbCBvbiBmYWlsdXJlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdExpbmVEZWxpbWl0ZXIoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGRhdGEuY2hhckF0KGkpO1xuICAgIGlmIChjb2RlID09PSAnXFxyJykge1xuICAgICAgLy8gTWlnaHQgYWN0dWFsbHkgYmUgXCJcXHJcXG5cIi5cbiAgICAgIGlmICgoKGkgKyAxKSA8IGRhdGEubGVuZ3RoKSAmJiAoZGF0YS5jaGFyQXQoaSArIDEpID09PSAnXFxuJykpIHtcbiAgICAgICAgcmV0dXJuICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAnXFxuJykge1xuICAgICAgLy8gTWlnaHQgYWN0dWFsbHkgYmUgXCJcXG5cXHJcIi5cbiAgICAgIGlmICgoKGkgKyAxKSA8IGRhdGEubGVuZ3RoKSAmJiAoZGF0YS5jaGFyQXQoaSArIDEpID09PSAnXFxyJykpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXHInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIElzIG9uZSBub2RlIGNvbnRhaW5lZCBieSBhbm90aGVyP1xuICogQHBhcmFtIHtOb2RlfSBjb250YWluZWUgVGhlIGNvbnRhaW5lZCBub2RlLlxuICogQHBhcmFtIHtOb2RlfSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBjb250YWluZWUgaXMgaW5zaWRlIChvciBlcXVhbCB0bykgY29udGFpbmVyLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUNvbnRhaW5lZEJ5KGNvbnRhaW5lZSwgY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjb250YWluZWVOb2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoY29udGFpbmVlKTtcbiAgd2hpbGUgKGNvbnRhaW5lZU5vZGUgJiYgY29udGFpbmVlTm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVlTm9kZSA9IGNvbnRhaW5lZU5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gKGNvbnRhaW5lZU5vZGUgPT09IGNvbnRhaW5lcik7XG59O1xuXG4vLyBUaGlzIG1hc2tzIHNvbWUgbnVtZXJpYyBpc3N1ZXMgaW4gb2xkZXIgdmVyc2lvbnMgb2YgRmlyZWZveCxcbi8vIHdoZXJlIDEuMC9NYXRoLnBvdygxMCwyKSAhPSBNYXRoLnBvdygxMCwtMikuXG4vKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3coYmFzZSwgZXhwKSB7XG4gIGlmIChleHAgPCAwKSB7XG4gICAgcmV0dXJuIDEuMCAvIE1hdGgucG93KGJhc2UsIC1leHApO1xuICB9XG4gIHJldHVybiBNYXRoLnBvdyhiYXNlLCBleHApO1xufTtcblxudmFyIFJHQkFfUkUgPSAvXnJnYmE/XFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSg/OixcXHMqKFswMV0oPzpcXC5cXGQrKT8pKT9cXCkkLztcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRvUkdCXyB3aGljaCBwYXJzZXMgc3RyaW5ncyBvZiB0aGUgZm9ybTpcbiAqIHJnYigxMjMsIDQ1LCA2NylcbiAqIHJnYmEoMTIzLCA0NSwgNjcsIDAuNSlcbiAqIEByZXR1cm4gcGFyc2VkIHtyLGcsYixhP30gdHVwbGUgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VSR0JBKHJnYlN0cikge1xuICB2YXIgYml0cyA9IFJHQkFfUkUuZXhlYyhyZ2JTdHIpO1xuICBpZiAoIWJpdHMpIHJldHVybiBudWxsO1xuICB2YXIgciA9IHBhcnNlSW50KGJpdHNbMV0sIDEwKSxcbiAgICAgIGcgPSBwYXJzZUludChiaXRzWzJdLCAxMCksXG4gICAgICBiID0gcGFyc2VJbnQoYml0c1szXSwgMTApO1xuICBpZiAoYml0c1s0XSkge1xuICAgIHJldHVybiB7cjogciwgZzogZywgYjogYiwgYTogcGFyc2VGbG9hdChiaXRzWzRdKX07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtyOiByLCBnOiBnLCBiOiBifTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFueSB2YWxpZCBDU1MgY29sb3IgKGhleCwgcmdiKCksIG5hbWVkIGNvbG9yKSB0byBhbiBSR0IgdHVwbGUuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBjb2xvclN0ciBBbnkgdmFsaWQgQ1NTIGNvbG9yIHN0cmluZy5cbiAqIEByZXR1cm4ge3tyOm51bWJlcixnOm51bWJlcixiOm51bWJlcixhOm51bWJlcj99fSBQYXJzZWQgUkdCIHR1cGxlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUkdCXyhjb2xvclN0cikge1xuICAvLyBTdHJhdGVneTogRmlyc3QgdHJ5IHRvIHBhcnNlIGNvbG9yU3RyIGRpcmVjdGx5LiBUaGlzIGlzIGZhc3QgJiBhdm9pZHMgRE9NXG4gIC8vIG1hbmlwdWxhdGlvbi4gIElmIHRoYXQgZmFpbHMgKGUuZy4gZm9yIG5hbWVkIGNvbG9ycyBsaWtlICdyZWQnKSwgdGhlblxuICAvLyBjcmVhdGUgYSBoaWRkZW4gRE9NIGVsZW1lbnQgYW5kIHBhcnNlIGl0cyBjb21wdXRlZCBjb2xvci5cbiAgdmFyIHJnYiA9IHBhcnNlUkdCQShjb2xvclN0cik7XG4gIGlmIChyZ2IpIHJldHVybiByZ2I7XG5cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHI7XG4gIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgdmFyIHJnYlN0ciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdiwgbnVsbCkuYmFja2dyb3VuZENvbG9yO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIHJldHVybiBwYXJzZVJHQkEocmdiU3RyKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlICZsdDtjYW52YXMmZ3Q7IHRhZy5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQ9fSBvcHRfY2FudmFzRWxlbWVudCBQYXNzIGEgY2FudmFzIGVsZW1lbnQgYXMgYW5cbiAqICAgICBvcHRpbWl6YXRpb24gaWYgeW91IGhhdmUgb25lLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbnZhc1N1cHBvcnRlZChvcHRfY2FudmFzRWxlbWVudCkge1xuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSBvcHRfY2FudmFzRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgdmFsdWUgYXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIuIFRoaXMgaXMgbGlrZSB0aGUgcGFyc2VGbG9hdCgpXG4gKiBidWlsdC1pbiwgYnV0IHdpdGggYSBmZXcgZGlmZmVyZW5jZXM6XG4gKiAtIHRoZSBlbXB0eSBzdHJpbmcgaXMgcGFyc2VkIGFzIG51bGwsIHJhdGhlciB0aGFuIE5hTi5cbiAqIC0gaWYgdGhlIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkIGF0IGFsbCwgYW4gZXJyb3IgaXMgbG9nZ2VkLlxuICogSWYgdGhlIHN0cmluZyBjYW4ndCBiZSBwYXJzZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB4IFRoZSBzdHJpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9saW5lX25vIFRoZSBsaW5lIG51bWJlciBmcm9tIHdoaWNoIHRoZSBzdHJpbmcgY29tZXMuXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9saW5lIFRoZSB0ZXh0IG9mIHRoZSBsaW5lIGZyb20gd2hpY2ggdGhlIHN0cmluZyBjb21lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRfKHgsIG9wdF9saW5lX25vLCBvcHRfbGluZSkge1xuICB2YXIgdmFsID0gcGFyc2VGbG9hdCh4KTtcbiAgaWYgKCFpc05hTih2YWwpKSByZXR1cm4gdmFsO1xuXG4gIC8vIFRyeSB0byBmaWd1cmUgb3V0IHdoYXQgaGFwcGVlbmQuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBwYXJzZSBpdCBhcyBudWxsLlxuICBpZiAoL14gKiQvLnRlc3QoeCkpIHJldHVybiBudWxsO1xuXG4gIC8vIElmIGl0IHdhcyBhY3R1YWxseSBcIk5hTlwiLCByZXR1cm4gaXQgYXMgTmFOLlxuICBpZiAoL14gKm5hbiAqJC9pLnRlc3QoeCkpIHJldHVybiBOYU47XG5cbiAgLy8gTG9va3MgbGlrZSBhIHBhcnNpbmcgZXJyb3IuXG4gIHZhciBtc2cgPSBcIlVuYWJsZSB0byBwYXJzZSAnXCIgKyB4ICsgXCInIGFzIGEgbnVtYmVyXCI7XG4gIGlmIChvcHRfbGluZSAhPT0gdW5kZWZpbmVkICYmIG9wdF9saW5lX25vICE9PSB1bmRlZmluZWQpIHtcbiAgICBtc2cgKz0gXCIgb24gbGluZSBcIiArICgxKyhvcHRfbGluZV9ub3x8MCkpICsgXCIgKCdcIiArIG9wdF9saW5lICsgXCInKSBvZiBDU1YuXCI7XG4gIH1cbiAgY29uc29sZS5lcnJvcihtc2cpO1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vLyBMYWJlbCBjb25zdGFudHMgZm9yIHRoZSBsYWJlbHNLTUIgYW5kIGxhYmVsc0tNRzIgb3B0aW9ucy5cbi8vIChpLmUuICcxMDAwMDAnIC0+ICcxMDBLJylcbnZhciBLTUJfTEFCRUxTID0gWyAnSycsICdNJywgJ0InLCAnVCcsICdRJyBdO1xudmFyIEtNRzJfQklHX0xBQkVMUyA9IFsgJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJywgJ1onLCAnWScgXTtcbnZhciBLTUcyX1NNQUxMX0xBQkVMUyA9IFsgJ20nLCAndScsICduJywgJ3AnLCAnZicsICdhJywgJ3onLCAneScgXTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJuIGEgc3RyaW5nIHZlcnNpb24gb2YgYSBudW1iZXIuIFRoaXMgcmVzcGVjdHMgdGhlIGRpZ2l0c0FmdGVyRGVjaW1hbFxuICogYW5kIG1heE51bWJlcldpZHRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtEeWdyYXBofSBvcHRzIEFuIG9wdGlvbnMgdmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVmFsdWVGb3JtYXR0ZXIoeCwgb3B0cykge1xuICB2YXIgc2lnRmlncyA9IG9wdHMoJ3NpZ0ZpZ3MnKTtcblxuICBpZiAoc2lnRmlncyAhPT0gbnVsbCkge1xuICAgIC8vIFVzZXIgaGFzIG9wdGVkIGZvciBhIGZpeGVkIG51bWJlciBvZiBzaWduaWZpY2FudCBmaWd1cmVzLlxuICAgIHJldHVybiBmbG9hdEZvcm1hdCh4LCBzaWdGaWdzKTtcbiAgfVxuXG4gIHZhciBkaWdpdHMgPSBvcHRzKCdkaWdpdHNBZnRlckRlY2ltYWwnKTtcbiAgdmFyIG1heE51bWJlcldpZHRoID0gb3B0cygnbWF4TnVtYmVyV2lkdGgnKTtcblxuICB2YXIga21iID0gb3B0cygnbGFiZWxzS01CJyk7XG4gIHZhciBrbWcyID0gb3B0cygnbGFiZWxzS01HMicpO1xuXG4gIHZhciBsYWJlbDtcblxuICAvLyBzd2l0Y2ggdG8gc2NpZW50aWZpYyBub3RhdGlvbiBpZiB3ZSB1bmRlcmZsb3cgb3Igb3ZlcmZsb3cgZml4ZWQgZGlzcGxheS5cbiAgaWYgKHggIT09IDAuMCAmJlxuICAgICAgKE1hdGguYWJzKHgpID49IE1hdGgucG93KDEwLCBtYXhOdW1iZXJXaWR0aCkgfHxcbiAgICAgICBNYXRoLmFicyh4KSA8IE1hdGgucG93KDEwLCAtZGlnaXRzKSkpIHtcbiAgICBsYWJlbCA9IHgudG9FeHBvbmVudGlhbChkaWdpdHMpO1xuICB9IGVsc2Uge1xuICAgIGxhYmVsID0gJycgKyByb3VuZF8oeCwgZGlnaXRzKTtcbiAgfVxuXG4gIGlmIChrbWIgfHwga21nMikge1xuICAgIHZhciBrO1xuICAgIHZhciBrX2xhYmVscyA9IFtdO1xuICAgIHZhciBtX2xhYmVscyA9IFtdO1xuICAgIGlmIChrbWIpIHtcbiAgICAgIGsgPSAxMDAwO1xuICAgICAga19sYWJlbHMgPSBLTUJfTEFCRUxTO1xuICAgIH1cbiAgICBpZiAoa21nMikge1xuICAgICAgaWYgKGttYikgY29uc29sZS53YXJuKFwiU2V0dGluZyBib3RoIGxhYmVsc0tNQiBhbmQgbGFiZWxzS01HMi4gUGljayBvbmUhXCIpO1xuICAgICAgayA9IDEwMjQ7XG4gICAgICBrX2xhYmVscyA9IEtNRzJfQklHX0xBQkVMUztcbiAgICAgIG1fbGFiZWxzID0gS01HMl9TTUFMTF9MQUJFTFM7XG4gICAgfVxuXG4gICAgdmFyIGFic3ggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgbiA9IHBvdyhrLCBrX2xhYmVscy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGogPSBrX2xhYmVscy5sZW5ndGggLSAxOyBqID49IDA7IGotLSwgbiAvPSBrKSB7XG4gICAgICBpZiAoYWJzeCA+PSBuKSB7XG4gICAgICAgIGxhYmVsID0gcm91bmRfKHggLyBuLCBkaWdpdHMpICsga19sYWJlbHNbal07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa21nMikge1xuICAgICAgLy8gVE9ETyhkYW52ayk6IGNsZWFuIHVwIHRoaXMgbG9naWMuIFdoeSBzbyBkaWZmZXJlbnQgdGhhbiBrbWI/XG4gICAgICB2YXIgeF9wYXJ0cyA9IFN0cmluZyh4LnRvRXhwb25lbnRpYWwoKSkuc3BsaXQoJ2UtJyk7XG4gICAgICBpZiAoeF9wYXJ0cy5sZW5ndGggPT09IDIgJiYgeF9wYXJ0c1sxXSA+PSAzICYmIHhfcGFydHNbMV0gPD0gMjQpIHtcbiAgICAgICAgaWYgKHhfcGFydHNbMV0gJSAzID4gMCkge1xuICAgICAgICAgIGxhYmVsID0gcm91bmRfKHhfcGFydHNbMF0gL1xuICAgICAgICAgICAgICBwb3coMTAsICh4X3BhcnRzWzFdICUgMykpLFxuICAgICAgICAgICAgICBkaWdpdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsID0gTnVtYmVyKHhfcGFydHNbMF0pLnRvRml4ZWQoMik7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwgKz0gbV9sYWJlbHNbTWF0aC5mbG9vcih4X3BhcnRzWzFdIC8gMykgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG4vKipcbiAqIHZhcmlhbnQgZm9yIHVzZSBhcyBhbiBheGlzTGFiZWxGb3JtYXR0ZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyKHgsIGdyYW51bGFyaXR5LCBvcHRzKSB7XG4gIHJldHVybiBudW1iZXJWYWx1ZUZvcm1hdHRlci5jYWxsKHRoaXMsIHgsIG9wdHMpO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICovXG52YXIgU0hPUlRfTU9OVEhfTkFNRVNfID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG5cbi8qKlxuICogQ29udmVydCBhIEpTIGRhdGUgdG8gYSBzdHJpbmcgYXBwcm9wcmlhdGUgdG8gZGlzcGxheSBvbiBhbiBheGlzIHRoYXRcbiAqIGlzIGRpc3BsYXlpbmcgdmFsdWVzIGF0IHRoZSBzdGF0ZWQgZ3JhbnVsYXJpdHkuIFRoaXMgcmVzcGVjdHMgdGhlXG4gKiBsYWJlbHNVVEMgb3B0aW9uLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXJ9IGdyYW51bGFyaXR5IE9uZSBvZiB0aGUgRHlncmFwaCBncmFudWxhcml0eSBjb25zdGFudHNcbiAqIEBwYXJhbSB7RHlncmFwaH0gb3B0cyBBbiBvcHRpb25zIHZpZXdcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0dGVkIGFzIGxvY2FsIHRpbWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlQXhpc0xhYmVsRm9ybWF0dGVyKGRhdGUsIGdyYW51bGFyaXR5LCBvcHRzKSB7XG4gIHZhciB1dGMgPSBvcHRzKCdsYWJlbHNVVEMnKTtcbiAgdmFyIGFjY2Vzc29ycyA9IHV0YyA/IERhdGVBY2Nlc3NvcnNVVEMgOiBEYXRlQWNjZXNzb3JzTG9jYWw7XG5cbiAgdmFyIHllYXIgPSBhY2Nlc3NvcnMuZ2V0RnVsbFllYXIoZGF0ZSksXG4gICAgICBtb250aCA9IGFjY2Vzc29ycy5nZXRNb250aChkYXRlKSxcbiAgICAgIGRheSA9IGFjY2Vzc29ycy5nZXREYXRlKGRhdGUpLFxuICAgICAgaG91cnMgPSBhY2Nlc3NvcnMuZ2V0SG91cnMoZGF0ZSksXG4gICAgICBtaW5zID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoZGF0ZSksXG4gICAgICBzZWNzID0gYWNjZXNzb3JzLmdldFNlY29uZHMoZGF0ZSksXG4gICAgICBtaWxsaXMgPSBhY2Nlc3NvcnMuZ2V0TWlsbGlzZWNvbmRzKGRhdGUpO1xuXG4gIGlmIChncmFudWxhcml0eSA+PSBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5ERUNBREFMKSB7XG4gICAgcmV0dXJuICcnICsgeWVhcjtcbiAgfSBlbHNlIGlmIChncmFudWxhcml0eSA+PSBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5NT05USExZKSB7XG4gICAgcmV0dXJuIFNIT1JUX01PTlRIX05BTUVTX1ttb250aF0gKyAnJiMxNjA7JyArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZyYWMgPSBob3VycyAqIDM2MDAgKyBtaW5zICogNjAgKyBzZWNzICsgMWUtMyAqIG1pbGxpcztcbiAgICBpZiAoZnJhYyA9PT0gMCB8fCBncmFudWxhcml0eSA+PSBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5EQUlMWSkge1xuICAgICAgLy8gZS5nLiAnMjEgSmFuJyAoJWQlYilcbiAgICAgIHJldHVybiB6ZXJvcGFkKGRheSkgKyAnJiMxNjA7JyArIFNIT1JUX01PTlRIX05BTUVTX1ttb250aF07XG4gICAgfSBlbHNlIGlmIChncmFudWxhcml0eSA8IER5Z3JhcGhUaWNrZXJzLkdyYW51bGFyaXR5LlNFQ09ORExZKSB7XG4gICAgICAvLyBlLmcuIDQwLjMxMCAobWVhbmluZyA0MCBzZWNvbmRzIGFuZCAzMTAgbWlsbGlzZWNvbmRzKVxuICAgICAgdmFyIHN0ciA9IFwiXCIgKyBtaWxsaXM7XG4gICAgICByZXR1cm4gemVyb3BhZChzZWNzKSArIFwiLlwiICsgKCcwMDAnK3N0cikuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPiBEeWdyYXBoVGlja2Vycy5HcmFudWxhcml0eS5NSU5VVEVMWSkge1xuICAgICAgcmV0dXJuIGhtc1N0cmluZ18oaG91cnMsIG1pbnMsIHNlY3MsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaG1zU3RyaW5nXyhob3VycywgbWlucywgc2VjcywgbWlsbGlzKTtcbiAgICB9XG4gIH1cbn07XG4vLyBhbGlhcyBpbiBjYXNlIGFueW9uZSBpcyByZWZlcmVuY2luZyB0aGUgb2xkIG1ldGhvZC5cbi8vIER5Z3JhcGguZGF0ZUF4aXNGb3JtYXR0ZXIgPSBEeWdyYXBoLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHZlcnNpb24gb2YgYSBKUyBkYXRlIGZvciBhIHZhbHVlIGxhYmVsLiBUaGlzIHJlc3BlY3RzIHRoZVxuICogbGFiZWxzVVRDIG9wdGlvbi5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBiZSBmb3JtYXR0ZWRcbiAqIEBwYXJhbSB7RHlncmFwaH0gb3B0cyBBbiBvcHRpb25zIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlVmFsdWVGb3JtYXR0ZXIoZCwgb3B0cykge1xuICByZXR1cm4gZGF0ZVN0cmluZ18oZCwgb3B0cygnbGFiZWxzVVRDJykpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return numericLinearTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return numericTicks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return dateTicker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Granularity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getDateAxis; });\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Description of this file.\n * @author danvk@google.com (Dan Vanderkam)\n *\n * A ticker is a function with the following interface:\n *\n * function(a, b, pixels, options_view, dygraph, forced_values);\n * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },\n *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },\n *      ...\n *    ]\n *\n * The returned value is called a "tick list".\n *\n * Arguments\n * ---------\n *\n * [a, b] is the range of the axis for which ticks are being generated. For a\n * numeric axis, these will simply be numbers. For a date axis, these will be\n * millis since epoch (convertable to Date objects using "new Date(a)" and "new\n * Date(b)").\n *\n * opts provides access to chart- and axis-specific options. It can be used to\n * access number/date formatting code/options, check for a log scale, etc.\n *\n * pixels is the length of the axis in pixels. opts(\'pixelsPerLabel\') is the\n * minimum amount of space to be allotted to each label. For instance, if\n * pixels=400 and opts(\'pixelsPerLabel\')=40 then the ticker should return\n * between zero and ten (400/40) ticks.\n *\n * dygraph is the Dygraph object for which an axis is being constructed.\n *\n * forced_values is used for secondary y-axes. The tick positions are typically\n * set by the primary y-axis, so the secondary y-axis has no choice in where to\n * put these. It simply has to generate labels for these data values.\n *\n * Tick lists\n * ----------\n * Typically a tick will have both a grid/tick line and a label at one end of\n * that line (at the bottom for an x-axis, at left or right for the y-axis).\n *\n * A tick may be missing one of these two components:\n * - If "label_v" is specified instead of "v", then there will be no tick or\n *   gridline, just a label.\n * - Similarly, if "label" is not specified, then there will be a gridline\n *   without a label.\n *\n * This flexibility is useful in a few situations:\n * - For log scales, some of the tick lines may be too close to all have labels.\n * - For date scales where years are being displayed, it is desirable to display\n *   tick marks at the beginnings of years but labels (e.g. "2006") in the\n *   middle of the years.\n */\n\n/*jshint sub:true */\n/*global Dygraph:false */\n\n\n\n\n/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */\nvar TickList = undefined;  // the \' = undefined\' keeps jshint happy.\n\n/** @typedef {function(\n *    number,\n *    number,\n *    number,\n *    function(string):*,\n *    Dygraph=,\n *    Array.<number>=\n *  ): TickList}\n */\nvar Ticker = undefined;  // the \' = undefined\' keeps jshint happy.\n\n/** @type {Ticker} */\nvar numericLinearTicks = function(a, b, pixels, opts, dygraph, vals) {\n  var nonLogscaleOpts = function(opt) {\n    if (opt === \'logscale\') return false;\n    return opts(opt);\n  };\n  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);\n};\n\n/** @type {Ticker} */\nvar numericTicks = function(a, b, pixels, opts, dygraph, vals) {\n  var pixels_per_tick = /** @type{number} */(opts(\'pixelsPerLabel\'));\n  var ticks = [];\n  var i, j, tickV, nTicks;\n  if (vals) {\n    for (i = 0; i < vals.length; i++) {\n      ticks.push({v: vals[i]});\n    }\n  } else {\n    // TODO(danvk): factor this log-scale block out into a separate function.\n    if (opts("logscale")) {\n      nTicks  = Math.floor(pixels / pixels_per_tick);\n      var minIdx = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* binarySearch */ "j"](a, PREFERRED_LOG_TICK_VALUES, 1);\n      var maxIdx = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* binarySearch */ "j"](b, PREFERRED_LOG_TICK_VALUES, -1);\n      if (minIdx == -1) {\n        minIdx = 0;\n      }\n      if (maxIdx == -1) {\n        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n      }\n      // Count the number of tick values would appear, if we can get at least\n      // nTicks / 4 accept them.\n      var lastDisplayed = null;\n      if (maxIdx - minIdx >= nTicks / 4) {\n        for (var idx = maxIdx; idx >= minIdx; idx--) {\n          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];\n          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;\n          var tick = { v: tickValue };\n          if (lastDisplayed === null) {\n            lastDisplayed = {\n              tickValue : tickValue,\n              pixel_coord : pixel_coord\n            };\n          } else {\n            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {\n              lastDisplayed = {\n                tickValue : tickValue,\n                pixel_coord : pixel_coord\n              };\n            } else {\n              tick.label = "";\n            }\n          }\n          ticks.push(tick);\n        }\n        // Since we went in backwards order.\n        ticks.reverse();\n      }\n    }\n\n    // ticks.length won\'t be 0 if the log scale function finds values to insert.\n    if (ticks.length === 0) {\n      // Basic idea:\n      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.\n      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).\n      // The first spacing greater than pixelsPerYLabel is what we use.\n      // TODO(danvk): version that works on a log scale.\n      var kmg2 = opts("labelsKMG2");\n      var mults, base;\n      if (kmg2) {\n        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];\n        base = 16;\n      } else {\n        mults = [1, 2, 5, 10, 20, 50, 100];\n        base = 10;\n      }\n\n      // Get the maximum number of permitted ticks based on the\n      // graph\'s pixel size and pixels_per_tick setting.\n      var max_ticks = Math.ceil(pixels / pixels_per_tick);\n\n      // Now calculate the data unit equivalent of this tick spacing.\n      // Use abs() since graphs may have a reversed Y axis.\n      var units_per_tick = Math.abs(b - a) / max_ticks;\n\n      // Based on this, get a starting scale which is the largest\n      // integer power of the chosen base (10 or 16) that still remains\n      // below the requested pixels_per_tick spacing.\n      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));\n      var base_scale = Math.pow(base, base_power);\n\n      // Now try multiples of the starting scale until we find one\n      // that results in tick marks spaced sufficiently far apart.\n      // The "mults" array should cover the range 1 .. base^2 to\n      // adjust for rounding and edge effects.\n      var scale, low_val, high_val, spacing;\n      for (j = 0; j < mults.length; j++) {\n        scale = base_scale * mults[j];\n        low_val = Math.floor(a / scale) * scale;\n        high_val = Math.ceil(b / scale) * scale;\n        nTicks = Math.abs(high_val - low_val) / scale;\n        spacing = pixels / nTicks;\n        if (spacing > pixels_per_tick) break;\n      }\n\n      // Construct the set of ticks.\n      // Allow reverse y-axis if it\'s explicitly requested.\n      if (low_val > high_val) scale *= -1;\n      for (i = 0; i <= nTicks; i++) {\n        tickV = low_val + i * scale;\n        ticks.push( {v: tickV} );\n      }\n    }\n  }\n\n  var formatter = /**@type{AxisLabelFormatter}*/(opts(\'axisLabelFormatter\'));\n\n  // Add labels to the ticks.\n  for (i = 0; i < ticks.length; i++) {\n    if (ticks[i].label !== undefined) continue;  // Use current label.\n    // TODO(danvk): set granularity to something appropriate here.\n    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);\n  }\n\n  return ticks;\n};\n\n\n/** @type {Ticker} */\nvar dateTicker = function(a, b, pixels, opts, dygraph, vals) {\n  var chosen = pickDateTickGranularity(a, b, pixels, opts);\n\n  if (chosen >= 0) {\n    return getDateAxis(a, b, chosen, opts, dygraph);\n  } else {\n    // this can happen if self.width_ is zero.\n    return [];\n  }\n};\n\n// Time granularity enumeration\nvar Granularity = {\n  MILLISECONDLY: 0,\n  TWO_MILLISECONDLY: 1,\n  FIVE_MILLISECONDLY: 2,\n  TEN_MILLISECONDLY: 3,\n  FIFTY_MILLISECONDLY: 4,\n  HUNDRED_MILLISECONDLY: 5,\n  FIVE_HUNDRED_MILLISECONDLY: 6,\n  SECONDLY: 7,\n  TWO_SECONDLY: 8,\n  FIVE_SECONDLY: 9,\n  TEN_SECONDLY: 10,\n  THIRTY_SECONDLY: 11,\n  MINUTELY: 12,\n  TWO_MINUTELY: 13,\n  FIVE_MINUTELY: 14,\n  TEN_MINUTELY: 15,\n  THIRTY_MINUTELY: 16,\n  HOURLY: 17,\n  TWO_HOURLY: 18,\n  SIX_HOURLY: 19,\n  DAILY: 20,\n  TWO_DAILY: 21,\n  WEEKLY: 22,\n  MONTHLY: 23,\n  QUARTERLY: 24,\n  BIANNUAL: 25,\n  ANNUAL: 26,\n  DECADAL: 27,\n  CENTENNIAL: 28,\n  NUM_GRANULARITIES: 29\n}\n\n// Date components enumeration (in the order of the arguments in Date)\n// TODO: make this an @enum\nvar DateField = {\n  DATEFIELD_Y: 0,\n  DATEFIELD_M: 1,\n  DATEFIELD_D: 2,\n  DATEFIELD_HH: 3,\n  DATEFIELD_MM: 4,\n  DATEFIELD_SS: 5,\n  DATEFIELD_MS: 6,\n  NUM_DATEFIELDS: 7\n};\n\n\n/**\n * The value of datefield will start at an even multiple of "step", i.e.\n *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.\n *\n * For granularities <= HOURLY, ticks are generated every `spacing` ms.\n *\n * At coarser granularities, ticks are generated by incrementing `datefield` by\n *   `step`. In this case, the `spacing` value is only used to estimate the\n *   number of ticks. It should roughly correspond to the spacing between\n *   adjacent ticks.\n *\n * @type {Array.<{datefield:number, step:number, spacing:number}>}\n */\nvar TICK_PLACEMENT = [];\nTICK_PLACEMENT[Granularity.MILLISECONDLY]               = {datefield: DateField.DATEFIELD_MS, step:   1, spacing: 1};\nTICK_PLACEMENT[Granularity.TWO_MILLISECONDLY]           = {datefield: DateField.DATEFIELD_MS, step:   2, spacing: 2};\nTICK_PLACEMENT[Granularity.FIVE_MILLISECONDLY]          = {datefield: DateField.DATEFIELD_MS, step:   5, spacing: 5};\nTICK_PLACEMENT[Granularity.TEN_MILLISECONDLY]           = {datefield: DateField.DATEFIELD_MS, step:  10, spacing: 10};\nTICK_PLACEMENT[Granularity.FIFTY_MILLISECONDLY]         = {datefield: DateField.DATEFIELD_MS, step:  50, spacing: 50};\nTICK_PLACEMENT[Granularity.HUNDRED_MILLISECONDLY]       = {datefield: DateField.DATEFIELD_MS, step: 100, spacing: 100};\nTICK_PLACEMENT[Granularity.FIVE_HUNDRED_MILLISECONDLY]  = {datefield: DateField.DATEFIELD_MS, step: 500, spacing: 500};\nTICK_PLACEMENT[Granularity.SECONDLY]        = {datefield: DateField.DATEFIELD_SS, step:   1, spacing: 1000 * 1};\nTICK_PLACEMENT[Granularity.TWO_SECONDLY]    = {datefield: DateField.DATEFIELD_SS, step:   2, spacing: 1000 * 2};\nTICK_PLACEMENT[Granularity.FIVE_SECONDLY]   = {datefield: DateField.DATEFIELD_SS, step:   5, spacing: 1000 * 5};\nTICK_PLACEMENT[Granularity.TEN_SECONDLY]    = {datefield: DateField.DATEFIELD_SS, step:  10, spacing: 1000 * 10};\nTICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = {datefield: DateField.DATEFIELD_SS, step:  30, spacing: 1000 * 30};\nTICK_PLACEMENT[Granularity.MINUTELY]        = {datefield: DateField.DATEFIELD_MM, step:   1, spacing: 1000 * 60};\nTICK_PLACEMENT[Granularity.TWO_MINUTELY]    = {datefield: DateField.DATEFIELD_MM, step:   2, spacing: 1000 * 60 * 2};\nTICK_PLACEMENT[Granularity.FIVE_MINUTELY]   = {datefield: DateField.DATEFIELD_MM, step:   5, spacing: 1000 * 60 * 5};\nTICK_PLACEMENT[Granularity.TEN_MINUTELY]    = {datefield: DateField.DATEFIELD_MM, step:  10, spacing: 1000 * 60 * 10};\nTICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = {datefield: DateField.DATEFIELD_MM, step:  30, spacing: 1000 * 60 * 30};\nTICK_PLACEMENT[Granularity.HOURLY]          = {datefield: DateField.DATEFIELD_HH, step:   1, spacing: 1000 * 3600};\nTICK_PLACEMENT[Granularity.TWO_HOURLY]      = {datefield: DateField.DATEFIELD_HH, step:   2, spacing: 1000 * 3600 * 2};\nTICK_PLACEMENT[Granularity.SIX_HOURLY]      = {datefield: DateField.DATEFIELD_HH, step:   6, spacing: 1000 * 3600 * 6};\nTICK_PLACEMENT[Granularity.DAILY]           = {datefield: DateField.DATEFIELD_D,  step:   1, spacing: 1000 * 86400};\nTICK_PLACEMENT[Granularity.TWO_DAILY]       = {datefield: DateField.DATEFIELD_D,  step:   2, spacing: 1000 * 86400 * 2};\nTICK_PLACEMENT[Granularity.WEEKLY]          = {datefield: DateField.DATEFIELD_D,  step:   7, spacing: 1000 * 604800};\nTICK_PLACEMENT[Granularity.MONTHLY]         = {datefield: DateField.DATEFIELD_M,  step:   1, spacing: 1000 * 7200  * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 / 12\nTICK_PLACEMENT[Granularity.QUARTERLY]       = {datefield: DateField.DATEFIELD_M,  step:   3, spacing: 1000 * 21600 * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 / 4\nTICK_PLACEMENT[Granularity.BIANNUAL]        = {datefield: DateField.DATEFIELD_M,  step:   6, spacing: 1000 * 43200 * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 / 2\nTICK_PLACEMENT[Granularity.ANNUAL]          = {datefield: DateField.DATEFIELD_Y,  step:   1, spacing: 1000 * 86400   * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 * 1\nTICK_PLACEMENT[Granularity.DECADAL]         = {datefield: DateField.DATEFIELD_Y,  step:  10, spacing: 1000 * 864000  * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 * 10\nTICK_PLACEMENT[Granularity.CENTENNIAL]      = {datefield: DateField.DATEFIELD_Y,  step: 100, spacing: 1000 * 8640000 * 365.2524}; // 1e3 * 60 * 60 * 24 * 365.2524 * 100\n\n\n/**\n * This is a list of human-friendly values at which to show tick marks on a log\n * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:\n * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...\n * NOTE: this assumes that utils.LOG_SCALE = 10.\n * @type {Array.<number>}\n */\nvar PREFERRED_LOG_TICK_VALUES = (function() {\n  var vals = [];\n  for (var power = -39; power <= 39; power++) {\n    var range = Math.pow(10, power);\n    for (var mult = 1; mult <= 9; mult++) {\n      var val = range * mult;\n      vals.push(val);\n    }\n  }\n  return vals;\n})();\n\n/**\n * Determine the correct granularity of ticks on a date axis.\n *\n * @param {number} a Left edge of the chart (ms)\n * @param {number} b Right edge of the chart (ms)\n * @param {number} pixels Size of the chart in the relevant dimension (width).\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @return {number} The appropriate axis granularity for this chart. See the\n *     enumeration of possible values in dygraph-tickers.js.\n */\nvar pickDateTickGranularity = function(a, b, pixels, opts) {\n  var pixels_per_tick = /** @type{number} */(opts(\'pixelsPerLabel\'));\n  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {\n    var num_ticks = numDateTicks(a, b, i);\n    if (pixels / num_ticks >= pixels_per_tick) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Compute the number of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @return {number} (Approximate) number of ticks that would result.\n */\nvar numDateTicks = function(start_time, end_time, granularity) {\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n  return Math.round(1.0 * (end_time - start_time) / spacing);\n};\n\n/**\n * Compute the positions and labels of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @param {Dygraph=} dg\n * @return {!TickList}\n */\nvar getDateAxis = function(start_time, end_time, granularity, opts, dg) {\n  var formatter = /** @type{AxisLabelFormatter} */(\n      opts("axisLabelFormatter"));\n  var utc = opts("labelsUTC");\n  var accessors = utc ? _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* DateAccessorsUTC */ "e"] : _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* DateAccessorsLocal */ "d"];\n\n  var datefield = TICK_PLACEMENT[granularity].datefield;\n  var step = TICK_PLACEMENT[granularity].step;\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n\n  // Choose a nice tick position before the initial instant.\n  // Currently, this code deals properly with the existent daily granularities:\n  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).\n  // Other daily granularities (say TWO_DAILY) should also be handled specially\n  // by setting the start_date_offset to 0.\n  var start_date = new Date(start_time);\n  var date_array = [];\n  date_array[DateField.DATEFIELD_Y]  = accessors.getFullYear(start_date);\n  date_array[DateField.DATEFIELD_M]  = accessors.getMonth(start_date);\n  date_array[DateField.DATEFIELD_D]  = accessors.getDate(start_date);\n  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);\n  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);\n  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);\n  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);\n\n  var start_date_offset = date_array[datefield] % step;\n  if (granularity == Granularity.WEEKLY) {\n    // This will put the ticks on Sundays.\n    start_date_offset = accessors.getDay(start_date);\n  }\n  \n  date_array[datefield] -= start_date_offset;\n  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {\n    // The minimum value is 1 for the day of month, and 0 for all other fields.\n    date_array[df] = (df === DateField.DATEFIELD_D) ? 1 : 0;\n  }\n\n  // Generate the ticks.\n  // For granularities not coarser than HOURLY we use the fact that:\n  //   the number of milliseconds between ticks is constant\n  //   and equal to the defined spacing.\n  // Otherwise we rely on the \'roll over\' property of the Date functions:\n  //   when some date field is set to a value outside of its logical range,\n  //   the excess \'rolls over\' the next (more significant) field.\n  // However, when using local time with DST transitions,\n  // there are dates that do not represent any time value at all\n  // (those in the hour skipped at the \'spring forward\'),\n  // and the JavaScript engines usually return an equivalent value.\n  // Hence we have to check that the date is properly increased at each step,\n  // returning a date at a nice tick position.\n  var ticks = [];\n  var tick_date = accessors.makeDate.apply(null, date_array);\n  var tick_time = tick_date.getTime();\n  if (granularity <= Granularity.HOURLY) {\n    if (tick_time < start_time) {\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n    while (tick_time <= end_time) {\n      ticks.push({ v: tick_time,\n                   label: formatter.call(dg, tick_date, granularity, opts, dg)\n                 });\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n  } else {\n    if (tick_time < start_time) {\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n    while (tick_time <= end_time) {\n      if (granularity >= Granularity.DAILY ||\n          accessors.getHours(tick_date) % step === 0) {\n        ticks.push({ v: tick_time,\n                     label: formatter.call(dg, tick_date, granularity, opts, dg)\n                   });\n      }\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n  }\n  return ticks;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC10aWNrZXJzLmpzPzUzMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVzY3JpcHRpb24gb2YgdGhpcyBmaWxlLlxuICogQGF1dGhvciBkYW52a0Bnb29nbGUuY29tIChEYW4gVmFuZGVya2FtKVxuICpcbiAqIEEgdGlja2VyIGlzIGEgZnVuY3Rpb24gd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZTpcbiAqXG4gKiBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdGlvbnNfdmlldywgZHlncmFwaCwgZm9yY2VkX3ZhbHVlcyk7XG4gKiAtPiBbIHsgdjogdGljazFfdiwgbGFiZWw6IHRpY2sxX2xhYmVsWywgbGFiZWxfdjogbGFiZWxfdjFdIH0sXG4gKiAgICAgIHsgdjogdGljazJfdiwgbGFiZWw6IHRpY2syX2xhYmVsWywgbGFiZWxfdjogbGFiZWxfdjJdIH0sXG4gKiAgICAgIC4uLlxuICogICAgXVxuICpcbiAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBjYWxsZWQgYSBcInRpY2sgbGlzdFwiLlxuICpcbiAqIEFyZ3VtZW50c1xuICogLS0tLS0tLS0tXG4gKlxuICogW2EsIGJdIGlzIHRoZSByYW5nZSBvZiB0aGUgYXhpcyBmb3Igd2hpY2ggdGlja3MgYXJlIGJlaW5nIGdlbmVyYXRlZC4gRm9yIGFcbiAqIG51bWVyaWMgYXhpcywgdGhlc2Ugd2lsbCBzaW1wbHkgYmUgbnVtYmVycy4gRm9yIGEgZGF0ZSBheGlzLCB0aGVzZSB3aWxsIGJlXG4gKiBtaWxsaXMgc2luY2UgZXBvY2ggKGNvbnZlcnRhYmxlIHRvIERhdGUgb2JqZWN0cyB1c2luZyBcIm5ldyBEYXRlKGEpXCIgYW5kIFwibmV3XG4gKiBEYXRlKGIpXCIpLlxuICpcbiAqIG9wdHMgcHJvdmlkZXMgYWNjZXNzIHRvIGNoYXJ0LSBhbmQgYXhpcy1zcGVjaWZpYyBvcHRpb25zLiBJdCBjYW4gYmUgdXNlZCB0b1xuICogYWNjZXNzIG51bWJlci9kYXRlIGZvcm1hdHRpbmcgY29kZS9vcHRpb25zLCBjaGVjayBmb3IgYSBsb2cgc2NhbGUsIGV0Yy5cbiAqXG4gKiBwaXhlbHMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgYXhpcyBpbiBwaXhlbHMuIG9wdHMoJ3BpeGVsc1BlckxhYmVsJykgaXMgdGhlXG4gKiBtaW5pbXVtIGFtb3VudCBvZiBzcGFjZSB0byBiZSBhbGxvdHRlZCB0byBlYWNoIGxhYmVsLiBGb3IgaW5zdGFuY2UsIGlmXG4gKiBwaXhlbHM9NDAwIGFuZCBvcHRzKCdwaXhlbHNQZXJMYWJlbCcpPTQwIHRoZW4gdGhlIHRpY2tlciBzaG91bGQgcmV0dXJuXG4gKiBiZXR3ZWVuIHplcm8gYW5kIHRlbiAoNDAwLzQwKSB0aWNrcy5cbiAqXG4gKiBkeWdyYXBoIGlzIHRoZSBEeWdyYXBoIG9iamVjdCBmb3Igd2hpY2ggYW4gYXhpcyBpcyBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBmb3JjZWRfdmFsdWVzIGlzIHVzZWQgZm9yIHNlY29uZGFyeSB5LWF4ZXMuIFRoZSB0aWNrIHBvc2l0aW9ucyBhcmUgdHlwaWNhbGx5XG4gKiBzZXQgYnkgdGhlIHByaW1hcnkgeS1heGlzLCBzbyB0aGUgc2Vjb25kYXJ5IHktYXhpcyBoYXMgbm8gY2hvaWNlIGluIHdoZXJlIHRvXG4gKiBwdXQgdGhlc2UuIEl0IHNpbXBseSBoYXMgdG8gZ2VuZXJhdGUgbGFiZWxzIGZvciB0aGVzZSBkYXRhIHZhbHVlcy5cbiAqXG4gKiBUaWNrIGxpc3RzXG4gKiAtLS0tLS0tLS0tXG4gKiBUeXBpY2FsbHkgYSB0aWNrIHdpbGwgaGF2ZSBib3RoIGEgZ3JpZC90aWNrIGxpbmUgYW5kIGEgbGFiZWwgYXQgb25lIGVuZCBvZlxuICogdGhhdCBsaW5lIChhdCB0aGUgYm90dG9tIGZvciBhbiB4LWF4aXMsIGF0IGxlZnQgb3IgcmlnaHQgZm9yIHRoZSB5LWF4aXMpLlxuICpcbiAqIEEgdGljayBtYXkgYmUgbWlzc2luZyBvbmUgb2YgdGhlc2UgdHdvIGNvbXBvbmVudHM6XG4gKiAtIElmIFwibGFiZWxfdlwiIGlzIHNwZWNpZmllZCBpbnN0ZWFkIG9mIFwidlwiLCB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gdGljayBvclxuICogICBncmlkbGluZSwganVzdCBhIGxhYmVsLlxuICogLSBTaW1pbGFybHksIGlmIFwibGFiZWxcIiBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZXJlIHdpbGwgYmUgYSBncmlkbGluZVxuICogICB3aXRob3V0IGEgbGFiZWwuXG4gKlxuICogVGhpcyBmbGV4aWJpbGl0eSBpcyB1c2VmdWwgaW4gYSBmZXcgc2l0dWF0aW9uczpcbiAqIC0gRm9yIGxvZyBzY2FsZXMsIHNvbWUgb2YgdGhlIHRpY2sgbGluZXMgbWF5IGJlIHRvbyBjbG9zZSB0byBhbGwgaGF2ZSBsYWJlbHMuXG4gKiAtIEZvciBkYXRlIHNjYWxlcyB3aGVyZSB5ZWFycyBhcmUgYmVpbmcgZGlzcGxheWVkLCBpdCBpcyBkZXNpcmFibGUgdG8gZGlzcGxheVxuICogICB0aWNrIG1hcmtzIGF0IHRoZSBiZWdpbm5pbmdzIG9mIHllYXJzIGJ1dCBsYWJlbHMgKGUuZy4gXCIyMDA2XCIpIGluIHRoZVxuICogICBtaWRkbGUgb2YgdGhlIHllYXJzLlxuICovXG5cbi8qanNoaW50IHN1Yjp0cnVlICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuLyoqIEB0eXBlZGVmIHtBcnJheS48e3Y6bnVtYmVyLCBsYWJlbDpzdHJpbmcsIGxhYmVsX3Y6KHN0cmluZ3x1bmRlZmluZWQpfT59ICovXG52YXIgVGlja0xpc3QgPSB1bmRlZmluZWQ7ICAvLyB0aGUgJyA9IHVuZGVmaW5lZCcga2VlcHMganNoaW50IGhhcHB5LlxuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9uKFxuICogICAgbnVtYmVyLFxuICogICAgbnVtYmVyLFxuICogICAgbnVtYmVyLFxuICogICAgZnVuY3Rpb24oc3RyaW5nKToqLFxuICogICAgRHlncmFwaD0sXG4gKiAgICBBcnJheS48bnVtYmVyPj1cbiAqICApOiBUaWNrTGlzdH1cbiAqL1xudmFyIFRpY2tlciA9IHVuZGVmaW5lZDsgIC8vIHRoZSAnID0gdW5kZWZpbmVkJyBrZWVwcyBqc2hpbnQgaGFwcHkuXG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBudW1lcmljTGluZWFyVGlja3MgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIHtcbiAgdmFyIG5vbkxvZ3NjYWxlT3B0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIGlmIChvcHQgPT09ICdsb2dzY2FsZScpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb3B0cyhvcHQpO1xuICB9O1xuICByZXR1cm4gbnVtZXJpY1RpY2tzKGEsIGIsIHBpeGVscywgbm9uTG9nc2NhbGVPcHRzLCBkeWdyYXBoLCB2YWxzKTtcbn07XG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBudW1lcmljVGlja3MgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMsIGR5Z3JhcGgsIHZhbHMpIHtcbiAgdmFyIHBpeGVsc19wZXJfdGljayA9IC8qKiBAdHlwZXtudW1iZXJ9ICovKG9wdHMoJ3BpeGVsc1BlckxhYmVsJykpO1xuICB2YXIgdGlja3MgPSBbXTtcbiAgdmFyIGksIGosIHRpY2tWLCBuVGlja3M7XG4gIGlmICh2YWxzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3Y6IHZhbHNbaV19KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyhkYW52ayk6IGZhY3RvciB0aGlzIGxvZy1zY2FsZSBibG9jayBvdXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuICAgIGlmIChvcHRzKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIG5UaWNrcyAgPSBNYXRoLmZsb29yKHBpeGVscyAvIHBpeGVsc19wZXJfdGljayk7XG4gICAgICB2YXIgbWluSWR4ID0gdXRpbHMuYmluYXJ5U2VhcmNoKGEsIFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMsIDEpO1xuICAgICAgdmFyIG1heElkeCA9IHV0aWxzLmJpbmFyeVNlYXJjaChiLCBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTLCAtMSk7XG4gICAgICBpZiAobWluSWR4ID09IC0xKSB7XG4gICAgICAgIG1pbklkeCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobWF4SWR4ID09IC0xKSB7XG4gICAgICAgIG1heElkeCA9IFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgdGljayB2YWx1ZXMgd291bGQgYXBwZWFyLCBpZiB3ZSBjYW4gZ2V0IGF0IGxlYXN0XG4gICAgICAvLyBuVGlja3MgLyA0IGFjY2VwdCB0aGVtLlxuICAgICAgdmFyIGxhc3REaXNwbGF5ZWQgPSBudWxsO1xuICAgICAgaWYgKG1heElkeCAtIG1pbklkeCA+PSBuVGlja3MgLyA0KSB7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IG1heElkeDsgaWR4ID49IG1pbklkeDsgaWR4LS0pIHtcbiAgICAgICAgICB2YXIgdGlja1ZhbHVlID0gUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFU1tpZHhdO1xuICAgICAgICAgIHZhciBwaXhlbF9jb29yZCA9IE1hdGgubG9nKHRpY2tWYWx1ZSAvIGEpIC8gTWF0aC5sb2coYiAvIGEpICogcGl4ZWxzO1xuICAgICAgICAgIHZhciB0aWNrID0geyB2OiB0aWNrVmFsdWUgfTtcbiAgICAgICAgICBpZiAobGFzdERpc3BsYXllZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdERpc3BsYXllZCA9IHtcbiAgICAgICAgICAgICAgdGlja1ZhbHVlIDogdGlja1ZhbHVlLFxuICAgICAgICAgICAgICBwaXhlbF9jb29yZCA6IHBpeGVsX2Nvb3JkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocGl4ZWxfY29vcmQgLSBsYXN0RGlzcGxheWVkLnBpeGVsX2Nvb3JkKSA+PSBwaXhlbHNfcGVyX3RpY2spIHtcbiAgICAgICAgICAgICAgbGFzdERpc3BsYXllZCA9IHtcbiAgICAgICAgICAgICAgICB0aWNrVmFsdWUgOiB0aWNrVmFsdWUsXG4gICAgICAgICAgICAgICAgcGl4ZWxfY29vcmQgOiBwaXhlbF9jb29yZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGljay5sYWJlbCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRpY2tzLnB1c2godGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2Ugd2VudCBpbiBiYWNrd2FyZHMgb3JkZXIuXG4gICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aWNrcy5sZW5ndGggd29uJ3QgYmUgMCBpZiB0aGUgbG9nIHNjYWxlIGZ1bmN0aW9uIGZpbmRzIHZhbHVlcyB0byBpbnNlcnQuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQmFzaWMgaWRlYTpcbiAgICAgIC8vIFRyeSBsYWJlbHMgZXZlcnkgMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwLCBldGMuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlc3VsdGluZyB0aWNrIHNwYWNpbmcgKGkuZS4gdGhpcy5oZWlnaHRfIC8gblRpY2tzKS5cbiAgICAgIC8vIFRoZSBmaXJzdCBzcGFjaW5nIGdyZWF0ZXIgdGhhbiBwaXhlbHNQZXJZTGFiZWwgaXMgd2hhdCB3ZSB1c2UuXG4gICAgICAvLyBUT0RPKGRhbnZrKTogdmVyc2lvbiB0aGF0IHdvcmtzIG9uIGEgbG9nIHNjYWxlLlxuICAgICAgdmFyIGttZzIgPSBvcHRzKFwibGFiZWxzS01HMlwiKTtcbiAgICAgIHZhciBtdWx0cywgYmFzZTtcbiAgICAgIGlmIChrbWcyKSB7XG4gICAgICAgIG11bHRzID0gWzEsIDIsIDQsIDgsIDE2LCAzMiwgNjQsIDEyOCwgMjU2XTtcbiAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdHMgPSBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwXTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHBlcm1pdHRlZCB0aWNrcyBiYXNlZCBvbiB0aGVcbiAgICAgIC8vIGdyYXBoJ3MgcGl4ZWwgc2l6ZSBhbmQgcGl4ZWxzX3Blcl90aWNrIHNldHRpbmcuXG4gICAgICB2YXIgbWF4X3RpY2tzID0gTWF0aC5jZWlsKHBpeGVscyAvIHBpeGVsc19wZXJfdGljayk7XG5cbiAgICAgIC8vIE5vdyBjYWxjdWxhdGUgdGhlIGRhdGEgdW5pdCBlcXVpdmFsZW50IG9mIHRoaXMgdGljayBzcGFjaW5nLlxuICAgICAgLy8gVXNlIGFicygpIHNpbmNlIGdyYXBocyBtYXkgaGF2ZSBhIHJldmVyc2VkIFkgYXhpcy5cbiAgICAgIHZhciB1bml0c19wZXJfdGljayA9IE1hdGguYWJzKGIgLSBhKSAvIG1heF90aWNrcztcblxuICAgICAgLy8gQmFzZWQgb24gdGhpcywgZ2V0IGEgc3RhcnRpbmcgc2NhbGUgd2hpY2ggaXMgdGhlIGxhcmdlc3RcbiAgICAgIC8vIGludGVnZXIgcG93ZXIgb2YgdGhlIGNob3NlbiBiYXNlICgxMCBvciAxNikgdGhhdCBzdGlsbCByZW1haW5zXG4gICAgICAvLyBiZWxvdyB0aGUgcmVxdWVzdGVkIHBpeGVsc19wZXJfdGljayBzcGFjaW5nLlxuICAgICAgdmFyIGJhc2VfcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHVuaXRzX3Blcl90aWNrKSAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBiYXNlX3NjYWxlID0gTWF0aC5wb3coYmFzZSwgYmFzZV9wb3dlcik7XG5cbiAgICAgIC8vIE5vdyB0cnkgbXVsdGlwbGVzIG9mIHRoZSBzdGFydGluZyBzY2FsZSB1bnRpbCB3ZSBmaW5kIG9uZVxuICAgICAgLy8gdGhhdCByZXN1bHRzIGluIHRpY2sgbWFya3Mgc3BhY2VkIHN1ZmZpY2llbnRseSBmYXIgYXBhcnQuXG4gICAgICAvLyBUaGUgXCJtdWx0c1wiIGFycmF5IHNob3VsZCBjb3ZlciB0aGUgcmFuZ2UgMSAuLiBiYXNlXjIgdG9cbiAgICAgIC8vIGFkanVzdCBmb3Igcm91bmRpbmcgYW5kIGVkZ2UgZWZmZWN0cy5cbiAgICAgIHZhciBzY2FsZSwgbG93X3ZhbCwgaGlnaF92YWwsIHNwYWNpbmc7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbXVsdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2NhbGUgPSBiYXNlX3NjYWxlICogbXVsdHNbal07XG4gICAgICAgIGxvd192YWwgPSBNYXRoLmZsb29yKGEgLyBzY2FsZSkgKiBzY2FsZTtcbiAgICAgICAgaGlnaF92YWwgPSBNYXRoLmNlaWwoYiAvIHNjYWxlKSAqIHNjYWxlO1xuICAgICAgICBuVGlja3MgPSBNYXRoLmFicyhoaWdoX3ZhbCAtIGxvd192YWwpIC8gc2NhbGU7XG4gICAgICAgIHNwYWNpbmcgPSBwaXhlbHMgLyBuVGlja3M7XG4gICAgICAgIGlmIChzcGFjaW5nID4gcGl4ZWxzX3Blcl90aWNrKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc3RydWN0IHRoZSBzZXQgb2YgdGlja3MuXG4gICAgICAvLyBBbGxvdyByZXZlcnNlIHktYXhpcyBpZiBpdCdzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAgICAgaWYgKGxvd192YWwgPiBoaWdoX3ZhbCkgc2NhbGUgKj0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IG5UaWNrczsgaSsrKSB7XG4gICAgICAgIHRpY2tWID0gbG93X3ZhbCArIGkgKiBzY2FsZTtcbiAgICAgICAgdGlja3MucHVzaCgge3Y6IHRpY2tWfSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtYXR0ZXIgPSAvKipAdHlwZXtBeGlzTGFiZWxGb3JtYXR0ZXJ9Ki8ob3B0cygnYXhpc0xhYmVsRm9ybWF0dGVyJykpO1xuXG4gIC8vIEFkZCBsYWJlbHMgdG8gdGhlIHRpY2tzLlxuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubGFiZWwgIT09IHVuZGVmaW5lZCkgY29udGludWU7ICAvLyBVc2UgY3VycmVudCBsYWJlbC5cbiAgICAvLyBUT0RPKGRhbnZrKTogc2V0IGdyYW51bGFyaXR5IHRvIHNvbWV0aGluZyBhcHByb3ByaWF0ZSBoZXJlLlxuICAgIHRpY2tzW2ldLmxhYmVsID0gZm9ybWF0dGVyLmNhbGwoZHlncmFwaCwgdGlja3NbaV0udiwgMCwgb3B0cywgZHlncmFwaCk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59O1xuXG5cbi8qKiBAdHlwZSB7VGlja2VyfSAqL1xuZXhwb3J0IHZhciBkYXRlVGlja2VyID0gZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRzLCBkeWdyYXBoLCB2YWxzKSB7XG4gIHZhciBjaG9zZW4gPSBwaWNrRGF0ZVRpY2tHcmFudWxhcml0eShhLCBiLCBwaXhlbHMsIG9wdHMpO1xuXG4gIGlmIChjaG9zZW4gPj0gMCkge1xuICAgIHJldHVybiBnZXREYXRlQXhpcyhhLCBiLCBjaG9zZW4sIG9wdHMsIGR5Z3JhcGgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiBzZWxmLndpZHRoXyBpcyB6ZXJvLlxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLy8gVGltZSBncmFudWxhcml0eSBlbnVtZXJhdGlvblxuZXhwb3J0IHZhciBHcmFudWxhcml0eSA9IHtcbiAgTUlMTElTRUNPTkRMWTogMCxcbiAgVFdPX01JTExJU0VDT05ETFk6IDEsXG4gIEZJVkVfTUlMTElTRUNPTkRMWTogMixcbiAgVEVOX01JTExJU0VDT05ETFk6IDMsXG4gIEZJRlRZX01JTExJU0VDT05ETFk6IDQsXG4gIEhVTkRSRURfTUlMTElTRUNPTkRMWTogNSxcbiAgRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFk6IDYsXG4gIFNFQ09ORExZOiA3LFxuICBUV09fU0VDT05ETFk6IDgsXG4gIEZJVkVfU0VDT05ETFk6IDksXG4gIFRFTl9TRUNPTkRMWTogMTAsXG4gIFRISVJUWV9TRUNPTkRMWTogMTEsXG4gIE1JTlVURUxZOiAxMixcbiAgVFdPX01JTlVURUxZOiAxMyxcbiAgRklWRV9NSU5VVEVMWTogMTQsXG4gIFRFTl9NSU5VVEVMWTogMTUsXG4gIFRISVJUWV9NSU5VVEVMWTogMTYsXG4gIEhPVVJMWTogMTcsXG4gIFRXT19IT1VSTFk6IDE4LFxuICBTSVhfSE9VUkxZOiAxOSxcbiAgREFJTFk6IDIwLFxuICBUV09fREFJTFk6IDIxLFxuICBXRUVLTFk6IDIyLFxuICBNT05USExZOiAyMyxcbiAgUVVBUlRFUkxZOiAyNCxcbiAgQklBTk5VQUw6IDI1LFxuICBBTk5VQUw6IDI2LFxuICBERUNBREFMOiAyNyxcbiAgQ0VOVEVOTklBTDogMjgsXG4gIE5VTV9HUkFOVUxBUklUSUVTOiAyOVxufVxuXG4vLyBEYXRlIGNvbXBvbmVudHMgZW51bWVyYXRpb24gKGluIHRoZSBvcmRlciBvZiB0aGUgYXJndW1lbnRzIGluIERhdGUpXG4vLyBUT0RPOiBtYWtlIHRoaXMgYW4gQGVudW1cbnZhciBEYXRlRmllbGQgPSB7XG4gIERBVEVGSUVMRF9ZOiAwLFxuICBEQVRFRklFTERfTTogMSxcbiAgREFURUZJRUxEX0Q6IDIsXG4gIERBVEVGSUVMRF9ISDogMyxcbiAgREFURUZJRUxEX01NOiA0LFxuICBEQVRFRklFTERfU1M6IDUsXG4gIERBVEVGSUVMRF9NUzogNixcbiAgTlVNX0RBVEVGSUVMRFM6IDdcbn07XG5cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgZGF0ZWZpZWxkIHdpbGwgc3RhcnQgYXQgYW4gZXZlbiBtdWx0aXBsZSBvZiBcInN0ZXBcIiwgaS5lLlxuICogICBpZiBkYXRlZmllbGQ9U1MgYW5kIHN0ZXA9NSB0aGVuIHRoZSBmaXJzdCB0aWNrIHdpbGwgYmUgb24gYSBtdWx0aXBsZSBvZiA1cy5cbiAqXG4gKiBGb3IgZ3JhbnVsYXJpdGllcyA8PSBIT1VSTFksIHRpY2tzIGFyZSBnZW5lcmF0ZWQgZXZlcnkgYHNwYWNpbmdgIG1zLlxuICpcbiAqIEF0IGNvYXJzZXIgZ3JhbnVsYXJpdGllcywgdGlja3MgYXJlIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgYGRhdGVmaWVsZGAgYnlcbiAqICAgYHN0ZXBgLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3BhY2luZ2AgdmFsdWUgaXMgb25seSB1c2VkIHRvIGVzdGltYXRlIHRoZVxuICogICBudW1iZXIgb2YgdGlja3MuIEl0IHNob3VsZCByb3VnaGx5IGNvcnJlc3BvbmQgdG8gdGhlIHNwYWNpbmcgYmV0d2VlblxuICogICBhZGphY2VudCB0aWNrcy5cbiAqXG4gKiBAdHlwZSB7QXJyYXkuPHtkYXRlZmllbGQ6bnVtYmVyLCBzdGVwOm51bWJlciwgc3BhY2luZzpudW1iZXJ9Pn1cbiAqL1xudmFyIFRJQ0tfUExBQ0VNRU5UID0gW107XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5NSUxMSVNFQ09ORExZXSAgICAgICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogICAxLCBzcGFjaW5nOiAxfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19NSUxMSVNFQ09ORExZXSAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01TLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9NSUxMSVNFQ09ORExZXSAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTVMsIHN0ZXA6ICAgNSwgc3BhY2luZzogNX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5URU5fTUlMTElTRUNPTkRMWV0gICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogIDEwLCBzcGFjaW5nOiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSUZUWV9NSUxMSVNFQ09ORExZXSAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogIDUwLCBzcGFjaW5nOiA1MH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5IVU5EUkVEX01JTExJU0VDT05ETFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NUywgc3RlcDogMTAwLCBzcGFjaW5nOiAxMDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9IVU5EUkVEX01JTExJU0VDT05ETFldICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTVMsIHN0ZXA6IDUwMCwgc3BhY2luZzogNTAwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlNFQ09ORExZXSAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiAxfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19TRUNPTkRMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkZJVkVfU0VDT05ETFldICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgIDUsIHNwYWNpbmc6IDEwMDAgKiA1fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRFTl9TRUNPTkRMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1NTLCBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwMDAgKiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5USElSVFlfU0VDT05ETFldID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogIDMwLCBzcGFjaW5nOiAxMDAwICogMzB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuTUlOVVRFTFldICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDYwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlRXT19NSU5VVEVMWV0gICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgIDIsIHNwYWNpbmc6IDEwMDAgKiA2MCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuRklWRV9NSU5VVEVMWV0gICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAgNSwgc3BhY2luZzogMTAwMCAqIDYwICogNX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5URU5fTUlOVVRFTFldICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogIDEwLCBzcGFjaW5nOiAxMDAwICogNjAgKiAxMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5USElSVFlfTUlOVVRFTFldID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogIDMwLCBzcGFjaW5nOiAxMDAwICogNjAgKiAzMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5IT1VSTFldICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISCwgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogMzYwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fSE9VUkxZXSAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISCwgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogMzYwMCAqIDJ9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuU0lYX0hPVVJMWV0gICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfSEgsIHN0ZXA6ICAgNiwgc3BhY2luZzogMTAwMCAqIDM2MDAgKiA2fTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkRBSUxZXSAgICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0QsICBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fREFJTFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ELCAgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogODY0MDAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LldFRUtMWV0gICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0QsICBzdGVwOiAgIDcsIHNwYWNpbmc6IDEwMDAgKiA2MDQ4MDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuTU9OVEhMWV0gICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTSwgIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDcyMDAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAvIDEyXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5RVUFSVEVSTFldICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NLCAgc3RlcDogICAzLCBzcGFjaW5nOiAxMDAwICogMjE2MDAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0IC8gNFxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuQklBTk5VQUxdICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTSwgIHN0ZXA6ICAgNiwgc3BhY2luZzogMTAwMCAqIDQzMjAwICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAvIDJcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkFOTlVBTF0gICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1ksICBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMCAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAqIDFcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkRFQ0FEQUxdICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX1ksICBzdGVwOiAgMTAsIHNwYWNpbmc6IDEwMDAgKiA4NjQwMDAgICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAqIDEwXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5DRU5URU5OSUFMXSAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZLCAgc3RlcDogMTAwLCBzcGFjaW5nOiAxMDAwICogODY0MDAwMCAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgKiAxMDBcblxuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGh1bWFuLWZyaWVuZGx5IHZhbHVlcyBhdCB3aGljaCB0byBzaG93IHRpY2sgbWFya3Mgb24gYSBsb2dcbiAqIHNjYWxlLiBJdCBpcyBrICogMTBebiwgd2hlcmUgaz0xLi45IGFuZCBuPS0zOS4uKzM5LCBzbzpcbiAqIC4uLiwgMSwgMiwgMywgNCwgNSwgLi4uLCA5LCAxMCwgMjAsIDMwLCAuLi4sIDkwLCAxMDAsIDIwMCwgMzAwLCAuLi5cbiAqIE5PVEU6IHRoaXMgYXNzdW1lcyB0aGF0IHV0aWxzLkxPR19TQ0FMRSA9IDEwLlxuICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICovXG52YXIgUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIgcG93ZXIgPSAtMzk7IHBvd2VyIDw9IDM5OyBwb3dlcisrKSB7XG4gICAgdmFyIHJhbmdlID0gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgICBmb3IgKHZhciBtdWx0ID0gMTsgbXVsdCA8PSA5OyBtdWx0KyspIHtcbiAgICAgIHZhciB2YWwgPSByYW5nZSAqIG11bHQ7XG4gICAgICB2YWxzLnB1c2godmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29ycmVjdCBncmFudWxhcml0eSBvZiB0aWNrcyBvbiBhIGRhdGUgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBMZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0IChtcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0IChtcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbHMgU2l6ZSBvZiB0aGUgY2hhcnQgaW4gdGhlIHJlbGV2YW50IGRpbWVuc2lvbiAod2lkdGgpLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOip9IG9wdHMgRnVuY3Rpb24gbWFwcGluZyBmcm9tIG9wdGlvbiBuYW1lIC0mZ3Q7IHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXBwcm9wcmlhdGUgYXhpcyBncmFudWxhcml0eSBmb3IgdGhpcyBjaGFydC4gU2VlIHRoZVxuICogICAgIGVudW1lcmF0aW9uIG9mIHBvc3NpYmxlIHZhbHVlcyBpbiBkeWdyYXBoLXRpY2tlcnMuanMuXG4gKi9cbnZhciBwaWNrRGF0ZVRpY2tHcmFudWxhcml0eSA9IGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0cykge1xuICB2YXIgcGl4ZWxzX3Blcl90aWNrID0gLyoqIEB0eXBle251bWJlcn0gKi8ob3B0cygncGl4ZWxzUGVyTGFiZWwnKSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgR3JhbnVsYXJpdHkuTlVNX0dSQU5VTEFSSVRJRVM7IGkrKykge1xuICAgIHZhciBudW1fdGlja3MgPSBudW1EYXRlVGlja3MoYSwgYiwgaSk7XG4gICAgaWYgKHBpeGVscyAvIG51bV90aWNrcyA+PSBwaXhlbHNfcGVyX3RpY2spIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG51bWJlciBvZiB0aWNrcyBvbiBhIGRhdGUgYXhpcyBmb3IgYSBnaXZlbiBncmFudWxhcml0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydF90aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kX3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmFudWxhcml0eSAob25lIG9mIHRoZSBncmFudWxhcml0aWVzIGVudW1lcmF0ZWQgYWJvdmUpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IChBcHByb3hpbWF0ZSkgbnVtYmVyIG9mIHRpY2tzIHRoYXQgd291bGQgcmVzdWx0LlxuICovXG52YXIgbnVtRGF0ZVRpY2tzID0gZnVuY3Rpb24oc3RhcnRfdGltZSwgZW5kX3RpbWUsIGdyYW51bGFyaXR5KSB7XG4gIHZhciBzcGFjaW5nID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnNwYWNpbmc7XG4gIHJldHVybiBNYXRoLnJvdW5kKDEuMCAqIChlbmRfdGltZSAtIHN0YXJ0X3RpbWUpIC8gc3BhY2luZyk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBvc2l0aW9ucyBhbmQgbGFiZWxzIG9mIHRpY2tzIG9uIGEgZGF0ZSBheGlzIGZvciBhIGdpdmVuIGdyYW51bGFyaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IGdyYW51bGFyaXR5IChvbmUgb2YgdGhlIGdyYW51bGFyaXRpZXMgZW51bWVyYXRlZCBhYm92ZSlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKToqfSBvcHRzIEZ1bmN0aW9uIG1hcHBpbmcgZnJvbSBvcHRpb24gbmFtZSAtJmd0OyB2YWx1ZS5cbiAqIEBwYXJhbSB7RHlncmFwaD19IGRnXG4gKiBAcmV0dXJuIHshVGlja0xpc3R9XG4gKi9cbmV4cG9ydCB2YXIgZ2V0RGF0ZUF4aXMgPSBmdW5jdGlvbihzdGFydF90aW1lLCBlbmRfdGltZSwgZ3JhbnVsYXJpdHksIG9wdHMsIGRnKSB7XG4gIHZhciBmb3JtYXR0ZXIgPSAvKiogQHR5cGV7QXhpc0xhYmVsRm9ybWF0dGVyfSAqLyhcbiAgICAgIG9wdHMoXCJheGlzTGFiZWxGb3JtYXR0ZXJcIikpO1xuICB2YXIgdXRjID0gb3B0cyhcImxhYmVsc1VUQ1wiKTtcbiAgdmFyIGFjY2Vzc29ycyA9IHV0YyA/IHV0aWxzLkRhdGVBY2Nlc3NvcnNVVEMgOiB1dGlscy5EYXRlQWNjZXNzb3JzTG9jYWw7XG5cbiAgdmFyIGRhdGVmaWVsZCA9IFRJQ0tfUExBQ0VNRU5UW2dyYW51bGFyaXR5XS5kYXRlZmllbGQ7XG4gIHZhciBzdGVwID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnN0ZXA7XG4gIHZhciBzcGFjaW5nID0gVElDS19QTEFDRU1FTlRbZ3JhbnVsYXJpdHldLnNwYWNpbmc7XG5cbiAgLy8gQ2hvb3NlIGEgbmljZSB0aWNrIHBvc2l0aW9uIGJlZm9yZSB0aGUgaW5pdGlhbCBpbnN0YW50LlxuICAvLyBDdXJyZW50bHksIHRoaXMgY29kZSBkZWFscyBwcm9wZXJseSB3aXRoIHRoZSBleGlzdGVudCBkYWlseSBncmFudWxhcml0aWVzOlxuICAvLyBEQUlMWSAod2l0aCBzdGVwIG9mIDEpIGFuZCBXRUVLTFkgKHdpdGggc3RlcCBvZiA3IGJ1dCBzcGVjaWFsbHkgaGFuZGxlZCkuXG4gIC8vIE90aGVyIGRhaWx5IGdyYW51bGFyaXRpZXMgKHNheSBUV09fREFJTFkpIHNob3VsZCBhbHNvIGJlIGhhbmRsZWQgc3BlY2lhbGx5XG4gIC8vIGJ5IHNldHRpbmcgdGhlIHN0YXJ0X2RhdGVfb2Zmc2V0IHRvIDAuXG4gIHZhciBzdGFydF9kYXRlID0gbmV3IERhdGUoc3RhcnRfdGltZSk7XG4gIHZhciBkYXRlX2FycmF5ID0gW107XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZXSAgPSBhY2Nlc3NvcnMuZ2V0RnVsbFllYXIoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9NXSAgPSBhY2Nlc3NvcnMuZ2V0TW9udGgoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9EXSAgPSBhY2Nlc3NvcnMuZ2V0RGF0ZShzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX0hIXSA9IGFjY2Vzc29ycy5nZXRIb3VycyhzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX01NXSA9IGFjY2Vzc29ycy5nZXRNaW51dGVzKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfU1NdID0gYWNjZXNzb3JzLmdldFNlY29uZHMoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9NU10gPSBhY2Nlc3NvcnMuZ2V0TWlsbGlzZWNvbmRzKHN0YXJ0X2RhdGUpO1xuXG4gIHZhciBzdGFydF9kYXRlX29mZnNldCA9IGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSAlIHN0ZXA7XG4gIGlmIChncmFudWxhcml0eSA9PSBHcmFudWxhcml0eS5XRUVLTFkpIHtcbiAgICAvLyBUaGlzIHdpbGwgcHV0IHRoZSB0aWNrcyBvbiBTdW5kYXlzLlxuICAgIHN0YXJ0X2RhdGVfb2Zmc2V0ID0gYWNjZXNzb3JzLmdldERheShzdGFydF9kYXRlKTtcbiAgfVxuICBcbiAgZGF0ZV9hcnJheVtkYXRlZmllbGRdIC09IHN0YXJ0X2RhdGVfb2Zmc2V0O1xuICBmb3IgKHZhciBkZiA9IGRhdGVmaWVsZCArIDE7IGRmIDwgRGF0ZUZpZWxkLk5VTV9EQVRFRklFTERTOyBkZisrKSB7XG4gICAgLy8gVGhlIG1pbmltdW0gdmFsdWUgaXMgMSBmb3IgdGhlIGRheSBvZiBtb250aCwgYW5kIDAgZm9yIGFsbCBvdGhlciBmaWVsZHMuXG4gICAgZGF0ZV9hcnJheVtkZl0gPSAoZGYgPT09IERhdGVGaWVsZC5EQVRFRklFTERfRCkgPyAxIDogMDtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSB0aWNrcy5cbiAgLy8gRm9yIGdyYW51bGFyaXRpZXMgbm90IGNvYXJzZXIgdGhhbiBIT1VSTFkgd2UgdXNlIHRoZSBmYWN0IHRoYXQ6XG4gIC8vICAgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYmV0d2VlbiB0aWNrcyBpcyBjb25zdGFudFxuICAvLyAgIGFuZCBlcXVhbCB0byB0aGUgZGVmaW5lZCBzcGFjaW5nLlxuICAvLyBPdGhlcndpc2Ugd2UgcmVseSBvbiB0aGUgJ3JvbGwgb3ZlcicgcHJvcGVydHkgb2YgdGhlIERhdGUgZnVuY3Rpb25zOlxuICAvLyAgIHdoZW4gc29tZSBkYXRlIGZpZWxkIGlzIHNldCB0byBhIHZhbHVlIG91dHNpZGUgb2YgaXRzIGxvZ2ljYWwgcmFuZ2UsXG4gIC8vICAgdGhlIGV4Y2VzcyAncm9sbHMgb3ZlcicgdGhlIG5leHQgKG1vcmUgc2lnbmlmaWNhbnQpIGZpZWxkLlxuICAvLyBIb3dldmVyLCB3aGVuIHVzaW5nIGxvY2FsIHRpbWUgd2l0aCBEU1QgdHJhbnNpdGlvbnMsXG4gIC8vIHRoZXJlIGFyZSBkYXRlcyB0aGF0IGRvIG5vdCByZXByZXNlbnQgYW55IHRpbWUgdmFsdWUgYXQgYWxsXG4gIC8vICh0aG9zZSBpbiB0aGUgaG91ciBza2lwcGVkIGF0IHRoZSAnc3ByaW5nIGZvcndhcmQnKSxcbiAgLy8gYW5kIHRoZSBKYXZhU2NyaXB0IGVuZ2luZXMgdXN1YWxseSByZXR1cm4gYW4gZXF1aXZhbGVudCB2YWx1ZS5cbiAgLy8gSGVuY2Ugd2UgaGF2ZSB0byBjaGVjayB0aGF0IHRoZSBkYXRlIGlzIHByb3Blcmx5IGluY3JlYXNlZCBhdCBlYWNoIHN0ZXAsXG4gIC8vIHJldHVybmluZyBhIGRhdGUgYXQgYSBuaWNlIHRpY2sgcG9zaXRpb24uXG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgdGlja19kYXRlID0gYWNjZXNzb3JzLm1ha2VEYXRlLmFwcGx5KG51bGwsIGRhdGVfYXJyYXkpO1xuICB2YXIgdGlja190aW1lID0gdGlja19kYXRlLmdldFRpbWUoKTtcbiAgaWYgKGdyYW51bGFyaXR5IDw9IEdyYW51bGFyaXR5LkhPVVJMWSkge1xuICAgIGlmICh0aWNrX3RpbWUgPCBzdGFydF90aW1lKSB7XG4gICAgICB0aWNrX3RpbWUgKz0gc3BhY2luZztcbiAgICAgIHRpY2tfZGF0ZSA9IG5ldyBEYXRlKHRpY2tfdGltZSk7XG4gICAgfVxuICAgIHdoaWxlICh0aWNrX3RpbWUgPD0gZW5kX3RpbWUpIHtcbiAgICAgIHRpY2tzLnB1c2goeyB2OiB0aWNrX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlci5jYWxsKGRnLCB0aWNrX2RhdGUsIGdyYW51bGFyaXR5LCBvcHRzLCBkZylcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICB0aWNrX3RpbWUgKz0gc3BhY2luZztcbiAgICAgIHRpY2tfZGF0ZSA9IG5ldyBEYXRlKHRpY2tfdGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aWNrX3RpbWUgPCBzdGFydF90aW1lKSB7XG4gICAgICBkYXRlX2FycmF5W2RhdGVmaWVsZF0gKz0gc3RlcDtcbiAgICAgIHRpY2tfZGF0ZSA9IGFjY2Vzc29ycy5tYWtlRGF0ZS5hcHBseShudWxsLCBkYXRlX2FycmF5KTtcbiAgICAgIHRpY2tfdGltZSA9IHRpY2tfZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHdoaWxlICh0aWNrX3RpbWUgPD0gZW5kX3RpbWUpIHtcbiAgICAgIGlmIChncmFudWxhcml0eSA+PSBHcmFudWxhcml0eS5EQUlMWSB8fFxuICAgICAgICAgIGFjY2Vzc29ycy5nZXRIb3Vycyh0aWNrX2RhdGUpICUgc3RlcCA9PT0gMCkge1xuICAgICAgICB0aWNrcy5wdXNoKHsgdjogdGlja190aW1lLFxuICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlci5jYWxsKGRnLCB0aWNrX2RhdGUsIGdyYW51bGFyaXR5LCBvcHRzLCBkZylcbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSArPSBzdGVwO1xuICAgICAgdGlja19kYXRlID0gYWNjZXNzb3JzLm1ha2VEYXRlLmFwcGx5KG51bGwsIGRhdGVfYXJyYXkpO1xuICAgICAgdGlja190aW1lID0gdGlja19kYXRlLmdldFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Robert Konigsberg (konigsberg@google.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview The default interaction model for Dygraphs. This is kept out\n * of dygraph.js for better navigability.\n * @author Robert Konigsberg (konigsberg@google.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * You can drag this many pixels past the edge of the chart and still have it\n * be considered a zoom. This makes it easier to zoom to the exact edge of the\n * chart, a fairly common operation.\n */\nvar DRAG_EDGE_MARGIN = 100;\n\n/**\n * A collection of functions to facilitate build custom interaction models.\n * @class\n */\nvar DygraphInteraction = {};\n\n/**\n * Checks whether the beginning & ending of an event were close enough that it\n * should be considered a click. If it should, dispatch appropriate events.\n * Returns true if the event was treated as a click.\n *\n * @param {Event} event\n * @param {Dygraph} g\n * @param {Object} context\n */\nDygraphInteraction.maybeTreatMouseOpAsClick = function(event, g, context) {\n  context.dragEndX = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetX_ */ "t"](event, context);\n  context.dragEndY = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetY_ */ "u"](event, context);\n  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);\n  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);\n\n  if (regionWidth < 2 && regionHeight < 2 &&\n      g.lastx_ !== undefined && g.lastx_ != -1) {\n    DygraphInteraction.treatMouseOpAsClick(g, event, context);\n  }\n\n  context.regionWidth = regionWidth;\n  context.regionHeight = regionHeight;\n};\n\n/**\n * Called in response to an interaction model operation that\n * should start the default panning behavior.\n *\n * It\'s used in the default callback for "mousedown" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the startPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startPan = function(event, g, context) {\n  var i, axis;\n  context.isPanning = true;\n  var xRange = g.xAxisRange();\n\n  if (g.getOptionForAxis("logscale", "x")) {\n    context.initialLeftmostDate = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](xRange[0]);\n    context.dateRange = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](xRange[1]) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](xRange[0]);\n  } else {\n    context.initialLeftmostDate = xRange[0];\n    context.dateRange = xRange[1] - xRange[0];\n  }\n  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);\n\n  if (g.getNumericOption("panEdgeFraction")) {\n    var maxXPixelsToDraw = g.width_ * g.getNumericOption("panEdgeFraction");\n    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!\n\n    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;\n    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;\n\n    var boundedLeftDate = g.toDataXCoord(boundedLeftX);\n    var boundedRightDate = g.toDataXCoord(boundedRightX);\n    context.boundedDates = [boundedLeftDate, boundedRightDate];\n\n    var boundedValues = [];\n    var maxYPixelsToDraw = g.height_ * g.getNumericOption("panEdgeFraction");\n\n    for (i = 0; i < g.axes_.length; i++) {\n      axis = g.axes_[i];\n      var yExtremes = axis.extremeRange;\n\n      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;\n      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;\n\n      var boundedTopValue = g.toDataYCoord(boundedTopY, i);\n      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);\n\n      boundedValues[i] = [boundedTopValue, boundedBottomValue];\n    }\n    context.boundedValues = boundedValues;\n  }\n\n  // Record the range of each y-axis at the start of the drag.\n  // If any axis has a valueRange, then we want a 2D pan.\n  // We can\'t store data directly in g.axes_, because it does not belong to us\n  // and could change out from under us during a pan (say if there\'s a data\n  // update).\n  context.is2DPan = false;\n  context.axes = [];\n  for (i = 0; i < g.axes_.length; i++) {\n    axis = g.axes_[i];\n    var axis_data = {};\n    var yRange = g.yAxisRange(i);\n    // TODO(konigsberg): These values should be in |context|.\n    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.\n    var logscale = g.attributes_.getForAxis("logscale", i);\n    if (logscale) {\n      axis_data.initialTopValue = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](yRange[1]);\n      axis_data.dragValueRange = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](yRange[1]) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ "H"](yRange[0]);\n    } else {\n      axis_data.initialTopValue = yRange[1];\n      axis_data.dragValueRange = yRange[1] - yRange[0];\n    }\n    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);\n    context.axes.push(axis_data);\n\n    // While calculating axes, set 2dpan.\n    if (axis.valueRange) context.is2DPan = true;\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that pans the view.\n *\n * It\'s used in the default callback for "mousemove" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the movePan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.movePan = function(event, g, context) {\n  context.dragEndX = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetX_ */ "t"](event, context);\n  context.dragEndY = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetY_ */ "u"](event, context);\n\n  var minDate = context.initialLeftmostDate -\n    (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;\n  if (context.boundedDates) {\n    minDate = Math.max(minDate, context.boundedDates[0]);\n  }\n  var maxDate = minDate + context.dateRange;\n  if (context.boundedDates) {\n    if (maxDate > context.boundedDates[1]) {\n      // Adjust minDate, and recompute maxDate.\n      minDate = minDate - (maxDate - context.boundedDates[1]);\n      maxDate = minDate + context.dateRange;\n    }\n  }\n\n  if (g.getOptionForAxis("logscale", "x")) {\n    g.dateWindow_ = [ Math.pow(_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* LOG_SCALE */ "g"], minDate),\n                      Math.pow(_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* LOG_SCALE */ "g"], maxDate) ];\n  } else {\n    g.dateWindow_ = [minDate, maxDate];\n  }\n\n  // y-axis scaling is automatic unless this is a full 2D pan.\n  if (context.is2DPan) {\n\n    var pixelsDragged = context.dragEndY - context.dragStartY;\n\n    // Adjust each axis appropriately.\n    for (var i = 0; i < g.axes_.length; i++) {\n      var axis = g.axes_[i];\n      var axis_data = context.axes[i];\n      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;\n\n      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;\n\n      // In log scale, maxValue and minValue are the logs of those values.\n      var maxValue = axis_data.initialTopValue + unitsDragged;\n      if (boundedValue) {\n        maxValue = Math.min(maxValue, boundedValue[1]);\n      }\n      var minValue = maxValue - axis_data.dragValueRange;\n      if (boundedValue) {\n        if (minValue < boundedValue[0]) {\n          // Adjust maxValue, and recompute minValue.\n          maxValue = maxValue - (minValue - boundedValue[0]);\n          minValue = maxValue - axis_data.dragValueRange;\n        }\n      }\n      if (g.attributes_.getForAxis("logscale", i)) {\n        axis.valueRange = [ Math.pow(_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* LOG_SCALE */ "g"], minValue),\n                            Math.pow(_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* LOG_SCALE */ "g"], maxValue) ];\n      } else {\n        axis.valueRange = [ minValue, maxValue ];\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that ends panning.\n *\n * It\'s used in the default callback for "mouseup" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the endPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that starts zooming.\n *\n * It\'s used in the default callback for "mousedown" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the startZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.startZoom = function(event, g, context) {\n  context.isZooming = true;\n  context.zoomMoved = false;\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that defines zoom boundaries.\n *\n * It\'s used in the default callback for "mousemove" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the moveZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.moveZoom = function(event, g, context) {\n  context.zoomMoved = true;\n  context.dragEndX = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetX_ */ "t"](event, context);\n  context.dragEndY = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* dragGetY_ */ "u"](event, context);\n\n  var xDelta = Math.abs(context.dragStartX - context.dragEndX);\n  var yDelta = Math.abs(context.dragStartY - context.dragEndY);\n\n  // drag direction threshold for y axis is twice as large as x axis\n  context.dragDirection = (xDelta < yDelta / 2) ? _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* VERTICAL */ "h"] : _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* HORIZONTAL */ "f"];\n\n  g.drawZoomRect_(\n      context.dragDirection,\n      context.dragStartX,\n      context.dragEndX,\n      context.dragStartY,\n      context.dragEndY,\n      context.prevDragDirection,\n      context.prevEndX,\n      context.prevEndY);\n\n  context.prevEndX = context.dragEndX;\n  context.prevEndY = context.dragEndY;\n  context.prevDragDirection = context.dragDirection;\n};\n\n/**\n * TODO(danvk): move this logic into dygraph.js\n * @param {Dygraph} g\n * @param {Event} event\n * @param {Object} context\n */\nDygraphInteraction.treatMouseOpAsClick = function(g, event, context) {\n  var clickCallback = g.getFunctionOption(\'clickCallback\');\n  var pointClickCallback = g.getFunctionOption(\'pointClickCallback\');\n\n  var selectedPoint = null;\n\n  // Find out if the click occurs on a point.\n  var closestIdx = -1;\n  var closestDistance = Number.MAX_VALUE;\n\n  // check if the click was on a particular point.\n  for (var i = 0; i < g.selPoints_.length; i++) {\n    var p = g.selPoints_[i];\n    var distance = Math.pow(p.canvasx - context.dragEndX, 2) +\n                   Math.pow(p.canvasy - context.dragEndY, 2);\n    if (!isNaN(distance) &&\n        (closestIdx == -1 || distance < closestDistance)) {\n      closestDistance = distance;\n      closestIdx = i;\n    }\n  }\n\n  // Allow any click within two pixels of the dot.\n  var radius = g.getNumericOption(\'highlightCircleSize\') + 2;\n  if (closestDistance <= radius * radius) {\n    selectedPoint = g.selPoints_[closestIdx];\n  }\n\n  if (selectedPoint) {\n    var e = {\n      cancelable: true,\n      point: selectedPoint,\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY\n    };\n    var defaultPrevented = g.cascadeEvents_(\'pointClick\', e);\n    if (defaultPrevented) {\n      // Note: this also prevents click / clickCallback from firing.\n      return;\n    }\n    if (pointClickCallback) {\n      pointClickCallback.call(g, event, selectedPoint);\n    }\n  }\n\n  var e = {\n    cancelable: true,\n    xval: g.lastx_,  // closest point by x value\n    pts: g.selPoints_,\n    canvasx: context.dragEndX,\n    canvasy: context.dragEndY\n  };\n  if (!g.cascadeEvents_(\'click\', e)) {\n    if (clickCallback) {\n      // TODO(danvk): pass along more info about the points, e.g. \'x\'\n      clickCallback.call(g, event, g.lastx_, g.selPoints_);\n    }\n  }\n};\n\n/**\n * Called in response to an interaction model operation that\n * responds to an event that performs a zoom based on previously defined\n * bounds..\n *\n * It\'s used in the default callback for "mouseup" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the endZoom call.\n * @param {Dygraph} g The dygraph on which to end the zoom.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\nDygraphInteraction.endZoom = function(event, g, context) {\n  g.clearZoomRect_();\n  context.isZooming = false;\n  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n\n  // The zoom rectangle is visibly clipped to the plot area, so its behavior\n  // should be as well.\n  // See http://code.google.com/p/dygraphs/issues/detail?id=280\n  var plotArea = g.getArea();\n  if (context.regionWidth >= 10 &&\n      context.dragDirection == _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* HORIZONTAL */ "f"]) {\n    var left = Math.min(context.dragStartX, context.dragEndX),\n        right = Math.max(context.dragStartX, context.dragEndX);\n    left = Math.max(left, plotArea.x);\n    right = Math.min(right, plotArea.x + plotArea.w);\n    if (left < right) {\n      g.doZoomX_(left, right);\n    }\n    context.cancelNextDblclick = true;\n  } else if (context.regionHeight >= 10 &&\n             context.dragDirection == _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* VERTICAL */ "h"]) {\n    var top = Math.min(context.dragStartY, context.dragEndY),\n        bottom = Math.max(context.dragStartY, context.dragEndY);\n    top = Math.max(top, plotArea.y);\n    bottom = Math.min(bottom, plotArea.y + plotArea.h);\n    if (top < bottom) {\n      g.doZoomY_(top, bottom);\n    }\n    context.cancelNextDblclick = true;\n  }\n  context.dragStartX = null;\n  context.dragStartY = null;\n};\n\n/**\n * @private\n */\nDygraphInteraction.startTouch = function(event, g, context) {\n  event.preventDefault();  // touch browsers are all nice.\n  if (event.touches.length > 1) {\n    // If the user ever puts two fingers down, it\'s not a double tap.\n    context.startTimeForDoubleTapMs = null;\n  }\n\n  var touches = [];\n  for (var i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    // we dispense with \'dragGetX_\' because all touchBrowsers support pageX\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY,\n      dataX: g.toDataXCoord(t.pageX),\n      dataY: g.toDataYCoord(t.pageY)\n      // identifier: t.identifier\n    });\n  }\n  context.initialTouches = touches;\n\n  if (touches.length == 1) {\n    // This is just a swipe.\n    context.initialPinchCenter = touches[0];\n    context.touchDirections = { x: true, y: true };\n  } else if (touches.length >= 2) {\n    // It\'s become a pinch!\n    // In case there are 3+ touches, we ignore all but the "first" two.\n\n    // only screen coordinates can be averaged (data coords could be log scale).\n    context.initialPinchCenter = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),\n\n      // TODO(danvk): remove\n      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),\n      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)\n    };\n\n    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.\n    var initialAngle = 180 / Math.PI * Math.atan2(\n        context.initialPinchCenter.pageY - touches[0].pageY,\n        touches[0].pageX - context.initialPinchCenter.pageX);\n\n    // use symmetry to get it into the first quadrant.\n    initialAngle = Math.abs(initialAngle);\n    if (initialAngle > 90) initialAngle = 90 - initialAngle;\n\n    context.touchDirections = {\n      x: (initialAngle < (90 - 45/2)),\n      y: (initialAngle > 45/2)\n    };\n  }\n\n  // save the full x & y ranges.\n  context.initialRange = {\n    x: g.xAxisRange(),\n    y: g.yAxisRange()\n  };\n};\n\n/**\n * @private\n */\nDygraphInteraction.moveTouch = function(event, g, context) {\n  // If the tap moves, then it\'s definitely not part of a double-tap.\n  context.startTimeForDoubleTapMs = null;\n\n  var i, touches = [];\n  for (i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY\n    });\n  }\n  var initialTouches = context.initialTouches;\n\n  var c_now;\n\n  // old and new centers.\n  var c_init = context.initialPinchCenter;\n  if (touches.length == 1) {\n    c_now = touches[0];\n  } else {\n    c_now = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)\n    };\n  }\n\n  // this is the "swipe" component\n  // we toss it out for now, but could use it in the future.\n  var swipe = {\n    pageX: c_now.pageX - c_init.pageX,\n    pageY: c_now.pageY - c_init.pageY\n  };\n  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];\n  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];\n  swipe.dataX = (swipe.pageX / g.plotter_.area.w) * dataWidth;\n  swipe.dataY = (swipe.pageY / g.plotter_.area.h) * dataHeight;\n  var xScale, yScale;\n\n  // The residual bits are usually split into scale & rotate bits, but we split\n  // them into x-scale and y-scale bits.\n  if (touches.length == 1) {\n    xScale = 1.0;\n    yScale = 1.0;\n  } else if (touches.length >= 2) {\n    var initHalfWidth = (initialTouches[1].pageX - c_init.pageX);\n    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;\n\n    var initHalfHeight = (initialTouches[1].pageY - c_init.pageY);\n    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;\n  }\n\n  // Clip scaling to [1/8, 8] to prevent too much blowup.\n  xScale = Math.min(8, Math.max(0.125, xScale));\n  yScale = Math.min(8, Math.max(0.125, yScale));\n\n  var didZoom = false;\n  if (context.touchDirections.x) {\n    g.dateWindow_ = [\n      c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale,\n      c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale\n    ];\n    didZoom = true;\n  }\n\n  if (context.touchDirections.y) {\n    for (i = 0; i < 1  /*g.axes_.length*/; i++) {\n      var axis = g.axes_[i];\n      var logscale = g.attributes_.getForAxis("logscale", i);\n      if (logscale) {\n        // TODO(danvk): implement\n      } else {\n        axis.valueRange = [\n          c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale,\n          c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale\n        ];\n        didZoom = true;\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n\n  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.\n  if (didZoom && touches.length > 1 && g.getFunctionOption(\'zoomCallback\')) {\n    var viewWindow = g.xAxisRange();\n    g.getFunctionOption("zoomCallback").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());\n  }\n};\n\n/**\n * @private\n */\nDygraphInteraction.endTouch = function(event, g, context) {\n  if (event.touches.length !== 0) {\n    // this is effectively a "reset"\n    DygraphInteraction.startTouch(event, g, context);\n  } else if (event.changedTouches.length == 1) {\n    // Could be part of a "double tap"\n    // The heuristic here is that it\'s a double-tap if the two touchend events\n    // occur within 500ms and within a 50x50 pixel box.\n    var now = new Date().getTime();\n    var t = event.changedTouches[0];\n    if (context.startTimeForDoubleTapMs &&\n        now - context.startTimeForDoubleTapMs < 500 &&\n        context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 &&\n        context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {\n      g.resetZoom();\n    } else {\n      context.startTimeForDoubleTapMs = now;\n      context.doubleTapX = t.screenX;\n      context.doubleTapY = t.screenY;\n    }\n  }\n};\n\n// Determine the distance from x to [left, right].\nvar distanceFromInterval = function(x, left, right) {\n  if (x < left) {\n    return left - x;\n  } else if (x > right) {\n    return x - right;\n  } else {\n    return 0;\n  }\n};\n\n/**\n * Returns the number of pixels by which the event happens from the nearest\n * edge of the chart. For events in the interior of the chart, this returns zero.\n */\nvar distanceFromChart = function(event, g) {\n  var chartPos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* findPos */ "v"](g.canvas_);\n  var box = {\n    left: chartPos.x,\n    right: chartPos.x + g.canvas_.offsetWidth,\n    top: chartPos.y,\n    bottom: chartPos.y + g.canvas_.offsetHeight\n  };\n\n  var pt = {\n    x: _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* pageX */ "L"](event),\n    y: _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* pageY */ "M"](event)\n  };\n\n  var dx = distanceFromInterval(pt.x, box.left, box.right),\n      dy = distanceFromInterval(pt.y, box.top, box.bottom);\n  return Math.max(dx, dy);\n};\n\n/**\n * Default interation model for dygraphs. You can refer to specific elements of\n * this when constructing your own interaction model, e.g.:\n * g.updateOptions( {\n *   interactionModel: {\n *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown\n *   }\n * } );\n */\nDygraphInteraction.defaultModel = {\n  // Track the beginning of drag events\n  mousedown: function(event, g, context) {\n    // Right-click should not initiate a zoom.\n    if (event.button && event.button == 2) return;\n\n    context.initializeMouseDown(event, g, context);\n\n    if (event.altKey || event.shiftKey) {\n      DygraphInteraction.startPan(event, g, context);\n    } else {\n      DygraphInteraction.startZoom(event, g, context);\n    }\n\n    // Note: we register mousemove/mouseup on document to allow some leeway for\n    // events to move outside of the chart. Interaction model events get\n    // registered on the canvas, which is too small to allow this.\n    var mousemove = function(event) {\n      if (context.isZooming) {\n        // When the mouse moves >200px from the chart edge, cancel the zoom.\n        var d = distanceFromChart(event, g);\n        if (d < DRAG_EDGE_MARGIN) {\n          DygraphInteraction.moveZoom(event, g, context);\n        } else {\n          if (context.dragEndX !== null) {\n            context.dragEndX = null;\n            context.dragEndY = null;\n            g.clearZoomRect_();\n          }\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.movePan(event, g, context);\n      }\n    };\n    var mouseup = function(event) {\n      if (context.isZooming) {\n        if (context.dragEndX !== null) {\n          DygraphInteraction.endZoom(event, g, context);\n        } else {\n          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.endPan(event, g, context);\n      }\n\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ "O"](document, \'mousemove\', mousemove);\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ "O"](document, \'mouseup\', mouseup);\n      context.destroy();\n    };\n\n    g.addAndTrackEvent(document, \'mousemove\', mousemove);\n    g.addAndTrackEvent(document, \'mouseup\', mouseup);\n  },\n  willDestroyContextMyself: true,\n\n  touchstart: function(event, g, context) {\n    DygraphInteraction.startTouch(event, g, context);\n  },\n  touchmove: function(event, g, context) {\n    DygraphInteraction.moveTouch(event, g, context);\n  },\n  touchend: function(event, g, context) {\n    DygraphInteraction.endTouch(event, g, context);\n  },\n\n  // Disable zooming out if panning.\n  dblclick: function(event, g, context) {\n    if (context.cancelNextDblclick) {\n      context.cancelNextDblclick = false;\n      return;\n    }\n\n    // Give plugins a chance to grab this event.\n    var e = {\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY,\n      cancelable: true,\n    };\n    if (g.cascadeEvents_(\'dblclick\', e)) {\n      return;\n    }\n\n    if (event.altKey || event.shiftKey) {\n      return;\n    }\n    g.resetZoom();\n  }\n};\n\n/*\nDygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;\n\n// old ways of accessing these methods/properties\nDygraph.defaultInteractionModel = DygraphInteraction.defaultModel;\nDygraph.endZoom = DygraphInteraction.endZoom;\nDygraph.moveZoom = DygraphInteraction.moveZoom;\nDygraph.startZoom = DygraphInteraction.startZoom;\nDygraph.endPan = DygraphInteraction.endPan;\nDygraph.movePan = DygraphInteraction.movePan;\nDygraph.startPan = DygraphInteraction.startPan;\n*/\n\nDygraphInteraction.nonInteractiveModel_ = {\n  mousedown: function(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n  },\n  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick\n};\n\n// Default interaction model when using the range selector.\nDygraphInteraction.dragIsPanInteractionModel = {\n  mousedown: function(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n    DygraphInteraction.startPan(event, g, context);\n  },\n  mousemove: function(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.movePan(event, g, context);\n    }\n  },\n  mouseup: function(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.endPan(event, g, context);\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (DygraphInteraction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC1pbnRlcmFjdGlvbi1tb2RlbC5qcz9kODRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIFJvYmVydCBLb25pZ3NiZXJnIChrb25pZ3NiZXJnQGdvb2dsZS5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBkZWZhdWx0IGludGVyYWN0aW9uIG1vZGVsIGZvciBEeWdyYXBocy4gVGhpcyBpcyBrZXB0IG91dFxuICogb2YgZHlncmFwaC5qcyBmb3IgYmV0dGVyIG5hdmlnYWJpbGl0eS5cbiAqIEBhdXRob3IgUm9iZXJ0IEtvbmlnc2JlcmcgKGtvbmlnc2JlcmdAZ29vZ2xlLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuLyoqXG4gKiBZb3UgY2FuIGRyYWcgdGhpcyBtYW55IHBpeGVscyBwYXN0IHRoZSBlZGdlIG9mIHRoZSBjaGFydCBhbmQgc3RpbGwgaGF2ZSBpdFxuICogYmUgY29uc2lkZXJlZCBhIHpvb20uIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIHpvb20gdG8gdGhlIGV4YWN0IGVkZ2Ugb2YgdGhlXG4gKiBjaGFydCwgYSBmYWlybHkgY29tbW9uIG9wZXJhdGlvbi5cbiAqL1xudmFyIERSQUdfRURHRV9NQVJHSU4gPSAxMDA7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0byBmYWNpbGl0YXRlIGJ1aWxkIGN1c3RvbSBpbnRlcmFjdGlvbiBtb2RlbHMuXG4gKiBAY2xhc3NcbiAqL1xudmFyIER5Z3JhcGhJbnRlcmFjdGlvbiA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBiZWdpbm5pbmcgJiBlbmRpbmcgb2YgYW4gZXZlbnQgd2VyZSBjbG9zZSBlbm91Z2ggdGhhdCBpdFxuICogc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjbGljay4gSWYgaXQgc2hvdWxkLCBkaXNwYXRjaCBhcHByb3ByaWF0ZSBldmVudHMuXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGV2ZW50IHdhcyB0cmVhdGVkIGFzIGEgY2xpY2suXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RHlncmFwaH0gZ1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcbiAgdmFyIHJlZ2lvbldpZHRoID0gTWF0aC5hYnMoY29udGV4dC5kcmFnRW5kWCAtIGNvbnRleHQuZHJhZ1N0YXJ0WCk7XG4gIHZhciByZWdpb25IZWlnaHQgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdFbmRZIC0gY29udGV4dC5kcmFnU3RhcnRZKTtcblxuICBpZiAocmVnaW9uV2lkdGggPCAyICYmIHJlZ2lvbkhlaWdodCA8IDIgJiZcbiAgICAgIGcubGFzdHhfICE9PSB1bmRlZmluZWQgJiYgZy5sYXN0eF8gIT0gLTEpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24udHJlYXRNb3VzZU9wQXNDbGljayhnLCBldmVudCwgY29udGV4dCk7XG4gIH1cblxuICBjb250ZXh0LnJlZ2lvbldpZHRoID0gcmVnaW9uV2lkdGg7XG4gIGNvbnRleHQucmVnaW9uSGVpZ2h0ID0gcmVnaW9uSGVpZ2h0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHNob3VsZCBzdGFydCB0aGUgZGVmYXVsdCBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZWRvd25cIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgc3RhcnRQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICB2YXIgaSwgYXhpcztcbiAgY29udGV4dC5pc1Bhbm5pbmcgPSB0cnVlO1xuICB2YXIgeFJhbmdlID0gZy54QXhpc1JhbmdlKCk7XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcyhcImxvZ3NjYWxlXCIsIFwieFwiKSkge1xuICAgIGNvbnRleHQuaW5pdGlhbExlZnRtb3N0RGF0ZSA9IHV0aWxzLmxvZzEwKHhSYW5nZVswXSk7XG4gICAgY29udGV4dC5kYXRlUmFuZ2UgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMV0pIC0gdXRpbHMubG9nMTAoeFJhbmdlWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmluaXRpYWxMZWZ0bW9zdERhdGUgPSB4UmFuZ2VbMF07XG4gICAgY29udGV4dC5kYXRlUmFuZ2UgPSB4UmFuZ2VbMV0gLSB4UmFuZ2VbMF07XG4gIH1cbiAgY29udGV4dC54VW5pdHNQZXJQaXhlbCA9IGNvbnRleHQuZGF0ZVJhbmdlIC8gKGcucGxvdHRlcl8uYXJlYS53IC0gMSk7XG5cbiAgaWYgKGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKSkge1xuICAgIHZhciBtYXhYUGl4ZWxzVG9EcmF3ID0gZy53aWR0aF8gKiBnLmdldE51bWVyaWNPcHRpb24oXCJwYW5FZGdlRnJhY3Rpb25cIik7XG4gICAgdmFyIHhFeHRyZW1lcyA9IGcueEF4aXNFeHRyZW1lcygpOyAvLyBJIFJFQUxMWSBXQU5UIFRPIENBTEwgVEhJUyB4VHJlbWVzIVxuXG4gICAgdmFyIGJvdW5kZWRMZWZ0WCA9IGcudG9Eb21YQ29vcmQoeEV4dHJlbWVzWzBdKSAtIG1heFhQaXhlbHNUb0RyYXc7XG4gICAgdmFyIGJvdW5kZWRSaWdodFggPSBnLnRvRG9tWENvb3JkKHhFeHRyZW1lc1sxXSkgKyBtYXhYUGl4ZWxzVG9EcmF3O1xuXG4gICAgdmFyIGJvdW5kZWRMZWZ0RGF0ZSA9IGcudG9EYXRhWENvb3JkKGJvdW5kZWRMZWZ0WCk7XG4gICAgdmFyIGJvdW5kZWRSaWdodERhdGUgPSBnLnRvRGF0YVhDb29yZChib3VuZGVkUmlnaHRYKTtcbiAgICBjb250ZXh0LmJvdW5kZWREYXRlcyA9IFtib3VuZGVkTGVmdERhdGUsIGJvdW5kZWRSaWdodERhdGVdO1xuXG4gICAgdmFyIGJvdW5kZWRWYWx1ZXMgPSBbXTtcbiAgICB2YXIgbWF4WVBpeGVsc1RvRHJhdyA9IGcuaGVpZ2h0XyAqIGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBnLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBheGlzID0gZy5heGVzX1tpXTtcbiAgICAgIHZhciB5RXh0cmVtZXMgPSBheGlzLmV4dHJlbWVSYW5nZTtcblxuICAgICAgdmFyIGJvdW5kZWRUb3BZID0gZy50b0RvbVlDb29yZCh5RXh0cmVtZXNbMF0sIGkpICsgbWF4WVBpeGVsc1RvRHJhdztcbiAgICAgIHZhciBib3VuZGVkQm90dG9tWSA9IGcudG9Eb21ZQ29vcmQoeUV4dHJlbWVzWzFdLCBpKSAtIG1heFlQaXhlbHNUb0RyYXc7XG5cbiAgICAgIHZhciBib3VuZGVkVG9wVmFsdWUgPSBnLnRvRGF0YVlDb29yZChib3VuZGVkVG9wWSwgaSk7XG4gICAgICB2YXIgYm91bmRlZEJvdHRvbVZhbHVlID0gZy50b0RhdGFZQ29vcmQoYm91bmRlZEJvdHRvbVksIGkpO1xuXG4gICAgICBib3VuZGVkVmFsdWVzW2ldID0gW2JvdW5kZWRUb3BWYWx1ZSwgYm91bmRlZEJvdHRvbVZhbHVlXTtcbiAgICB9XG4gICAgY29udGV4dC5ib3VuZGVkVmFsdWVzID0gYm91bmRlZFZhbHVlcztcbiAgfVxuXG4gIC8vIFJlY29yZCB0aGUgcmFuZ2Ugb2YgZWFjaCB5LWF4aXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkcmFnLlxuICAvLyBJZiBhbnkgYXhpcyBoYXMgYSB2YWx1ZVJhbmdlLCB0aGVuIHdlIHdhbnQgYSAyRCBwYW4uXG4gIC8vIFdlIGNhbid0IHN0b3JlIGRhdGEgZGlyZWN0bHkgaW4gZy5heGVzXywgYmVjYXVzZSBpdCBkb2VzIG5vdCBiZWxvbmcgdG8gdXNcbiAgLy8gYW5kIGNvdWxkIGNoYW5nZSBvdXQgZnJvbSB1bmRlciB1cyBkdXJpbmcgYSBwYW4gKHNheSBpZiB0aGVyZSdzIGEgZGF0YVxuICAvLyB1cGRhdGUpLlxuICBjb250ZXh0LmlzMkRQYW4gPSBmYWxzZTtcbiAgY29udGV4dC5heGVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBnLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgYXhpcyA9IGcuYXhlc19baV07XG4gICAgdmFyIGF4aXNfZGF0YSA9IHt9O1xuICAgIHZhciB5UmFuZ2UgPSBnLnlBeGlzUmFuZ2UoaSk7XG4gICAgLy8gVE9ETyhrb25pZ3NiZXJnKTogVGhlc2UgdmFsdWVzIHNob3VsZCBiZSBpbiB8Y29udGV4dHwuXG4gICAgLy8gSW4gbG9nIHNjYWxlLCBpbml0aWFsVG9wVmFsdWUsIGRyYWdWYWx1ZVJhbmdlIGFuZCB1bml0c1BlclBpeGVsIGFyZSBsb2cgc2NhbGUuXG4gICAgdmFyIGxvZ3NjYWxlID0gZy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgaSk7XG4gICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICBheGlzX2RhdGEuaW5pdGlhbFRvcFZhbHVlID0gdXRpbHMubG9nMTAoeVJhbmdlWzFdKTtcbiAgICAgIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZSA9IHV0aWxzLmxvZzEwKHlSYW5nZVsxXSkgLSB1dGlscy5sb2cxMCh5UmFuZ2VbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzX2RhdGEuaW5pdGlhbFRvcFZhbHVlID0geVJhbmdlWzFdO1xuICAgICAgYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlID0geVJhbmdlWzFdIC0geVJhbmdlWzBdO1xuICAgIH1cbiAgICBheGlzX2RhdGEudW5pdHNQZXJQaXhlbCA9IGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZSAvIChnLnBsb3R0ZXJfLmFyZWEuaCAtIDEpO1xuICAgIGNvbnRleHQuYXhlcy5wdXNoKGF4aXNfZGF0YSk7XG5cbiAgICAvLyBXaGlsZSBjYWxjdWxhdGluZyBheGVzLCBzZXQgMmRwYW4uXG4gICAgaWYgKGF4aXMudmFsdWVSYW5nZSkgY29udGV4dC5pczJEUGFuID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgcGFucyB0aGUgdmlldy5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2Vtb3ZlXCIgb3BlcmF0aW9ucy5cbiAqIEN1c3RvbSBpbnRlcmFjdGlvbiBtb2RlbCBidWlsZGVycyBjYW4gdXNlIGl0IHRvIHByb3ZpZGUgdGhlIGRlZmF1bHRcbiAqIHBhbm5pbmcgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGV2ZW50IG9iamVjdCB3aGljaCBsZWQgdG8gdGhlIG1vdmVQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbiA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcblxuICB2YXIgbWluRGF0ZSA9IGNvbnRleHQuaW5pdGlhbExlZnRtb3N0RGF0ZSAtXG4gICAgKGNvbnRleHQuZHJhZ0VuZFggLSBjb250ZXh0LmRyYWdTdGFydFgpICogY29udGV4dC54VW5pdHNQZXJQaXhlbDtcbiAgaWYgKGNvbnRleHQuYm91bmRlZERhdGVzKSB7XG4gICAgbWluRGF0ZSA9IE1hdGgubWF4KG1pbkRhdGUsIGNvbnRleHQuYm91bmRlZERhdGVzWzBdKTtcbiAgfVxuICB2YXIgbWF4RGF0ZSA9IG1pbkRhdGUgKyBjb250ZXh0LmRhdGVSYW5nZTtcbiAgaWYgKGNvbnRleHQuYm91bmRlZERhdGVzKSB7XG4gICAgaWYgKG1heERhdGUgPiBjb250ZXh0LmJvdW5kZWREYXRlc1sxXSkge1xuICAgICAgLy8gQWRqdXN0IG1pbkRhdGUsIGFuZCByZWNvbXB1dGUgbWF4RGF0ZS5cbiAgICAgIG1pbkRhdGUgPSBtaW5EYXRlIC0gKG1heERhdGUgLSBjb250ZXh0LmJvdW5kZWREYXRlc1sxXSk7XG4gICAgICBtYXhEYXRlID0gbWluRGF0ZSArIGNvbnRleHQuZGF0ZVJhbmdlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoXCJsb2dzY2FsZVwiLCBcInhcIikpIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gWyBNYXRoLnBvdyh1dGlscy5MT0dfU0NBTEUsIG1pbkRhdGUpLFxuICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWF4RGF0ZSkgXTtcbiAgfSBlbHNlIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gW21pbkRhdGUsIG1heERhdGVdO1xuICB9XG5cbiAgLy8geS1heGlzIHNjYWxpbmcgaXMgYXV0b21hdGljIHVubGVzcyB0aGlzIGlzIGEgZnVsbCAyRCBwYW4uXG4gIGlmIChjb250ZXh0LmlzMkRQYW4pIHtcblxuICAgIHZhciBwaXhlbHNEcmFnZ2VkID0gY29udGV4dC5kcmFnRW5kWSAtIGNvbnRleHQuZHJhZ1N0YXJ0WTtcblxuICAgIC8vIEFkanVzdCBlYWNoIGF4aXMgYXBwcm9wcmlhdGVseS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBheGlzID0gZy5heGVzX1tpXTtcbiAgICAgIHZhciBheGlzX2RhdGEgPSBjb250ZXh0LmF4ZXNbaV07XG4gICAgICB2YXIgdW5pdHNEcmFnZ2VkID0gcGl4ZWxzRHJhZ2dlZCAqIGF4aXNfZGF0YS51bml0c1BlclBpeGVsO1xuXG4gICAgICB2YXIgYm91bmRlZFZhbHVlID0gY29udGV4dC5ib3VuZGVkVmFsdWVzID8gY29udGV4dC5ib3VuZGVkVmFsdWVzW2ldIDogbnVsbDtcblxuICAgICAgLy8gSW4gbG9nIHNjYWxlLCBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYXJlIHRoZSBsb2dzIG9mIHRob3NlIHZhbHVlcy5cbiAgICAgIHZhciBtYXhWYWx1ZSA9IGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgKyB1bml0c0RyYWdnZWQ7XG4gICAgICBpZiAoYm91bmRlZFZhbHVlKSB7XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5taW4obWF4VmFsdWUsIGJvdW5kZWRWYWx1ZVsxXSk7XG4gICAgICB9XG4gICAgICB2YXIgbWluVmFsdWUgPSBtYXhWYWx1ZSAtIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZTtcbiAgICAgIGlmIChib3VuZGVkVmFsdWUpIHtcbiAgICAgICAgaWYgKG1pblZhbHVlIDwgYm91bmRlZFZhbHVlWzBdKSB7XG4gICAgICAgICAgLy8gQWRqdXN0IG1heFZhbHVlLCBhbmQgcmVjb21wdXRlIG1pblZhbHVlLlxuICAgICAgICAgIG1heFZhbHVlID0gbWF4VmFsdWUgLSAobWluVmFsdWUgLSBib3VuZGVkVmFsdWVbMF0pO1xuICAgICAgICAgIG1pblZhbHVlID0gbWF4VmFsdWUgLSBheGlzX2RhdGEuZHJhZ1ZhbHVlUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChnLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKSkge1xuICAgICAgICBheGlzLnZhbHVlUmFuZ2UgPSBbIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWluVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWF4VmFsdWUpIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBheGlzLnZhbHVlUmFuZ2UgPSBbIG1pblZhbHVlLCBtYXhWYWx1ZSBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGcuZHJhd0dyYXBoXyhmYWxzZSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpbiByZXNwb25zZSB0byBhbiBpbnRlcmFjdGlvbiBtb2RlbCBvcGVyYXRpb24gdGhhdFxuICogcmVzcG9uZHMgdG8gYW4gZXZlbnQgdGhhdCBlbmRzIHBhbm5pbmcuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNldXBcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgZW5kUGFuIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5tYXliZVRyZWF0TW91c2VPcEFzQ2xpY2s7XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IHN0YXJ0cyB6b29taW5nLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZWRvd25cIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgc3RhcnRab29tIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0Wm9vbSA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuaXNab29taW5nID0gdHJ1ZTtcbiAgY29udGV4dC56b29tTW92ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IGRlZmluZXMgem9vbSBib3VuZGFyaWVzLlxuICpcbiAqIEl0J3MgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3IgXCJtb3VzZW1vdmVcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgbW92ZVpvb20gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb20gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBjb250ZXh0Lnpvb21Nb3ZlZCA9IHRydWU7XG4gIGNvbnRleHQuZHJhZ0VuZFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmRyYWdFbmRZID0gdXRpbHMuZHJhZ0dldFlfKGV2ZW50LCBjb250ZXh0KTtcblxuICB2YXIgeERlbHRhID0gTWF0aC5hYnMoY29udGV4dC5kcmFnU3RhcnRYIC0gY29udGV4dC5kcmFnRW5kWCk7XG4gIHZhciB5RGVsdGEgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdTdGFydFkgLSBjb250ZXh0LmRyYWdFbmRZKTtcblxuICAvLyBkcmFnIGRpcmVjdGlvbiB0aHJlc2hvbGQgZm9yIHkgYXhpcyBpcyB0d2ljZSBhcyBsYXJnZSBhcyB4IGF4aXNcbiAgY29udGV4dC5kcmFnRGlyZWN0aW9uID0gKHhEZWx0YSA8IHlEZWx0YSAvIDIpID8gdXRpbHMuVkVSVElDQUwgOiB1dGlscy5IT1JJWk9OVEFMO1xuXG4gIGcuZHJhd1pvb21SZWN0XyhcbiAgICAgIGNvbnRleHQuZHJhZ0RpcmVjdGlvbixcbiAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WCxcbiAgICAgIGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgICBjb250ZXh0LmRyYWdTdGFydFksXG4gICAgICBjb250ZXh0LmRyYWdFbmRZLFxuICAgICAgY29udGV4dC5wcmV2RHJhZ0RpcmVjdGlvbixcbiAgICAgIGNvbnRleHQucHJldkVuZFgsXG4gICAgICBjb250ZXh0LnByZXZFbmRZKTtcblxuICBjb250ZXh0LnByZXZFbmRYID0gY29udGV4dC5kcmFnRW5kWDtcbiAgY29udGV4dC5wcmV2RW5kWSA9IGNvbnRleHQuZHJhZ0VuZFk7XG4gIGNvbnRleHQucHJldkRyYWdEaXJlY3Rpb24gPSBjb250ZXh0LmRyYWdEaXJlY3Rpb247XG59O1xuXG4vKipcbiAqIFRPRE8oZGFudmspOiBtb3ZlIHRoaXMgbG9naWMgaW50byBkeWdyYXBoLmpzXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGdcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24udHJlYXRNb3VzZU9wQXNDbGljayA9IGZ1bmN0aW9uKGcsIGV2ZW50LCBjb250ZXh0KSB7XG4gIHZhciBjbGlja0NhbGxiYWNrID0gZy5nZXRGdW5jdGlvbk9wdGlvbignY2xpY2tDYWxsYmFjaycpO1xuICB2YXIgcG9pbnRDbGlja0NhbGxiYWNrID0gZy5nZXRGdW5jdGlvbk9wdGlvbigncG9pbnRDbGlja0NhbGxiYWNrJyk7XG5cbiAgdmFyIHNlbGVjdGVkUG9pbnQgPSBudWxsO1xuXG4gIC8vIEZpbmQgb3V0IGlmIHRoZSBjbGljayBvY2N1cnMgb24gYSBwb2ludC5cbiAgdmFyIGNsb3Nlc3RJZHggPSAtMTtcbiAgdmFyIGNsb3Nlc3REaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgLy8gY2hlY2sgaWYgdGhlIGNsaWNrIHdhcyBvbiBhIHBhcnRpY3VsYXIgcG9pbnQuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZy5zZWxQb2ludHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBnLnNlbFBvaW50c19baV07XG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5wb3cocC5jYW52YXN4IC0gY29udGV4dC5kcmFnRW5kWCwgMikgK1xuICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHAuY2FudmFzeSAtIGNvbnRleHQuZHJhZ0VuZFksIDIpO1xuICAgIGlmICghaXNOYU4oZGlzdGFuY2UpICYmXG4gICAgICAgIChjbG9zZXN0SWR4ID09IC0xIHx8IGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlKSkge1xuICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICBjbG9zZXN0SWR4ID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBhbnkgY2xpY2sgd2l0aGluIHR3byBwaXhlbHMgb2YgdGhlIGRvdC5cbiAgdmFyIHJhZGl1cyA9IGcuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScpICsgMjtcbiAgaWYgKGNsb3Nlc3REaXN0YW5jZSA8PSByYWRpdXMgKiByYWRpdXMpIHtcbiAgICBzZWxlY3RlZFBvaW50ID0gZy5zZWxQb2ludHNfW2Nsb3Nlc3RJZHhdO1xuICB9XG5cbiAgaWYgKHNlbGVjdGVkUG9pbnQpIHtcbiAgICB2YXIgZSA9IHtcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBwb2ludDogc2VsZWN0ZWRQb2ludCxcbiAgICAgIGNhbnZhc3g6IGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgICBjYW52YXN5OiBjb250ZXh0LmRyYWdFbmRZXG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IGcuY2FzY2FkZUV2ZW50c18oJ3BvaW50Q2xpY2snLCBlKTtcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgLy8gTm90ZTogdGhpcyBhbHNvIHByZXZlbnRzIGNsaWNrIC8gY2xpY2tDYWxsYmFjayBmcm9tIGZpcmluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBvaW50Q2xpY2tDYWxsYmFjaykge1xuICAgICAgcG9pbnRDbGlja0NhbGxiYWNrLmNhbGwoZywgZXZlbnQsIHNlbGVjdGVkUG9pbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlID0ge1xuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgeHZhbDogZy5sYXN0eF8sICAvLyBjbG9zZXN0IHBvaW50IGJ5IHggdmFsdWVcbiAgICBwdHM6IGcuc2VsUG9pbnRzXyxcbiAgICBjYW52YXN4OiBjb250ZXh0LmRyYWdFbmRYLFxuICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFlcbiAgfTtcbiAgaWYgKCFnLmNhc2NhZGVFdmVudHNfKCdjbGljaycsIGUpKSB7XG4gICAgaWYgKGNsaWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiBwYXNzIGFsb25nIG1vcmUgaW5mbyBhYm91dCB0aGUgcG9pbnRzLCBlLmcuICd4J1xuICAgICAgY2xpY2tDYWxsYmFjay5jYWxsKGcsIGV2ZW50LCBnLmxhc3R4XywgZy5zZWxQb2ludHNfKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IHBlcmZvcm1zIGEgem9vbSBiYXNlZCBvbiBwcmV2aW91c2x5IGRlZmluZWRcbiAqIGJvdW5kcy4uXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNldXBcIiBvcGVyYXRpb25zLlxuICogQ3VzdG9tIGludGVyYWN0aW9uIG1vZGVsIGJ1aWxkZXJzIGNhbiB1c2UgaXQgdG8gcHJvdmlkZSB0aGUgZGVmYXVsdFxuICogem9vbWluZyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZXZlbnQgb2JqZWN0IHdoaWNoIGxlZCB0byB0aGUgZW5kWm9vbSBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGVuZCB0aGUgem9vbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5lbmRab29tID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgZy5jbGVhclpvb21SZWN0XygpO1xuICBjb250ZXh0LmlzWm9vbWluZyA9IGZhbHNlO1xuICBEeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrKGV2ZW50LCBnLCBjb250ZXh0KTtcblxuICAvLyBUaGUgem9vbSByZWN0YW5nbGUgaXMgdmlzaWJseSBjbGlwcGVkIHRvIHRoZSBwbG90IGFyZWEsIHNvIGl0cyBiZWhhdmlvclxuICAvLyBzaG91bGQgYmUgYXMgd2VsbC5cbiAgLy8gU2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9keWdyYXBocy9pc3N1ZXMvZGV0YWlsP2lkPTI4MFxuICB2YXIgcGxvdEFyZWEgPSBnLmdldEFyZWEoKTtcbiAgaWYgKGNvbnRleHQucmVnaW9uV2lkdGggPj0gMTAgJiZcbiAgICAgIGNvbnRleHQuZHJhZ0RpcmVjdGlvbiA9PSB1dGlscy5IT1JJWk9OVEFMKSB7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihjb250ZXh0LmRyYWdTdGFydFgsIGNvbnRleHQuZHJhZ0VuZFgpLFxuICAgICAgICByaWdodCA9IE1hdGgubWF4KGNvbnRleHQuZHJhZ1N0YXJ0WCwgY29udGV4dC5kcmFnRW5kWCk7XG4gICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBsb3RBcmVhLngpO1xuICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBsb3RBcmVhLnggKyBwbG90QXJlYS53KTtcbiAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBnLmRvWm9vbVhfKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGNvbnRleHQucmVnaW9uSGVpZ2h0ID49IDEwICYmXG4gICAgICAgICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgdmFyIHRvcCA9IE1hdGgubWluKGNvbnRleHQuZHJhZ1N0YXJ0WSwgY29udGV4dC5kcmFnRW5kWSksXG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGNvbnRleHQuZHJhZ1N0YXJ0WSwgY29udGV4dC5kcmFnRW5kWSk7XG4gICAgdG9wID0gTWF0aC5tYXgodG9wLCBwbG90QXJlYS55KTtcbiAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHBsb3RBcmVhLnkgKyBwbG90QXJlYS5oKTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICBnLmRvWm9vbVlfKHRvcCwgYm90dG9tKTtcbiAgICB9XG4gICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSB0cnVlO1xuICB9XG4gIGNvbnRleHQuZHJhZ1N0YXJ0WCA9IG51bGw7XG4gIGNvbnRleHQuZHJhZ1N0YXJ0WSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIHRvdWNoIGJyb3dzZXJzIGFyZSBhbGwgbmljZS5cbiAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgIC8vIElmIHRoZSB1c2VyIGV2ZXIgcHV0cyB0d28gZmluZ2VycyBkb3duLCBpdCdzIG5vdCBhIGRvdWJsZSB0YXAuXG4gICAgY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA9IG51bGw7XG4gIH1cblxuICB2YXIgdG91Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IGV2ZW50LnRvdWNoZXNbaV07XG4gICAgLy8gd2UgZGlzcGVuc2Ugd2l0aCAnZHJhZ0dldFhfJyBiZWNhdXNlIGFsbCB0b3VjaEJyb3dzZXJzIHN1cHBvcnQgcGFnZVhcbiAgICB0b3VjaGVzLnB1c2goe1xuICAgICAgcGFnZVg6IHQucGFnZVgsXG4gICAgICBwYWdlWTogdC5wYWdlWSxcbiAgICAgIGRhdGFYOiBnLnRvRGF0YVhDb29yZCh0LnBhZ2VYKSxcbiAgICAgIGRhdGFZOiBnLnRvRGF0YVlDb29yZCh0LnBhZ2VZKVxuICAgICAgLy8gaWRlbnRpZmllcjogdC5pZGVudGlmaWVyXG4gICAgfSk7XG4gIH1cbiAgY29udGV4dC5pbml0aWFsVG91Y2hlcyA9IHRvdWNoZXM7XG5cbiAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAvLyBUaGlzIGlzIGp1c3QgYSBzd2lwZS5cbiAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlciA9IHRvdWNoZXNbMF07XG4gICAgY29udGV4dC50b3VjaERpcmVjdGlvbnMgPSB7IHg6IHRydWUsIHk6IHRydWUgfTtcbiAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgLy8gSXQncyBiZWNvbWUgYSBwaW5jaCFcbiAgICAvLyBJbiBjYXNlIHRoZXJlIGFyZSAzKyB0b3VjaGVzLCB3ZSBpZ25vcmUgYWxsIGJ1dCB0aGUgXCJmaXJzdFwiIHR3by5cblxuICAgIC8vIG9ubHkgc2NyZWVuIGNvb3JkaW5hdGVzIGNhbiBiZSBhdmVyYWdlZCAoZGF0YSBjb29yZHMgY291bGQgYmUgbG9nIHNjYWxlKS5cbiAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlciA9IHtcbiAgICAgIHBhZ2VYOiAwLjUgKiAodG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpLFxuICAgICAgcGFnZVk6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VZICsgdG91Y2hlc1sxXS5wYWdlWSksXG5cbiAgICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmVcbiAgICAgIGRhdGFYOiAwLjUgKiAodG91Y2hlc1swXS5kYXRhWCArIHRvdWNoZXNbMV0uZGF0YVgpLFxuICAgICAgZGF0YVk6IDAuNSAqICh0b3VjaGVzWzBdLmRhdGFZICsgdG91Y2hlc1sxXS5kYXRhWSlcbiAgICB9O1xuXG4gICAgLy8gTWFrZSBwaW5jaGVzIGluIGEgNDUtZGVncmVlIHN3YXRoIGFyb3VuZCBlaXRoZXIgYXhpcyAxLWRpbWVuc2lvbmFsIHpvb21zLlxuICAgIHZhciBpbml0aWFsQW5nbGUgPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihcbiAgICAgICAgY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXIucGFnZVkgLSB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICB0b3VjaGVzWzBdLnBhZ2VYIC0gY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXIucGFnZVgpO1xuXG4gICAgLy8gdXNlIHN5bW1ldHJ5IHRvIGdldCBpdCBpbnRvIHRoZSBmaXJzdCBxdWFkcmFudC5cbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLmFicyhpbml0aWFsQW5nbGUpO1xuICAgIGlmIChpbml0aWFsQW5nbGUgPiA5MCkgaW5pdGlhbEFuZ2xlID0gOTAgLSBpbml0aWFsQW5nbGU7XG5cbiAgICBjb250ZXh0LnRvdWNoRGlyZWN0aW9ucyA9IHtcbiAgICAgIHg6IChpbml0aWFsQW5nbGUgPCAoOTAgLSA0NS8yKSksXG4gICAgICB5OiAoaW5pdGlhbEFuZ2xlID4gNDUvMilcbiAgICB9O1xuICB9XG5cbiAgLy8gc2F2ZSB0aGUgZnVsbCB4ICYgeSByYW5nZXMuXG4gIGNvbnRleHQuaW5pdGlhbFJhbmdlID0ge1xuICAgIHg6IGcueEF4aXNSYW5nZSgpLFxuICAgIHk6IGcueUF4aXNSYW5nZSgpXG4gIH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlVG91Y2ggPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAvLyBJZiB0aGUgdGFwIG1vdmVzLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBub3QgcGFydCBvZiBhIGRvdWJsZS10YXAuXG4gIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPSBudWxsO1xuXG4gIHZhciBpLCB0b3VjaGVzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBldmVudC50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSBldmVudC50b3VjaGVzW2ldO1xuICAgIHRvdWNoZXMucHVzaCh7XG4gICAgICBwYWdlWDogdC5wYWdlWCxcbiAgICAgIHBhZ2VZOiB0LnBhZ2VZXG4gICAgfSk7XG4gIH1cbiAgdmFyIGluaXRpYWxUb3VjaGVzID0gY29udGV4dC5pbml0aWFsVG91Y2hlcztcblxuICB2YXIgY19ub3c7XG5cbiAgLy8gb2xkIGFuZCBuZXcgY2VudGVycy5cbiAgdmFyIGNfaW5pdCA9IGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyO1xuICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIGNfbm93ID0gdG91Y2hlc1swXTtcbiAgfSBlbHNlIHtcbiAgICBjX25vdyA9IHtcbiAgICAgIHBhZ2VYOiAwLjUgKiAodG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpLFxuICAgICAgcGFnZVk6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VZICsgdG91Y2hlc1sxXS5wYWdlWSlcbiAgICB9O1xuICB9XG5cbiAgLy8gdGhpcyBpcyB0aGUgXCJzd2lwZVwiIGNvbXBvbmVudFxuICAvLyB3ZSB0b3NzIGl0IG91dCBmb3Igbm93LCBidXQgY291bGQgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gIHZhciBzd2lwZSA9IHtcbiAgICBwYWdlWDogY19ub3cucGFnZVggLSBjX2luaXQucGFnZVgsXG4gICAgcGFnZVk6IGNfbm93LnBhZ2VZIC0gY19pbml0LnBhZ2VZXG4gIH07XG4gIHZhciBkYXRhV2lkdGggPSBjb250ZXh0LmluaXRpYWxSYW5nZS54WzFdIC0gY29udGV4dC5pbml0aWFsUmFuZ2UueFswXTtcbiAgdmFyIGRhdGFIZWlnaHQgPSBjb250ZXh0LmluaXRpYWxSYW5nZS55WzBdIC0gY29udGV4dC5pbml0aWFsUmFuZ2UueVsxXTtcbiAgc3dpcGUuZGF0YVggPSAoc3dpcGUucGFnZVggLyBnLnBsb3R0ZXJfLmFyZWEudykgKiBkYXRhV2lkdGg7XG4gIHN3aXBlLmRhdGFZID0gKHN3aXBlLnBhZ2VZIC8gZy5wbG90dGVyXy5hcmVhLmgpICogZGF0YUhlaWdodDtcbiAgdmFyIHhTY2FsZSwgeVNjYWxlO1xuXG4gIC8vIFRoZSByZXNpZHVhbCBiaXRzIGFyZSB1c3VhbGx5IHNwbGl0IGludG8gc2NhbGUgJiByb3RhdGUgYml0cywgYnV0IHdlIHNwbGl0XG4gIC8vIHRoZW0gaW50byB4LXNjYWxlIGFuZCB5LXNjYWxlIGJpdHMuXG4gIGlmICh0b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgeFNjYWxlID0gMS4wO1xuICAgIHlTY2FsZSA9IDEuMDtcbiAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgdmFyIGluaXRIYWxmV2lkdGggPSAoaW5pdGlhbFRvdWNoZXNbMV0ucGFnZVggLSBjX2luaXQucGFnZVgpO1xuICAgIHhTY2FsZSA9ICh0b3VjaGVzWzFdLnBhZ2VYIC0gY19ub3cucGFnZVgpIC8gaW5pdEhhbGZXaWR0aDtcblxuICAgIHZhciBpbml0SGFsZkhlaWdodCA9IChpbml0aWFsVG91Y2hlc1sxXS5wYWdlWSAtIGNfaW5pdC5wYWdlWSk7XG4gICAgeVNjYWxlID0gKHRvdWNoZXNbMV0ucGFnZVkgLSBjX25vdy5wYWdlWSkgLyBpbml0SGFsZkhlaWdodDtcbiAgfVxuXG4gIC8vIENsaXAgc2NhbGluZyB0byBbMS84LCA4XSB0byBwcmV2ZW50IHRvbyBtdWNoIGJsb3d1cC5cbiAgeFNjYWxlID0gTWF0aC5taW4oOCwgTWF0aC5tYXgoMC4xMjUsIHhTY2FsZSkpO1xuICB5U2NhbGUgPSBNYXRoLm1pbig4LCBNYXRoLm1heCgwLjEyNSwgeVNjYWxlKSk7XG5cbiAgdmFyIGRpZFpvb20gPSBmYWxzZTtcbiAgaWYgKGNvbnRleHQudG91Y2hEaXJlY3Rpb25zLngpIHtcbiAgICBnLmRhdGVXaW5kb3dfID0gW1xuICAgICAgY19pbml0LmRhdGFYIC0gc3dpcGUuZGF0YVggKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueFswXSAtIGNfaW5pdC5kYXRhWCkgLyB4U2NhbGUsXG4gICAgICBjX2luaXQuZGF0YVggLSBzd2lwZS5kYXRhWCArIChjb250ZXh0LmluaXRpYWxSYW5nZS54WzFdIC0gY19pbml0LmRhdGFYKSAvIHhTY2FsZVxuICAgIF07XG4gICAgZGlkWm9vbSA9IHRydWU7XG4gIH1cblxuICBpZiAoY29udGV4dC50b3VjaERpcmVjdGlvbnMueSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCAxICAvKmcuYXhlc18ubGVuZ3RoKi87IGkrKykge1xuICAgICAgdmFyIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIGxvZ3NjYWxlID0gZy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgaSk7XG4gICAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETyhkYW52ayk6IGltcGxlbWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhpcy52YWx1ZVJhbmdlID0gW1xuICAgICAgICAgIGNfaW5pdC5kYXRhWSAtIHN3aXBlLmRhdGFZICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMF0gLSBjX2luaXQuZGF0YVkpIC8geVNjYWxlLFxuICAgICAgICAgIGNfaW5pdC5kYXRhWSAtIHN3aXBlLmRhdGFZICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMV0gLSBjX2luaXQuZGF0YVkpIC8geVNjYWxlXG4gICAgICAgIF07XG4gICAgICAgIGRpZFpvb20gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGcuZHJhd0dyYXBoXyhmYWxzZSk7XG5cbiAgLy8gV2Ugb25seSBjYWxsIHpvb21DYWxsYmFjayBvbiB6b29tcywgbm90IHBhbnMsIHRvIG1pcnJvciBkZXNrdG9wIGJlaGF2aW9yLlxuICBpZiAoZGlkWm9vbSAmJiB0b3VjaGVzLmxlbmd0aCA+IDEgJiYgZy5nZXRGdW5jdGlvbk9wdGlvbignem9vbUNhbGxiYWNrJykpIHtcbiAgICB2YXIgdmlld1dpbmRvdyA9IGcueEF4aXNSYW5nZSgpO1xuICAgIGcuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikuY2FsbChnLCB2aWV3V2luZG93WzBdLCB2aWV3V2luZG93WzFdLCBnLnlBeGlzUmFuZ2VzKCkpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5lbmRUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIHRoaXMgaXMgZWZmZWN0aXZlbHkgYSBcInJlc2V0XCJcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRUb3VjaChldmVudCwgZywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAvLyBDb3VsZCBiZSBwYXJ0IG9mIGEgXCJkb3VibGUgdGFwXCJcbiAgICAvLyBUaGUgaGV1cmlzdGljIGhlcmUgaXMgdGhhdCBpdCdzIGEgZG91YmxlLXRhcCBpZiB0aGUgdHdvIHRvdWNoZW5kIGV2ZW50c1xuICAgIC8vIG9jY3VyIHdpdGhpbiA1MDBtcyBhbmQgd2l0aGluIGEgNTB4NTAgcGl4ZWwgYm94LlxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGlmIChjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zICYmXG4gICAgICAgIG5vdyAtIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPCA1MDAgJiZcbiAgICAgICAgY29udGV4dC5kb3VibGVUYXBYICYmIE1hdGguYWJzKGNvbnRleHQuZG91YmxlVGFwWCAtIHQuc2NyZWVuWCkgPCA1MCAmJlxuICAgICAgICBjb250ZXh0LmRvdWJsZVRhcFkgJiYgTWF0aC5hYnMoY29udGV4dC5kb3VibGVUYXBZIC0gdC5zY3JlZW5ZKSA8IDUwKSB7XG4gICAgICBnLnJlc2V0Wm9vbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zID0gbm93O1xuICAgICAgY29udGV4dC5kb3VibGVUYXBYID0gdC5zY3JlZW5YO1xuICAgICAgY29udGV4dC5kb3VibGVUYXBZID0gdC5zY3JlZW5ZO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHggdG8gW2xlZnQsIHJpZ2h0XS5cbnZhciBkaXN0YW5jZUZyb21JbnRlcnZhbCA9IGZ1bmN0aW9uKHgsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmICh4IDwgbGVmdCkge1xuICAgIHJldHVybiBsZWZ0IC0geDtcbiAgfSBlbHNlIGlmICh4ID4gcmlnaHQpIHtcbiAgICByZXR1cm4geCAtIHJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIGV2ZW50IGhhcHBlbnMgZnJvbSB0aGUgbmVhcmVzdFxuICogZWRnZSBvZiB0aGUgY2hhcnQuIEZvciBldmVudHMgaW4gdGhlIGludGVyaW9yIG9mIHRoZSBjaGFydCwgdGhpcyByZXR1cm5zIHplcm8uXG4gKi9cbnZhciBkaXN0YW5jZUZyb21DaGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBnKSB7XG4gIHZhciBjaGFydFBvcyA9IHV0aWxzLmZpbmRQb3MoZy5jYW52YXNfKTtcbiAgdmFyIGJveCA9IHtcbiAgICBsZWZ0OiBjaGFydFBvcy54LFxuICAgIHJpZ2h0OiBjaGFydFBvcy54ICsgZy5jYW52YXNfLm9mZnNldFdpZHRoLFxuICAgIHRvcDogY2hhcnRQb3MueSxcbiAgICBib3R0b206IGNoYXJ0UG9zLnkgKyBnLmNhbnZhc18ub2Zmc2V0SGVpZ2h0XG4gIH07XG5cbiAgdmFyIHB0ID0ge1xuICAgIHg6IHV0aWxzLnBhZ2VYKGV2ZW50KSxcbiAgICB5OiB1dGlscy5wYWdlWShldmVudClcbiAgfTtcblxuICB2YXIgZHggPSBkaXN0YW5jZUZyb21JbnRlcnZhbChwdC54LCBib3gubGVmdCwgYm94LnJpZ2h0KSxcbiAgICAgIGR5ID0gZGlzdGFuY2VGcm9tSW50ZXJ2YWwocHQueSwgYm94LnRvcCwgYm94LmJvdHRvbSk7XG4gIHJldHVybiBNYXRoLm1heChkeCwgZHkpO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGludGVyYXRpb24gbW9kZWwgZm9yIGR5Z3JhcGhzLiBZb3UgY2FuIHJlZmVyIHRvIHNwZWNpZmljIGVsZW1lbnRzIG9mXG4gKiB0aGlzIHdoZW4gY29uc3RydWN0aW5nIHlvdXIgb3duIGludGVyYWN0aW9uIG1vZGVsLCBlLmcuOlxuICogZy51cGRhdGVPcHRpb25zKCB7XG4gKiAgIGludGVyYWN0aW9uTW9kZWw6IHtcbiAqICAgICBtb3VzZWRvd246IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0SW50ZXJhY3Rpb25Nb2RlbC5tb3VzZWRvd25cbiAqICAgfVxuICogfSApO1xuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsID0ge1xuICAvLyBUcmFjayB0aGUgYmVnaW5uaW5nIG9mIGRyYWcgZXZlbnRzXG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICAvLyBSaWdodC1jbGljayBzaG91bGQgbm90IGluaXRpYXRlIGEgem9vbS5cbiAgICBpZiAoZXZlbnQuYnV0dG9uICYmIGV2ZW50LmJ1dHRvbiA9PSAyKSByZXR1cm47XG5cbiAgICBjb250ZXh0LmluaXRpYWxpemVNb3VzZURvd24oZXZlbnQsIGcsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0Wm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogd2UgcmVnaXN0ZXIgbW91c2Vtb3ZlL21vdXNldXAgb24gZG9jdW1lbnQgdG8gYWxsb3cgc29tZSBsZWV3YXkgZm9yXG4gICAgLy8gZXZlbnRzIHRvIG1vdmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQuIEludGVyYWN0aW9uIG1vZGVsIGV2ZW50cyBnZXRcbiAgICAvLyByZWdpc3RlcmVkIG9uIHRoZSBjYW52YXMsIHdoaWNoIGlzIHRvbyBzbWFsbCB0byBhbGxvdyB0aGlzLlxuICAgIHZhciBtb3VzZW1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKGNvbnRleHQuaXNab29taW5nKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1vdXNlIG1vdmVzID4yMDBweCBmcm9tIHRoZSBjaGFydCBlZGdlLCBjYW5jZWwgdGhlIHpvb20uXG4gICAgICAgIHZhciBkID0gZGlzdGFuY2VGcm9tQ2hhcnQoZXZlbnQsIGcpO1xuICAgICAgICBpZiAoZCA8IERSQUdfRURHRV9NQVJHSU4pIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb20oZXZlbnQsIGcsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb250ZXh0LmRyYWdFbmRYICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYWdFbmRYID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhZ0VuZFkgPSBudWxsO1xuICAgICAgICAgICAgZy5jbGVhclpvb21SZWN0XygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZHJhZ0VuZFggIT09IG51bGwpIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kWm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljayhldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLnJlbW92ZUV2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgIHV0aWxzLnJlbW92ZUV2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNldXApO1xuICAgICAgY29udGV4dC5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGcuYWRkQW5kVHJhY2tFdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNldXApO1xuICB9LFxuICB3aWxsRGVzdHJveUNvbnRleHRNeXNlbGY6IHRydWUsXG5cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRUb3VjaChldmVudCwgZywgY29udGV4dCk7XG4gIH0sXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcblxuICAvLyBEaXNhYmxlIHpvb21pbmcgb3V0IGlmIHBhbm5pbmcuXG4gIGRibGNsaWNrOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmNhbmNlbE5leHREYmxjbGljaykge1xuICAgICAgY29udGV4dC5jYW5jZWxOZXh0RGJsY2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gZ3JhYiB0aGlzIGV2ZW50LlxuICAgIHZhciBlID0ge1xuICAgICAgY2FudmFzeDogY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH07XG4gICAgaWYgKGcuY2FzY2FkZUV2ZW50c18oJ2RibGNsaWNrJywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGcucmVzZXRab29tKCk7XG4gIH1cbn07XG5cbi8qXG5EeWdyYXBoLkRFRkFVTFRfQVRUUlMuaW50ZXJhY3Rpb25Nb2RlbCA9IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWw7XG5cbi8vIG9sZCB3YXlzIG9mIGFjY2Vzc2luZyB0aGVzZSBtZXRob2RzL3Byb3BlcnRpZXNcbkR5Z3JhcGguZGVmYXVsdEludGVyYWN0aW9uTW9kZWwgPSBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsO1xuRHlncmFwaC5lbmRab29tID0gRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb207XG5EeWdyYXBoLm1vdmVab29tID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVab29tO1xuRHlncmFwaC5zdGFydFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tO1xuRHlncmFwaC5lbmRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuO1xuRHlncmFwaC5tb3ZlUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVQYW47XG5EeWdyYXBoLnN0YXJ0UGFuID0gRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuO1xuKi9cblxuRHlncmFwaEludGVyYWN0aW9uLm5vbkludGVyYWN0aXZlTW9kZWxfID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgbW91c2V1cDogRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGlja1xufTtcblxuLy8gRGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlbCB3aGVuIHVzaW5nIHRoZSByYW5nZSBzZWxlY3Rvci5cbkR5Z3JhcGhJbnRlcmFjdGlvbi5kcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4oZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9LFxuICBtb3VzZXVwOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoSW50ZXJhY3Rpb247XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _datahandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n/* harmony import */ var _dygraph_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler base implementation for the "bar" \n * data formats. This implementation must be extended and the\n * extractSeries and rollingAverage must be implemented.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n\n\n/**\n * @constructor\n * @extends {Dygraph.DataHandler}\n */\nvar BarsHandler = function() {\n  _datahandler__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].call(this);\n};\nBarsHandler.prototype = new _datahandler__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();\n\n// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.\n//   (I get closure compiler errors if this isn\'t here.)\n/**\n * @override\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where \n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}]. \n */\nBarsHandler.prototype.extractSeries = function(rawData, seriesIndex, options) {\n  // Not implemented here must be extended\n};\n\n/**\n * @override\n * @param {!Array.<[!number,?number,?]>} series The series in the unified \n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * TODO(danvk): be more specific than "Array" here.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nBarsHandler.prototype.rollingAverage =\n    function(series, rollPeriod, options) {\n  // Not implemented here, must be extended.\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onPointsCreated_ = function(series, points) {\n  for (var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var point = points[i];\n    point.y_top = NaN;\n    point.y_bottom = NaN;\n    point.yval_minus = _datahandler__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].parseFloat(item[2][0]);\n    point.yval_plus = _datahandler__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].parseFloat(item[2][1]);\n  }\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.getExtremeYValues = function(series, dateWindow, options) {\n  var minY = null, maxY = null, y;\n\n  var firstIdx = 0;\n  var lastIdx = series.length - 1;\n\n  for ( var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n\n    var low = series[j][2][0];\n    var high = series[j][2][1];\n\n    if (low > y) low = y; // this can happen with custom bars,\n    if (high < y) high = y; // e.g. in tests/custom-bars.html\n\n    if (maxY === null || high > maxY) maxY = high;\n    if (minY === null || low < minY) minY = low;\n  }\n\n  return [ minY, maxY ];\n};\n\n/** @inheritDoc */\nBarsHandler.prototype.onLineEvaluated = function(points, axis, logscale) {\n  var point;\n  for (var j = 0; j < points.length; j++) {\n    // Copy over the error terms\n    point = points[j];\n    point.y_top = _dygraph_layout__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].calcYNormal_(axis, point.yval_minus, logscale);\n    point.y_bottom = _dygraph_layout__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].calcYNormal_(axis, point.yval_plus, logscale);\n  }\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (BarsHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy5qcz8yZjQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBiYXNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgXCJiYXJcIiBcbiAqIGRhdGEgZm9ybWF0cy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIGV4dGVuZGVkIGFuZCB0aGVcbiAqIGV4dHJhY3RTZXJpZXMgYW5kIHJvbGxpbmdBdmVyYWdlIG11c3QgYmUgaW1wbGVtZW50ZWQuXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cbi8qZ2xvYmFsIER5Z3JhcGhMYXlvdXQ6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuaW1wb3J0IER5Z3JhcGhMYXlvdXQgZnJvbSAnLi4vZHlncmFwaC1sYXlvdXQnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0R5Z3JhcGguRGF0YUhhbmRsZXJ9XG4gKi9cbnZhciBCYXJzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBEeWdyYXBoRGF0YUhhbmRsZXIuY2FsbCh0aGlzKTtcbn07XG5CYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgRHlncmFwaERhdGFIYW5kbGVyKCk7XG5cbi8vIFRPRE8oZGFudmspOiBmaWd1cmUgb3V0IHdoeSB0aGUganNkb2MgaGFzIHRvIGJlIGNvcHkvcGFzdGVkIGZyb20gc3VwZXJjbGFzcy5cbi8vICAgKEkgZ2V0IGNsb3N1cmUgY29tcGlsZXIgZXJyb3JzIGlmIHRoaXMgaXNuJ3QgaGVyZS4pXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmUgXG4gKiAgICAgcmF3RGF0YVtpXSA9IFt4LHlTZXJpZXMxLC4uLix5U2VyaWVzTl0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNlcmllc0luZGV4IEluZGV4IG9mIHRoZSBzZXJpZXMgdG8gZXh0cmFjdC4gQWxsIG90aGVyXG4gKiAgICAgc2VyaWVzIHNob3VsZCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgRHlncmFwaCBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0XG4gKiAgICAgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uIFxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIHNlcmllc0luZGV4LCBvcHRpb25zKSB7XG4gIC8vIE5vdCBpbXBsZW1lbnRlZCBoZXJlIG11c3QgYmUgZXh0ZW5kZWRcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgICAgICAgZGF0YSBmb3JtYXQgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHJvbGxQZXJpb2QgVGhlIG51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBUaGUgZHlncmFwaCBvcHRpb25zLlxuICogVE9ETyhkYW52ayk6IGJlIG1vcmUgc3BlY2lmaWMgdGhhbiBcIkFycmF5XCIgaGVyZS5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICAvLyBOb3QgaW1wbGVtZW50ZWQgaGVyZSwgbXVzdCBiZSBleHRlbmRlZC5cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLm9uUG9pbnRzQ3JlYXRlZF8gPSBmdW5jdGlvbihzZXJpZXMsIHBvaW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VyaWVzW2ldO1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBwb2ludC55X3RvcCA9IE5hTjtcbiAgICBwb2ludC55X2JvdHRvbSA9IE5hTjtcbiAgICBwb2ludC55dmFsX21pbnVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVswXSk7XG4gICAgcG9pbnQueXZhbF9wbHVzID0gRHlncmFwaERhdGFIYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVsyXVsxXSk7XG4gIH1cbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLmdldEV4dHJlbWVZVmFsdWVzID0gZnVuY3Rpb24oc2VyaWVzLCBkYXRlV2luZG93LCBvcHRpb25zKSB7XG4gIHZhciBtaW5ZID0gbnVsbCwgbWF4WSA9IG51bGwsIHk7XG5cbiAgdmFyIGZpcnN0SWR4ID0gMDtcbiAgdmFyIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKCB2YXIgaiA9IGZpcnN0SWR4OyBqIDw9IGxhc3RJZHg7IGorKykge1xuICAgIHkgPSBzZXJpZXNbal1bMV07XG4gICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGxvdyA9IHNlcmllc1tqXVsyXVswXTtcbiAgICB2YXIgaGlnaCA9IHNlcmllc1tqXVsyXVsxXTtcblxuICAgIGlmIChsb3cgPiB5KSBsb3cgPSB5OyAvLyB0aGlzIGNhbiBoYXBwZW4gd2l0aCBjdXN0b20gYmFycyxcbiAgICBpZiAoaGlnaCA8IHkpIGhpZ2ggPSB5OyAvLyBlLmcuIGluIHRlc3RzL2N1c3RvbS1iYXJzLmh0bWxcblxuICAgIGlmIChtYXhZID09PSBudWxsIHx8IGhpZ2ggPiBtYXhZKSBtYXhZID0gaGlnaDtcbiAgICBpZiAobWluWSA9PT0gbnVsbCB8fCBsb3cgPCBtaW5ZKSBtaW5ZID0gbG93O1xuICB9XG5cbiAgcmV0dXJuIFsgbWluWSwgbWF4WSBdO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5CYXJzSGFuZGxlci5wcm90b3R5cGUub25MaW5lRXZhbHVhdGVkID0gZnVuY3Rpb24ocG9pbnRzLCBheGlzLCBsb2dzY2FsZSkge1xuICB2YXIgcG9pbnQ7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgLy8gQ29weSBvdmVyIHRoZSBlcnJvciB0ZXJtc1xuICAgIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgIHBvaW50LnlfdG9wID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9taW51cywgbG9nc2NhbGUpO1xuICAgIHBvaW50LnlfYm90dG9tID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oYXhpcywgcG9pbnQueXZhbF9wbHVzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJhcnNIYW5kbGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview This file contains the managment of data handlers\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n *\n * The idea is to define a common, generic data format that works for all data\n * structures supported by dygraphs. To make this possible, the DataHandler\n * interface is introduced. This makes it possible, that dygraph itself can work\n * with the same logic for every data type independent of the actual format and\n * the DataHandler takes care of the data format specific jobs.\n * DataHandlers are implemented for all data types supported by Dygraphs and\n * return Dygraphs compliant formats.\n * By default the correct DataHandler is chosen based on the options set.\n * Optionally the user may use his own DataHandler (similar to the plugin\n * system).\n *\n *\n * The unified data format returend by each handler is defined as so:\n * series[n][point] = [x,y,(extras)]\n *\n * This format contains the common basis that is needed to draw a simple line\n * series extended by optional extras for more complex graphing types. It\n * contains a primitive x value as first array entry, a primitive y value as\n * second array entry and an optional extras object for additional data needed.\n *\n * x must always be a number.\n * y must always be a number, NaN of type number or null.\n * extras is optional and must be interpreted by the DataHandler. It may be of\n * any type.\n *\n * In practice this might look something like this:\n * default: [x, yVal]\n * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]\n *\n */\n/*global Dygraph:false */\n/*global DygraphLayout:false */\n\n\n\n/**\n *\n * The data handler is responsible for all data specific operations. All of the\n * series data it receives and returns is always in the unified data format.\n * Initially the unified data is created by the extractSeries method\n * @constructor\n */\nvar DygraphDataHandler = function () {\n};\n\nvar handler = DygraphDataHandler;\n\n/**\n * X-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.X = 0;\n\n/**\n * Y-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.Y = 1;\n\n/**\n * Extras-value array index constant for unified data samples.\n * @const\n * @type {number}\n */\nhandler.EXTRAS = 2;\n\n/**\n * Extracts one series from the raw data (a 2D array) into an array of the\n * unified data format.\n * This is where undesirable points (i.e. negative values on log scales and\n * missing values through which we wish to connect lines) are dropped.\n * TODO(danvk): the \"missing values\" bit above doesn't seem right.\n *\n * @param {!Array.<Array>} rawData The raw data passed into dygraphs where\n *     rawData[i] = [x,ySeries1,...,ySeriesN].\n * @param {!number} seriesIndex Index of the series to extract. All other\n *     series should be ignored.\n * @param {!DygraphOptions} options Dygraph options.\n * @return {Array.<[!number,?number,?]>} The series in the unified data format\n *     where series[i] = [x,y,{extras}].\n */\nhandler.prototype.extractSeries = function(rawData, seriesIndex, options) {\n};\n\n/**\n * Converts a series to a Point array.  The resulting point array must be\n * returned in increasing order of idx property.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!string} setName Name of the series.\n * @param {!number} boundaryIdStart Index offset of the first point, equal to the\n *          number of skipped points left of the date window minimum (if any).\n * @return {!Array.<Dygraph.PointType>} List of points for this series.\n */\nhandler.prototype.seriesToPoints = function(series, setName, boundaryIdStart) {\n  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In\n  // fact,\n  // on chrome+linux, they are 6 times more expensive than iterating through\n  // the\n  // points and drawing the lines. The brunt of the cost comes from allocating\n  // the |point| structures.\n  var points = [];\n  for ( var i = 0; i < series.length; ++i) {\n    var item = series[i];\n    var yraw = item[1];\n    var yval = yraw === null ? null : handler.parseFloat(yraw);\n    var point = {\n      x : NaN,\n      y : NaN,\n      xval : handler.parseFloat(item[0]),\n      yval : yval,\n      name : setName, // TODO(danvk): is this really necessary?\n      idx : i + boundaryIdStart\n    };\n    points.push(point);\n  }\n  this.onPointsCreated_(series, points);\n  return points;\n};\n\n/**\n * Callback called for each series after the series points have been generated\n * which will later be used by the plotters to draw the graph.\n * Here data may be added to the seriesPoints which is needed by the plotters.\n * The indexes of series and points are in sync meaning the original data\n * sample for series[i] is points[i].\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x,y,{extras}].\n * @param {!Array.<Dygraph.PointType>} points The corresponding points passed\n *     to the plotter.\n * @protected\n */\nhandler.prototype.onPointsCreated_ = function(series, points) {\n};\n\n/**\n * Calculates the rolling average of a data set.\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *          data format where series[i] = [x,y,{extras}].\n * @param {!number} rollPeriod The number of points over which to average the data\n * @param {!DygraphOptions} options The dygraph options.\n * @return {!Array.<[!number,?number,?]>} the rolled series.\n */\nhandler.prototype.rollingAverage = function(series, rollPeriod, options) {\n};\n\n/**\n * Computes the range of the data series (including confidence intervals).\n *\n * @param {!Array.<[!number,?number,?]>} series The series in the unified\n *     data format where series[i] = [x, y, {extras}].\n * @param {!Array.<number>} dateWindow The x-value range to display with\n *     the format: [min, max].\n * @param {!DygraphOptions} options The dygraph options.\n * @return {Array.<number>} The low and high extremes of the series in the\n *     given window with the format: [low, high].\n */\nhandler.prototype.getExtremeYValues = function(series, dateWindow, options) {\n};\n\n/**\n * Callback called for each series after the layouting data has been\n * calculated before the series is drawn. Here normalized positioning data\n * should be calculated for the extras of each point.\n *\n * @param {!Array.<Dygraph.PointType>} points The points passed to\n *          the plotter.\n * @param {!Object} axis The axis on which the series will be plotted.\n * @param {!boolean} logscale Weather or not to use a logscale.\n */\nhandler.prototype.onLineEvaluated = function(points, axis, logscale) {\n};\n\n/**\n * Optimized replacement for parseFloat, which was way too slow when almost\n * all values were type number, with few edge cases, none of which were strings.\n * @param {?number} val\n * @return {number}\n * @protected\n */\nhandler.parseFloat = function(val) {\n  // parseFloat(null) is NaN\n  if (val === null) {\n    return NaN;\n  }\n\n  // Assume it's a number or NaN. If it's something else, I'll be shocked.\n  return val;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphDataHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvZGF0YWhhbmRsZXIuanM/NDgwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBtYW5hZ21lbnQgb2YgZGF0YSBoYW5kbGVyc1xuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqXG4gKiBUaGUgaWRlYSBpcyB0byBkZWZpbmUgYSBjb21tb24sIGdlbmVyaWMgZGF0YSBmb3JtYXQgdGhhdCB3b3JrcyBmb3IgYWxsIGRhdGFcbiAqIHN0cnVjdHVyZXMgc3VwcG9ydGVkIGJ5IGR5Z3JhcGhzLiBUbyBtYWtlIHRoaXMgcG9zc2libGUsIHRoZSBEYXRhSGFuZGxlclxuICogaW50ZXJmYWNlIGlzIGludHJvZHVjZWQuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUsIHRoYXQgZHlncmFwaCBpdHNlbGYgY2FuIHdvcmtcbiAqIHdpdGggdGhlIHNhbWUgbG9naWMgZm9yIGV2ZXJ5IGRhdGEgdHlwZSBpbmRlcGVuZGVudCBvZiB0aGUgYWN0dWFsIGZvcm1hdCBhbmRcbiAqIHRoZSBEYXRhSGFuZGxlciB0YWtlcyBjYXJlIG9mIHRoZSBkYXRhIGZvcm1hdCBzcGVjaWZpYyBqb2JzLlxuICogRGF0YUhhbmRsZXJzIGFyZSBpbXBsZW1lbnRlZCBmb3IgYWxsIGRhdGEgdHlwZXMgc3VwcG9ydGVkIGJ5IER5Z3JhcGhzIGFuZFxuICogcmV0dXJuIER5Z3JhcGhzIGNvbXBsaWFudCBmb3JtYXRzLlxuICogQnkgZGVmYXVsdCB0aGUgY29ycmVjdCBEYXRhSGFuZGxlciBpcyBjaG9zZW4gYmFzZWQgb24gdGhlIG9wdGlvbnMgc2V0LlxuICogT3B0aW9uYWxseSB0aGUgdXNlciBtYXkgdXNlIGhpcyBvd24gRGF0YUhhbmRsZXIgKHNpbWlsYXIgdG8gdGhlIHBsdWdpblxuICogc3lzdGVtKS5cbiAqXG4gKlxuICogVGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQgcmV0dXJlbmQgYnkgZWFjaCBoYW5kbGVyIGlzIGRlZmluZWQgYXMgc286XG4gKiBzZXJpZXNbbl1bcG9pbnRdID0gW3gseSwoZXh0cmFzKV1cbiAqXG4gKiBUaGlzIGZvcm1hdCBjb250YWlucyB0aGUgY29tbW9uIGJhc2lzIHRoYXQgaXMgbmVlZGVkIHRvIGRyYXcgYSBzaW1wbGUgbGluZVxuICogc2VyaWVzIGV4dGVuZGVkIGJ5IG9wdGlvbmFsIGV4dHJhcyBmb3IgbW9yZSBjb21wbGV4IGdyYXBoaW5nIHR5cGVzLiBJdFxuICogY29udGFpbnMgYSBwcmltaXRpdmUgeCB2YWx1ZSBhcyBmaXJzdCBhcnJheSBlbnRyeSwgYSBwcmltaXRpdmUgeSB2YWx1ZSBhc1xuICogc2Vjb25kIGFycmF5IGVudHJ5IGFuZCBhbiBvcHRpb25hbCBleHRyYXMgb2JqZWN0IGZvciBhZGRpdGlvbmFsIGRhdGEgbmVlZGVkLlxuICpcbiAqIHggbXVzdCBhbHdheXMgYmUgYSBudW1iZXIuXG4gKiB5IG11c3QgYWx3YXlzIGJlIGEgbnVtYmVyLCBOYU4gb2YgdHlwZSBudW1iZXIgb3IgbnVsbC5cbiAqIGV4dHJhcyBpcyBvcHRpb25hbCBhbmQgbXVzdCBiZSBpbnRlcnByZXRlZCBieSB0aGUgRGF0YUhhbmRsZXIuIEl0IG1heSBiZSBvZlxuICogYW55IHR5cGUuXG4gKlxuICogSW4gcHJhY3RpY2UgdGhpcyBtaWdodCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKiBkZWZhdWx0OiBbeCwgeVZhbF1cbiAqIGVycm9yQmFyIC8gY3VzdG9tQmFyOiBbeCwgeVZhbCwgW3lUb3BWYXJpYW5jZSwgeUJvdHRvbVZhcmlhbmNlXSBdXG4gKlxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG4vKmdsb2JhbCBEeWdyYXBoTGF5b3V0OmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBUaGUgZGF0YSBoYW5kbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgZGF0YSBzcGVjaWZpYyBvcGVyYXRpb25zLiBBbGwgb2YgdGhlXG4gKiBzZXJpZXMgZGF0YSBpdCByZWNlaXZlcyBhbmQgcmV0dXJucyBpcyBhbHdheXMgaW4gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gKiBJbml0aWFsbHkgdGhlIHVuaWZpZWQgZGF0YSBpcyBjcmVhdGVkIGJ5IHRoZSBleHRyYWN0U2VyaWVzIG1ldGhvZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEeWdyYXBoRGF0YUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG52YXIgaGFuZGxlciA9IER5Z3JhcGhEYXRhSGFuZGxlcjtcblxuLyoqXG4gKiBYLXZhbHVlIGFycmF5IGluZGV4IGNvbnN0YW50IGZvciB1bmlmaWVkIGRhdGEgc2FtcGxlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuaGFuZGxlci5YID0gMDtcblxuLyoqXG4gKiBZLXZhbHVlIGFycmF5IGluZGV4IGNvbnN0YW50IGZvciB1bmlmaWVkIGRhdGEgc2FtcGxlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuaGFuZGxlci5ZID0gMTtcblxuLyoqXG4gKiBFeHRyYXMtdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLkVYVFJBUyA9IDI7XG5cbi8qKlxuICogRXh0cmFjdHMgb25lIHNlcmllcyBmcm9tIHRoZSByYXcgZGF0YSAoYSAyRCBhcnJheSkgaW50byBhbiBhcnJheSBvZiB0aGVcbiAqIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gKiBUaGlzIGlzIHdoZXJlIHVuZGVzaXJhYmxlIHBvaW50cyAoaS5lLiBuZWdhdGl2ZSB2YWx1ZXMgb24gbG9nIHNjYWxlcyBhbmRcbiAqIG1pc3NpbmcgdmFsdWVzIHRocm91Z2ggd2hpY2ggd2Ugd2lzaCB0byBjb25uZWN0IGxpbmVzKSBhcmUgZHJvcHBlZC5cbiAqIFRPRE8oZGFudmspOiB0aGUgXCJtaXNzaW5nIHZhbHVlc1wiIGJpdCBhYm92ZSBkb2Vzbid0IHNlZW0gcmlnaHQuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmVcbiAqICAgICByYXdEYXRhW2ldID0gW3gseVNlcmllczEsLi4uLHlTZXJpZXNOXS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gc2VyaWVzSW5kZXggSW5kZXggb2YgdGhlIHNlcmllcyB0byBleHRyYWN0LiBBbGwgb3RoZXJcbiAqICAgICBzZXJpZXMgc2hvdWxkIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0geyFEeWdyYXBoT3B0aW9uc30gb3B0aW9ucyBEeWdyYXBoIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXRcbiAqICAgICB3aGVyZSBzZXJpZXNbaV0gPSBbeCx5LHtleHRyYXN9XS5cbiAqL1xuaGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIHNlcmllc0luZGV4LCBvcHRpb25zKSB7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2VyaWVzIHRvIGEgUG9pbnQgYXJyYXkuICBUaGUgcmVzdWx0aW5nIHBvaW50IGFycmF5IG11c3QgYmVcbiAqIHJldHVybmVkIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgaWR4IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshc3RyaW5nfSBzZXROYW1lIE5hbWUgb2YgdGhlIHNlcmllcy5cbiAqIEBwYXJhbSB7IW51bWJlcn0gYm91bmRhcnlJZFN0YXJ0IEluZGV4IG9mZnNldCBvZiB0aGUgZmlyc3QgcG9pbnQsIGVxdWFsIHRvIHRoZVxuICogICAgICAgICAgbnVtYmVyIG9mIHNraXBwZWQgcG9pbnRzIGxlZnQgb2YgdGhlIGRhdGUgd2luZG93IG1pbmltdW0gKGlmIGFueSkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gTGlzdCBvZiBwb2ludHMgZm9yIHRoaXMgc2VyaWVzLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5zZXJpZXNUb1BvaW50cyA9IGZ1bmN0aW9uKHNlcmllcywgc2V0TmFtZSwgYm91bmRhcnlJZFN0YXJ0KSB7XG4gIC8vIFRPRE8oYmhzKTogdGhlc2UgbG9vcHMgYXJlIGEgaG90LXNwb3QgZm9yIGhpZ2gtcG9pbnQtY291bnQgY2hhcnRzLiBJblxuICAvLyBmYWN0LFxuICAvLyBvbiBjaHJvbWUrbGludXgsIHRoZXkgYXJlIDYgdGltZXMgbW9yZSBleHBlbnNpdmUgdGhhbiBpdGVyYXRpbmcgdGhyb3VnaFxuICAvLyB0aGVcbiAgLy8gcG9pbnRzIGFuZCBkcmF3aW5nIHRoZSBsaW5lcy4gVGhlIGJydW50IG9mIHRoZSBjb3N0IGNvbWVzIGZyb20gYWxsb2NhdGluZ1xuICAvLyB0aGUgfHBvaW50fCBzdHJ1Y3R1cmVzLlxuICB2YXIgcG9pbnRzID0gW107XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpdGVtID0gc2VyaWVzW2ldO1xuICAgIHZhciB5cmF3ID0gaXRlbVsxXTtcbiAgICB2YXIgeXZhbCA9IHlyYXcgPT09IG51bGwgPyBudWxsIDogaGFuZGxlci5wYXJzZUZsb2F0KHlyYXcpO1xuICAgIHZhciBwb2ludCA9IHtcbiAgICAgIHggOiBOYU4sXG4gICAgICB5IDogTmFOLFxuICAgICAgeHZhbCA6IGhhbmRsZXIucGFyc2VGbG9hdChpdGVtWzBdKSxcbiAgICAgIHl2YWwgOiB5dmFsLFxuICAgICAgbmFtZSA6IHNldE5hbWUsIC8vIFRPRE8oZGFudmspOiBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/XG4gICAgICBpZHggOiBpICsgYm91bmRhcnlJZFN0YXJ0XG4gICAgfTtcbiAgICBwb2ludHMucHVzaChwb2ludCk7XG4gIH1cbiAgdGhpcy5vblBvaW50c0NyZWF0ZWRfKHNlcmllcywgcG9pbnRzKTtcbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgY2FsbGVkIGZvciBlYWNoIHNlcmllcyBhZnRlciB0aGUgc2VyaWVzIHBvaW50cyBoYXZlIGJlZW4gZ2VuZXJhdGVkXG4gKiB3aGljaCB3aWxsIGxhdGVyIGJlIHVzZWQgYnkgdGhlIHBsb3R0ZXJzIHRvIGRyYXcgdGhlIGdyYXBoLlxuICogSGVyZSBkYXRhIG1heSBiZSBhZGRlZCB0byB0aGUgc2VyaWVzUG9pbnRzIHdoaWNoIGlzIG5lZWRlZCBieSB0aGUgcGxvdHRlcnMuXG4gKiBUaGUgaW5kZXhlcyBvZiBzZXJpZXMgYW5kIHBvaW50cyBhcmUgaW4gc3luYyBtZWFuaW5nIHRoZSBvcmlnaW5hbCBkYXRhXG4gKiBzYW1wbGUgZm9yIHNlcmllc1tpXSBpcyBwb2ludHNbaV0uXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFRoZSBjb3JyZXNwb25kaW5nIHBvaW50cyBwYXNzZWRcbiAqICAgICB0byB0aGUgcGxvdHRlci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuaGFuZGxlci5wcm90b3R5cGUub25Qb2ludHNDcmVhdGVkXyA9IGZ1bmN0aW9uKHNlcmllcywgcG9pbnRzKSB7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHJvbGxpbmcgYXZlcmFnZSBvZiBhIGRhdGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshbnVtYmVyfSByb2xsUGVyaW9kIFRoZSBudW1iZXIgb2YgcG9pbnRzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSB0aGUgZGF0YVxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgVGhlIGR5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgc2VyaWVzIChpbmNsdWRpbmcgY29uZmlkZW5jZSBpbnRlcnZhbHMpLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWRcbiAqICAgICBkYXRhIGZvcm1hdCB3aGVyZSBzZXJpZXNbaV0gPSBbeCwgeSwge2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGRhdGVXaW5kb3cgVGhlIHgtdmFsdWUgcmFuZ2UgdG8gZGlzcGxheSB3aXRoXG4gKiAgICAgdGhlIGZvcm1hdDogW21pbiwgbWF4XS5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhPcHRpb25zfSBvcHRpb25zIFRoZSBkeWdyYXBoIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxvdyBhbmQgaGlnaCBleHRyZW1lcyBvZiB0aGUgc2VyaWVzIGluIHRoZVxuICogICAgIGdpdmVuIHdpbmRvdyB3aXRoIHRoZSBmb3JtYXQ6IFtsb3csIGhpZ2hdLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdywgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayBjYWxsZWQgZm9yIGVhY2ggc2VyaWVzIGFmdGVyIHRoZSBsYXlvdXRpbmcgZGF0YSBoYXMgYmVlblxuICogY2FsY3VsYXRlZCBiZWZvcmUgdGhlIHNlcmllcyBpcyBkcmF3bi4gSGVyZSBub3JtYWxpemVkIHBvc2l0aW9uaW5nIGRhdGFcbiAqIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZvciB0aGUgZXh0cmFzIG9mIGVhY2ggcG9pbnQuXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFRoZSBwb2ludHMgcGFzc2VkIHRvXG4gKiAgICAgICAgICB0aGUgcGxvdHRlci5cbiAqIEBwYXJhbSB7IU9iamVjdH0gYXhpcyBUaGUgYXhpcyBvbiB3aGljaCB0aGUgc2VyaWVzIHdpbGwgYmUgcGxvdHRlZC5cbiAqIEBwYXJhbSB7IWJvb2xlYW59IGxvZ3NjYWxlIFdlYXRoZXIgb3Igbm90IHRvIHVzZSBhIGxvZ3NjYWxlLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5vbkxpbmVFdmFsdWF0ZWQgPSBmdW5jdGlvbihwb2ludHMsIGF4aXMsIGxvZ3NjYWxlKSB7XG59O1xuXG4vKipcbiAqIE9wdGltaXplZCByZXBsYWNlbWVudCBmb3IgcGFyc2VGbG9hdCwgd2hpY2ggd2FzIHdheSB0b28gc2xvdyB3aGVuIGFsbW9zdFxuICogYWxsIHZhbHVlcyB3ZXJlIHR5cGUgbnVtYmVyLCB3aXRoIGZldyBlZGdlIGNhc2VzLCBub25lIG9mIHdoaWNoIHdlcmUgc3RyaW5ncy5cbiAqIEBwYXJhbSB7P251bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmhhbmRsZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAvLyBwYXJzZUZsb2F0KG51bGwpIGlzIE5hTlxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8vIEFzc3VtZSBpdCdzIGEgbnVtYmVyIG9yIE5hTi4gSWYgaXQncyBzb21ldGhpbmcgZWxzZSwgSSdsbCBiZSBzaG9ja2VkLlxuICByZXR1cm4gdmFsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRHlncmFwaERhdGFIYW5kbGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _dygraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - error bars\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It\'s based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n\n/**\n * @constructor\n *\n * This gets called when there are "new points" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart\'s DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\nvar DygraphCanvasRenderer = function(dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n\n  this.height = dygraph.height_;\n  this.width = dygraph.width_;\n\n  // --- check whether everything is ok before we return\n  if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* isCanvasSupported */ "B"](this.element)) {\n    throw "Canvas is not supported.";\n  }\n\n  // internal state\n  this.area = layout.getPlotArea();\n\n  // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don\'t overdraw.\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\nDygraphCanvasRenderer.prototype.clear = function() {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, error bars, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\nDygraphCanvasRenderer.prototype.render = function() {\n  // attaches point.canvas{x,y}\n  this._updatePoints();\n\n  // actually draws the chart.\n  this._renderLineChart();\n};\n\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it\'s false, the predicate will\n * skip over points with missing yVals.\n */\nDygraphCanvasRenderer._getIteratorPredicate = function(connectSeparatedPoints) {\n  return connectSeparatedPoints ?\n      DygraphCanvasRenderer._predicateThatSkipsEmptyPoints :\n      null;\n};\n\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints =\n    function(array, idx) {\n  return array[idx].yval !== null;\n};\n\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawStyledLine = function(e,\n    color, strokeWidth, strokePattern, drawPoints,\n    drawPointCallback, pointSize) {\n  var g = e.dygraph;\n  // TODO(konigsberg): Compute attributes outside this method call.\n  var stepPlot = g.getBooleanOption("stepPlot", e.setName);\n\n  if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* isArrayLike */ "A"](strokePattern)) {\n    strokePattern = null;\n  }\n\n  var drawGapPoints = g.getBooleanOption(\'drawGapEdgePoints\', e.setName);\n\n  var points = e.points;\n  var setName = e.setName;\n  var iter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* createIterator */ "n"](points, 0, points.length,\n      DygraphCanvasRenderer._getIteratorPredicate(\n          g.getBooleanOption("connectSeparatedPoints", setName)));\n\n  var stroking = strokePattern && (strokePattern.length >= 2);\n\n  var ctx = e.drawingContext;\n  ctx.save();\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(\n      e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n  DygraphCanvasRenderer._drawPointsOnLine(\n      e, pointsOnLine, drawPointCallback, color, pointSize);\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n\n  ctx.restore();\n};\n\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawSeries = function(e,\n    iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n  var point; // the point being processed in the while loop\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth;\n\n  // NOTE: we break the iterator\'s encapsulation here for about a 25% speedup.\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n      if (i == limit) break;\n      point = arr[i];\n    }\n\n    // FIXME: The \'canvasy != canvasy\' test here catches NaN values but the test\n    // doesn\'t catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n\n        var isNextCanvasYNullOrNaN = nextCanvasY === null ||\n            nextCanvasY != nextCanvasY;\n        isIsolated = (prevCanvasX === null && isNextCanvasYNullOrNaN);\n        if (drawGapPoints) {\n          // Also consider a point to be "isolated" if it\'s adjacent to a\n          // null point, excluding the graph edges.\n          if ((!first && prevCanvasX === null) ||\n              (iter.hasNext && isNextCanvasYNullOrNaN)) {\n            isIsolated = true;\n          }\n        }\n      }\n\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n    first = false;\n  }\n  ctx.stroke();\n  return pointsOnLine;\n};\n\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the "drawPoints" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\nDygraphCanvasRenderer._drawPointsOnLine = function(\n    e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph,\n        e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\nDygraphCanvasRenderer.prototype._updatePoints = function() {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can\'t specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n\n/**\n * Add canvas Actually draw the lines chart, including error bars.\n *\n * This function can only be called if DygraphLayout\'s points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object\'s\n *     elementContext.\n * @private\n */\nDygraphCanvasRenderer.prototype._renderLineChart = function(opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n\n  this.colors = this.dygraph_.colorsMap_;\n\n  // Determine which series have specialized plotters.\n  var plotter_attr = this.dygraph_.getOption("plotter");\n  var plotters = plotter_attr;\n  if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* isArrayLike */ "A"](plotters)) {\n    plotters = [plotters];\n  }\n\n  var setPlotters = {};  // series name -> plotter fn.\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption("plotter", setName);\n    if (setPlotter == plotter_attr) continue;  // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = (i == plotters.length - 1);\n\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n\n      var points = sets[j];\n\n      // Only throw in the specialized plotters on the last iteration.\n      var p = plotter;\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don\'t use the standard plotters in this case.\n          continue;\n        }\n      }\n\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption("strokeWidth", setName);\n\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function(e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n\n  fillPlotter: function(e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n\n  errorPlotter: function(e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\nDygraphCanvasRenderer._linePlotter = function(e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth;\n\n  // TODO(danvk): Check if there\'s any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n  var borderWidth = g.getNumericOption("strokeBorderWidth", setName);\n  var drawPointCallback = g.getOption("drawPointCallback", setName) ||\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* Circles */ "a"].DEFAULT;\n  var strokePattern = g.getOption("strokePattern", setName);\n  var drawPoints = g.getBooleanOption("drawPoints", setName);\n  var pointSize = g.getNumericOption("pointSize", setName);\n\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e,\n        g.getOption("strokeBorderColor", setName),\n        strokeWidth + 2 * borderWidth,\n        strokePattern,\n        drawPoints,\n        drawPointCallback,\n        pointSize\n        );\n  }\n\n  DygraphCanvasRenderer._drawStyledLine(e,\n      e.color,\n      strokeWidth,\n      strokePattern,\n      drawPoints,\n      drawPointCallback,\n      pointSize\n  );\n};\n\n/**\n * Draws the shaded error bars/confidence intervals for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the error bars for all series.\n * @private\n */\nDygraphCanvasRenderer._errorPlotter = function(e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption("errorBars") ||\n      g.getBooleanOption("customBars");\n  if (!errorBars) return;\n\n  var fillGraph = g.getBooleanOption("fillGraph", setName);\n  if (fillGraph) {\n    console.warn("Can\'t use fillGraph option with error bars");\n  }\n\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption(\'fillAlpha\', setName);\n  var stepPlot = g.getBooleanOption("stepPlot", setName);\n  var points = e.points;\n\n  var iter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* createIterator */ "n"](points, 0, points.length,\n      DygraphCanvasRenderer._getIteratorPredicate(\n          g.getBooleanOption("connectSeparatedPoints", setName)));\n\n  var newYs;\n\n  // setup graphics context\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1];\n  // should be same color as the lines but only 15% opaque.\n  var rgb = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* toRGB_ */ "Q"](color);\n  var err_color =\n      \'rgba(\' + rgb.r + \',\' + rgb.g + \',\' + rgb.b + \',\' + fillAlpha + \')\';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n\n  var isNullUndefinedOrNaN = function(x) {\n    return (x === null ||\n            x === undefined ||\n            isNaN(x));\n  };\n\n  while (iter.hasNext) {\n    var point = iter.next();\n    if ((!stepPlot && isNullUndefinedOrNaN(point.y)) ||\n        (stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY))) {\n      prevX = NaN;\n      continue;\n    }\n\n    newYs = [ point.y_bottom, point.y_top ];\n    if (stepPlot) {\n      prevY = point.y;\n    }\n\n    // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n  ctx.fill();\n};\n\n\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven\'t changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\nDygraphCanvasRenderer._fastCanvasProxy = function(context) {\n  var pendingActions = [];  // array of [type, x, y] tuples\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n\n  var LINE_TO = 1,\n      MOVE_TO = 2;\n\n  var actionCount = 0;  // number of moveTos and lineTos passed to context.\n\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n  var compressActions = function(opt_losslessOnly) {\n    if (pendingActions.length <= 1) return;\n\n    // Lossless compression: drop inconsequential moveTos.\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    }\n\n    // Lossless compression: ... drop consecutive moveTos ...\n    for (var i = 0; i < pendingActions.length - 1; /* incremented internally */) {\n      var action = pendingActions[i];\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Lossy compression: ... drop all but the extreme y-values ...\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null, maxIdx = null;\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n      var minAction = pendingActions[minIdx],\n          maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n\n  var flushActions = function(opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n\n  var addAction = function(action, x, y) {\n    var rx = Math.round(x);\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it\'s essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = (lastRoundedX - lastFlushedX > 1),\n          hasGapOnRight = (rx - lastRoundedX > 1),\n          hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n    pendingActions.push([action, x, y]);\n  };\n\n  return {\n    moveTo: function(x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function(x, y) {\n      addAction(LINE_TO, x, y);\n    },\n\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke:    function() { flushActions(true); context.stroke(); },\n    fill:      function() { flushActions(true); context.fill(); },\n    beginPath: function() { flushActions(true); context.beginPath(); },\n    closePath: function() { flushActions(true); context.closePath(); },\n\n    _count: function() { return actionCount; }\n  };\n};\n\n/**\n * Draws the shaded regions when "fillGraph" is set. Not to be confused with\n * error bars.\n *\n * For stacked charts, it\'s more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it\'s asked to draw, then ignores all the other series.\n *\n * @private\n */\nDygraphCanvasRenderer._fillPlotter = function(e) {\n  // Skip if we\'re drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return;\n\n  // We\'ll handle all the series at once, not one-by-one.\n  if (e.seriesIndex !== 0) return;\n\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1);  // remove x-axis\n\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n\n  var anySeriesFilled = (function() {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption("fillGraph", setNames[i])) return true;\n    }\n    return false;\n  })();\n\n  if (!anySeriesFilled) return;\n\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n\n  var stackedGraph = g.getBooleanOption("stackedGraph");\n  var colors = g.getColors();\n\n  // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  // Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  };\n\n  // process sets in reverse order (needed for stacked graphs)\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption(\'fillGraph\', setName)) continue;\n\n    var fillAlpha = g.getNumericOption(\'fillAlpha\', setName);\n    var stepPlot = g.getBooleanOption(\'stepPlot\', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n    var points = sets[setIdx];\n    var iter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* createIterator */ "n"](points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption("connectSeparatedPoints", setName)));\n\n    // setup graphics context\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs;\n    // should be same color as the lines but only 15% opaque.\n    var rgb = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* toRGB_ */ "Q"](color);\n    var err_color =\n        \'rgba(\' + rgb.r + \',\' + rgb.g + \',\' + rgb.b + \',\' + fillAlpha + \')\';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || _dygraph__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this "back path" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n    var pathBack = [];\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* isOK */ "E"](point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if(prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n        newYs = [ point.canvasy, lastY ];\n\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [ point.canvasy, axisY ];\n          } else {\n            baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [ area.y + area.h, axisY ];\n        } else {\n          newYs = [ point.canvasy, axisY ];\n        }\n      }\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        }\n\n        // Record the baseline for the reverse path.\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n  }\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (DygraphCanvasRenderer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC1jYW52YXMuanM/NTI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwNiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGVcbiAqIG5lZWRzIG9mIGR5Z3JhcGhzLlxuICpcbiAqIEluIHBhcnRpY3VsYXIsIHN1cHBvcnQgZm9yOlxuICogLSBncmlkIG92ZXJsYXlzXG4gKiAtIGVycm9yIGJhcnNcbiAqIC0gZHlncmFwaHMgYXR0cmlidXRlIHN5c3RlbVxuICovXG5cbi8qKlxuICogVGhlIER5Z3JhcGhDYW52YXNSZW5kZXJlciBjbGFzcyBkb2VzIHRoZSBhY3R1YWwgcmVuZGVyaW5nIG9mIHRoZSBjaGFydCBvbnRvXG4gKiBhIGNhbnZhcy4gSXQncyBiYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGNhbnZhcyB0byBhdHRhY2ggdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50Q29udGV4dCBUaGUgMmQgY29udGV4dCBvZiB0aGUgY2FudmFzIChpbmplY3RlZCBzbyBpdFxuICogY2FuIGJlIG1vY2tlZCBmb3IgdGVzdGluZy4pXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFRoZSBEeWdyYXBoTGF5b3V0IG9iamVjdCBmb3IgdGhpcyBncmFwaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGggZnJvbSAnLi9keWdyYXBoJztcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgXCJuZXcgcG9pbnRzXCIgdG8gY2hhcnQuIFRoaXMgaXMgZ2VuZXJhbGx5IHRoZVxuICogY2FzZSB3aGVuIHRoZSB1bmRlcmx5aW5nIGRhdGEgYmVpbmcgY2hhcnRlZCBoYXMgY2hhbmdlZC4gSXQgaXMgX25vdF8gY2FsbGVkXG4gKiBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGUgdXNlciBoYXMgem9vbWVkIG9yIGlzIHBhbm5pbmcgdGhlIHZpZXcuXG4gKlxuICogVGhlIGNoYXJ0IGNhbnZhcyBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgYnkgdGhlIER5Z3JhcGggb2JqZWN0LiBUaGVcbiAqIHJlbmRlcmVyIHNpbXBseSBnZXRzIGEgZHJhd2luZyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhpcyByZW5kZXJlciBiZWxvbmdzLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCBUaGUgJmx0O2NhbnZhcyZndDsgRE9NIGVsZW1lbnQgb24gd2hpY2ggdG8gZHJhdy5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBlbGVtZW50Q29udGV4dCBUaGUgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtIHtEeWdyYXBoTGF5b3V0fSBsYXlvdXQgVGhlIGNoYXJ0J3MgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVE9ETyhkYW52ayk6IHJlbW92ZSB0aGUgZWxlbWVudENvbnRleHQgcHJvcGVydHkuXG4gKi9cbnZhciBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbihkeWdyYXBoLCBlbGVtZW50LCBlbGVtZW50Q29udGV4dCwgbGF5b3V0KSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmVsZW1lbnRDb250ZXh0ID0gZWxlbWVudENvbnRleHQ7XG5cbiAgdGhpcy5oZWlnaHQgPSBkeWdyYXBoLmhlaWdodF87XG4gIHRoaXMud2lkdGggPSBkeWdyYXBoLndpZHRoXztcblxuICAvLyAtLS0gY2hlY2sgd2hldGhlciBldmVyeXRoaW5nIGlzIG9rIGJlZm9yZSB3ZSByZXR1cm5cbiAgaWYgKCF1dGlscy5pc0NhbnZhc1N1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgdGhyb3cgXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgfVxuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIHRoaXMuYXJlYSA9IGxheW91dC5nZXRQbG90QXJlYSgpO1xuXG4gIC8vIFNldCB1cCBhIGNsaXBwaW5nIGFyZWEgZm9yIHRoZSBjYW52YXMgKGFuZCB0aGUgaW50ZXJhY3Rpb24gY2FudmFzKS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgb3ZlcmRyYXcuXG4gIHZhciBjdHggPSB0aGlzLmR5Z3JhcGhfLmNhbnZhc19jdHhfO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHRoaXMuYXJlYS54LCB0aGlzLmFyZWEueSwgdGhpcy5hcmVhLncsIHRoaXMuYXJlYS5oKTtcbiAgY3R4LmNsaXAoKTtcblxuICBjdHggPSB0aGlzLmR5Z3JhcGhfLmhpZGRlbl9jdHhfO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHRoaXMuYXJlYS54LCB0aGlzLmFyZWEueSwgdGhpcy5hcmVhLncsIHRoaXMuYXJlYS5oKTtcbiAgY3R4LmNsaXAoKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCBhbGwgY2hhcnQgY29udGVudCBhbmQgRE9NIGVsZW1lbnRzLlxuICogVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYmVmb3JlIHJlbmRlcigpIG9uIGV2ZXJ5IGZyYW1lLCBpbmNsdWRpbmdcbiAqIGR1cmluZyB6b29tcyBhbmQgcGFucy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50Q29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBldmVyeXRoaW5nIG9uIHRoZSBjaGFydCwgaW5jbHVkaW5nXG4gKiBsaW5lcywgZXJyb3IgYmFycywgZmlsbHMgYW5kIGF4ZXMuXG4gKiBJdCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY2xlYXIoKSBvbiBldmVyeSBmcmFtZSwgaW5jbHVkaW5nIGR1cmluZyBwYW5zXG4gKiBhbmQgem9vbXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBhdHRhY2hlcyBwb2ludC5jYW52YXN7eCx5fVxuICB0aGlzLl91cGRhdGVQb2ludHMoKTtcblxuICAvLyBhY3R1YWxseSBkcmF3cyB0aGUgY2hhcnQuXG4gIHRoaXMuX3JlbmRlckxpbmVDaGFydCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZGljYXRlIHRvIGJlIHVzZWQgd2l0aCBhbiBpdGVyYXRvciwgd2hpY2ggd2lsbFxuICogaXRlcmF0ZSBvdmVyIHBvaW50cyBhcHByb3ByaWF0ZWx5LCBkZXBlbmRpbmcgb24gd2hldGhlclxuICogY29ubmVjdFNlcGFyYXRlZFBvaW50cyBpcyB0cnVlLiBXaGVuIGl0J3MgZmFsc2UsIHRoZSBwcmVkaWNhdGUgd2lsbFxuICogc2tpcCBvdmVyIHBvaW50cyB3aXRoIG1pc3NpbmcgeVZhbHMuXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUgPSBmdW5jdGlvbihjb25uZWN0U2VwYXJhdGVkUG9pbnRzKSB7XG4gIHJldHVybiBjb25uZWN0U2VwYXJhdGVkUG9pbnRzID9cbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgOlxuICAgICAgbnVsbDtcbn07XG5cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgPVxuICAgIGZ1bmN0aW9uKGFycmF5LCBpZHgpIHtcbiAgcmV0dXJuIGFycmF5W2lkeF0ueXZhbCAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogRHJhd3MgYSBsaW5lIHdpdGggdGhlIHN0eWxlcyBwYXNzZWQgaW4gYW5kIGNhbGxzIGFsbCB0aGUgZHJhd1BvaW50Q2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZSA9IGZ1bmN0aW9uKGUsXG4gICAgY29sb3IsIHN0cm9rZVdpZHRoLCBzdHJva2VQYXR0ZXJuLCBkcmF3UG9pbnRzLFxuICAgIGRyYXdQb2ludENhbGxiYWNrLCBwb2ludFNpemUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIC8vIFRPRE8oa29uaWdzYmVyZyk6IENvbXB1dGUgYXR0cmlidXRlcyBvdXRzaWRlIHRoaXMgbWV0aG9kIGNhbGwuXG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIGUuc2V0TmFtZSk7XG5cbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShzdHJva2VQYXR0ZXJuKSkge1xuICAgIHN0cm9rZVBhdHRlcm4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGRyYXdHYXBQb2ludHMgPSBnLmdldEJvb2xlYW5PcHRpb24oJ2RyYXdHYXBFZGdlUG9pbnRzJywgZS5zZXROYW1lKTtcblxuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgaXRlciA9IHV0aWxzLmNyZWF0ZUl0ZXJhdG9yKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCxcbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUoXG4gICAgICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiLCBzZXROYW1lKSkpO1xuXG4gIHZhciBzdHJva2luZyA9IHN0cm9rZVBhdHRlcm4gJiYgKHN0cm9rZVBhdHRlcm4ubGVuZ3RoID49IDIpO1xuXG4gIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICBjdHguc2F2ZSgpO1xuICBpZiAoc3Ryb2tpbmcpIHtcbiAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goc3Ryb2tlUGF0dGVybik7XG4gIH1cblxuICB2YXIgcG9pbnRzT25MaW5lID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzKFxuICAgICAgZSwgaXRlciwgc3Ryb2tlV2lkdGgsIHBvaW50U2l6ZSwgZHJhd1BvaW50cywgZHJhd0dhcFBvaW50cywgc3RlcFBsb3QsIGNvbG9yKTtcbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lKFxuICAgICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSk7XG5cbiAgaWYgKHN0cm9raW5nKSB7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZG9lcyB0aGUgYWN0dWFsIGRyYXdpbmcgb2YgbGluZXMgb24gdGhlIGNhbnZhcywgZm9yIGp1c3Qgb25lIHNlcmllcy5cbiAqIFJldHVybnMgYSBsaXN0IG9mIFtjYW52YXN4LCBjYW52YXN5XSBwYWlycyBmb3IgcG9pbnRzIGZvciB3aGljaCBhXG4gKiBkcmF3UG9pbnRDYWxsYmFjayBzaG91bGQgYmUgZmlyZWQuICBUaGVzZSBpbmNsdWRlIGlzb2xhdGVkIHBvaW50cywgb3IgYWxsXG4gKiBwb2ludHMgaWYgZHJhd1BvaW50cz10cnVlLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzID0gZnVuY3Rpb24oZSxcbiAgICBpdGVyLCBzdHJva2VXaWR0aCwgcG9pbnRTaXplLCBkcmF3UG9pbnRzLCBkcmF3R2FwUG9pbnRzLCBzdGVwUGxvdCwgY29sb3IpIHtcblxuICB2YXIgcHJldkNhbnZhc1ggPSBudWxsO1xuICB2YXIgcHJldkNhbnZhc1kgPSBudWxsO1xuICB2YXIgbmV4dENhbnZhc1kgPSBudWxsO1xuICB2YXIgaXNJc29sYXRlZDsgLy8gdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGlzb2xhdGVkIChubyBsaW5lIHNlZ21lbnRzKVxuICB2YXIgcG9pbnQ7IC8vIHRoZSBwb2ludCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHdoaWxlIGxvb3BcbiAgdmFyIHBvaW50c09uTGluZSA9IFtdOyAvLyBBcnJheSBvZiBbY2FudmFzeCwgY2FudmFzeV0gcGFpcnMuXG4gIHZhciBmaXJzdCA9IHRydWU7IC8vIHRoZSBmaXJzdCBjeWNsZSB0aHJvdWdoIHRoZSB3aGlsZSBsb29wXG5cbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblxuICAvLyBOT1RFOiB3ZSBicmVhayB0aGUgaXRlcmF0b3IncyBlbmNhcHN1bGF0aW9uIGhlcmUgZm9yIGFib3V0IGEgMjUlIHNwZWVkdXAuXG4gIHZhciBhcnIgPSBpdGVyLmFycmF5XztcbiAgdmFyIGxpbWl0ID0gaXRlci5lbmRfO1xuICB2YXIgcHJlZGljYXRlID0gaXRlci5wcmVkaWNhdGVfO1xuXG4gIGZvciAodmFyIGkgPSBpdGVyLnN0YXJ0XzsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICBwb2ludCA9IGFycltpXTtcbiAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICB3aGlsZSAoaSA8IGxpbWl0ICYmICFwcmVkaWNhdGUoYXJyLCBpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PSBsaW1pdCkgYnJlYWs7XG4gICAgICBwb2ludCA9IGFycltpXTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogVGhlICdjYW52YXN5ICE9IGNhbnZhc3knIHRlc3QgaGVyZSBjYXRjaGVzIE5hTiB2YWx1ZXMgYnV0IHRoZSB0ZXN0XG4gICAgLy8gZG9lc24ndCBjYXRjaCBJbmZpbml0eSB2YWx1ZXMuIENvdWxkIGNoYW5nZSB0aGlzIHRvXG4gICAgLy8gIWlzRmluaXRlKHBvaW50LmNhbnZhc3kpLCBidXQgSSBhc3N1bWUgaXQgYXZvaWRzIGlzTmFOIGZvciBwZXJmb3JtYW5jZT9cbiAgICBpZiAocG9pbnQuY2FudmFzeSA9PT0gbnVsbCB8fCBwb2ludC5jYW52YXN5ICE9IHBvaW50LmNhbnZhc3kpIHtcbiAgICAgIGlmIChzdGVwUGxvdCAmJiBwcmV2Q2FudmFzWCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBEcmF3IGEgaG9yaXpvbnRhbCBsaW5lIHRvIHRoZSBzdGFydCBvZiB0aGUgbWlzc2luZyBkYXRhXG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldkNhbnZhc1gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2Q2FudmFzWSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHByZXZDYW52YXNZID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNJc29sYXRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGRyYXdHYXBQb2ludHMgfHwgcHJldkNhbnZhc1ggPT09IG51bGwpIHtcbiAgICAgICAgaXRlci5uZXh0SWR4XyA9IGk7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBuZXh0Q2FudmFzWSA9IGl0ZXIuaGFzTmV4dCA/IGl0ZXIucGVlay5jYW52YXN5IDogbnVsbDtcblxuICAgICAgICB2YXIgaXNOZXh0Q2FudmFzWU51bGxPck5hTiA9IG5leHRDYW52YXNZID09PSBudWxsIHx8XG4gICAgICAgICAgICBuZXh0Q2FudmFzWSAhPSBuZXh0Q2FudmFzWTtcbiAgICAgICAgaXNJc29sYXRlZCA9IChwcmV2Q2FudmFzWCA9PT0gbnVsbCAmJiBpc05leHRDYW52YXNZTnVsbE9yTmFOKTtcbiAgICAgICAgaWYgKGRyYXdHYXBQb2ludHMpIHtcbiAgICAgICAgICAvLyBBbHNvIGNvbnNpZGVyIGEgcG9pbnQgdG8gYmUgXCJpc29sYXRlZFwiIGlmIGl0J3MgYWRqYWNlbnQgdG8gYVxuICAgICAgICAgIC8vIG51bGwgcG9pbnQsIGV4Y2x1ZGluZyB0aGUgZ3JhcGggZWRnZXMuXG4gICAgICAgICAgaWYgKCghZmlyc3QgJiYgcHJldkNhbnZhc1ggPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgIChpdGVyLmhhc05leHQgJiYgaXNOZXh0Q2FudmFzWU51bGxPck5hTikpIHtcbiAgICAgICAgICAgIGlzSXNvbGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNhbnZhc1ggIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHByZXZDYW52YXNYLCBwcmV2Q2FudmFzWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYXdQb2ludHMgfHwgaXNJc29sYXRlZCkge1xuICAgICAgICBwb2ludHNPbkxpbmUucHVzaChbcG9pbnQuY2FudmFzeCwgcG9pbnQuY2FudmFzeSwgcG9pbnQuaWR4XSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHBvaW50LmNhbnZhc3g7XG4gICAgICBwcmV2Q2FudmFzWSA9IHBvaW50LmNhbnZhc3k7XG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgY3R4LnN0cm9rZSgpO1xuICByZXR1cm4gcG9pbnRzT25MaW5lO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpcmVzIHRoZSBkcmF3UG9pbnRDYWxsYmFjayBmdW5jdGlvbnMsIHdoaWNoIGRyYXcgZG90cyBvbiB0aGUgcG9pbnRzIGJ5XG4gKiBkZWZhdWx0LiBUaGlzIGdldHMgdXNlZCB3aGVuIHRoZSBcImRyYXdQb2ludHNcIiBvcHRpb24gaXMgc2V0LCBvciB3aGVuIHRoZXJlXG4gKiBhcmUgaXNvbGF0ZWQgcG9pbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lID0gZnVuY3Rpb24oXG4gICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSkge1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcG9pbnRzT25MaW5lLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIgY2IgPSBwb2ludHNPbkxpbmVbaWR4XTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGRyYXdQb2ludENhbGxiYWNrLmNhbGwoZS5keWdyYXBoLFxuICAgICAgICBlLmR5Z3JhcGgsIGUuc2V0TmFtZSwgY3R4LCBjYlswXSwgY2JbMV0sIGNvbG9yLCBwb2ludFNpemUsIGNiWzJdKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGNhbnZhcyBjb29yZGluYXRlcyB0byB0aGUgcG9pbnRzIGFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFVwZGF0ZSBQb2ludHNcbiAgLy8gVE9ETyhkYW52ayk6IGhlcmVcbiAgLy9cbiAgLy8gVE9ETyhiaHMpOiB0aGlzIGxvb3AgaXMgYSBob3Qtc3BvdCBmb3IgaGlnaC1wb2ludC1jb3VudCBjaGFydHMuIFRoZXNlXG4gIC8vIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgcHVzaGVkIGludG8gdGhlIGNhbnZhcyB2aWEgbGluZWFyIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG1hdHJpY2VzLlxuICAvLyBOT1RFKGRhbnZrKTogdGhpcyBpcyB0cmlja2llciB0aGFuIGl0IHNvdW5kcyBhdCBmaXJzdC4gVGhlIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIHRoZSAubW92ZVRvKCkgYW5kIC5saW5lVG8oKSBjYWxscywgYnV0IG11c3QgYmVcbiAgLy8gdW5kb25lIGJlZm9yZSB0aGUgLnN0cm9rZSgpIGNhbGwgdG8gZW5zdXJlIHRoYXQgdGhlIHN0cm9rZSB3aWR0aCBpc1xuICAvLyB1bmFmZmVjdGVkLiAgQW4gYWx0ZXJuYXRpdmUgaXMgdG8gcmVkdWNlIHRoZSBzdHJva2Ugd2lkdGggaW4gdGhlXG4gIC8vIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUgc3BhY2UsIGJ1dCB5b3UgY2FuJ3Qgc3BlY2lmeSBkaWZmZXJlbnQgdmFsdWVzIGZvclxuICAvLyBlYWNoIGRpbWVuc2lvbiAoYXMgeW91IGNhbiB3aXRoIC5zY2FsZSgpKS4gVGhlIHNwZWVkdXAgaGVyZSBpcyB+MTIlLlxuICB2YXIgc2V0cyA9IHRoaXMubGF5b3V0LnBvaW50cztcbiAgZm9yICh2YXIgaSA9IHNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIHBvaW50cyA9IHNldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IHBvaW50cy5sZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBwb2ludCA9IHBvaW50c1tqXTtcbiAgICAgIHBvaW50LmNhbnZhc3ggPSB0aGlzLmFyZWEudyAqIHBvaW50LnggKyB0aGlzLmFyZWEueDtcbiAgICAgIHBvaW50LmNhbnZhc3kgPSB0aGlzLmFyZWEuaCAqIHBvaW50LnkgKyB0aGlzLmFyZWEueTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGNhbnZhcyBBY3R1YWxseSBkcmF3IHRoZSBsaW5lcyBjaGFydCwgaW5jbHVkaW5nIGVycm9yIGJhcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgaWYgRHlncmFwaExheW91dCdzIHBvaW50cyBhcnJheSBoYXMgYmVlblxuICogdXBkYXRlZCB3aXRoIGNhbnZhc3t4LHl9IGF0dHJpYnV0ZXMsIGkuZS4gYnlcbiAqIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fdXBkYXRlUG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgd2hlbiBzcGVjaWZpZWQsIG9ubHkgdGhhdCBzZXJpZXMgd2lsbFxuICogICAgIGJlIGRyYXduLiAoVGhpcyBpcyB1c2VkIGZvciBleHBlZGl0ZWQgcmVkcmF3aW5nIHdpdGggaGlnaGxpZ2h0U2VyaWVzT3B0cylcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBvcHRfY3R4IHdoZW4gc3BlY2lmaWVkLCB0aGUgZHJhd2luZ1xuICogICAgIGNvbnRleHQuICBIb3dldmVyLCBsaW5lcyBhcmUgdHlwaWNhbGx5IGRyYXduIG9uIHRoZSBvYmplY3Qnc1xuICogICAgIGVsZW1lbnRDb250ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyTGluZUNoYXJ0ID0gZnVuY3Rpb24ob3B0X3Nlcmllc05hbWUsIG9wdF9jdHgpIHtcbiAgdmFyIGN0eCA9IG9wdF9jdHggfHwgdGhpcy5lbGVtZW50Q29udGV4dDtcbiAgdmFyIGk7XG5cbiAgdmFyIHNldHMgPSB0aGlzLmxheW91dC5wb2ludHM7XG4gIHZhciBzZXROYW1lcyA9IHRoaXMubGF5b3V0LnNldE5hbWVzO1xuICB2YXIgc2V0TmFtZTtcblxuICB0aGlzLmNvbG9ycyA9IHRoaXMuZHlncmFwaF8uY29sb3JzTWFwXztcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2VyaWVzIGhhdmUgc3BlY2lhbGl6ZWQgcGxvdHRlcnMuXG4gIHZhciBwbG90dGVyX2F0dHIgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInBsb3R0ZXJcIik7XG4gIHZhciBwbG90dGVycyA9IHBsb3R0ZXJfYXR0cjtcbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShwbG90dGVycykpIHtcbiAgICBwbG90dGVycyA9IFtwbG90dGVyc107XG4gIH1cblxuICB2YXIgc2V0UGxvdHRlcnMgPSB7fTsgIC8vIHNlcmllcyBuYW1lIC0+IHBsb3R0ZXIgZm4uXG4gIGZvciAoaSA9IDA7IGkgPCBzZXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHNldE5hbWUgPSBzZXROYW1lc1tpXTtcbiAgICB2YXIgc2V0UGxvdHRlciA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwicGxvdHRlclwiLCBzZXROYW1lKTtcbiAgICBpZiAoc2V0UGxvdHRlciA9PSBwbG90dGVyX2F0dHIpIGNvbnRpbnVlOyAgLy8gbm90IHNwZWNpYWxpemVkLlxuXG4gICAgc2V0UGxvdHRlcnNbc2V0TmFtZV0gPSBzZXRQbG90dGVyO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHBsb3R0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsb3R0ZXIgPSBwbG90dGVyc1tpXTtcbiAgICB2YXIgaXNfbGFzdCA9IChpID09IHBsb3R0ZXJzLmxlbmd0aCAtIDEpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZXROYW1lID0gc2V0TmFtZXNbal07XG4gICAgICBpZiAob3B0X3Nlcmllc05hbWUgJiYgc2V0TmFtZSAhPSBvcHRfc2VyaWVzTmFtZSkgY29udGludWU7XG5cbiAgICAgIHZhciBwb2ludHMgPSBzZXRzW2pdO1xuXG4gICAgICAvLyBPbmx5IHRocm93IGluIHRoZSBzcGVjaWFsaXplZCBwbG90dGVycyBvbiB0aGUgbGFzdCBpdGVyYXRpb24uXG4gICAgICB2YXIgcCA9IHBsb3R0ZXI7XG4gICAgICBpZiAoc2V0TmFtZSBpbiBzZXRQbG90dGVycykge1xuICAgICAgICBpZiAoaXNfbGFzdCkge1xuICAgICAgICAgIHAgPSBzZXRQbG90dGVyc1tzZXROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEb24ndCB1c2UgdGhlIHN0YW5kYXJkIHBsb3R0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yc1tzZXROYW1lXTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwic3Ryb2tlV2lkdGhcIiwgc2V0TmFtZSk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHAoe1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgc2V0TmFtZTogc2V0TmFtZSxcbiAgICAgICAgZHJhd2luZ0NvbnRleHQ6IGN0eCxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGR5Z3JhcGg6IHRoaXMuZHlncmFwaF8sXG4gICAgICAgIGF4aXM6IHRoaXMuZHlncmFwaF8uYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMoc2V0TmFtZSksXG4gICAgICAgIHBsb3RBcmVhOiB0aGlzLmFyZWEsXG4gICAgICAgIHNlcmllc0luZGV4OiBqLFxuICAgICAgICBzZXJpZXNDb3VudDogc2V0cy5sZW5ndGgsXG4gICAgICAgIHNpbmdsZVNlcmllc05hbWU6IG9wdF9zZXJpZXNOYW1lLFxuICAgICAgICBhbGxTZXJpZXNQb2ludHM6IHNldHNcbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3RhbmRhcmQgcGxvdHRlcnMuIFRoZXNlIG1heSBiZSB1c2VkIGJ5IGNsaWVudHMgdmlhIER5Z3JhcGguUGxvdHRlcnMuXG4gKiBTZWUgY29tbWVudHMgdGhlcmUgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9QbG90dGVycyA9IHtcbiAgbGluZVBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2xpbmVQbG90dGVyKGUpO1xuICB9LFxuXG4gIGZpbGxQbG90dGVyOiBmdW5jdGlvbihlKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9maWxsUGxvdHRlcihlKTtcbiAgfSxcblxuICBlcnJvclBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlcihlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQbG90dGVyIHdoaWNoIGRyYXdzIHRoZSBjZW50cmFsIGxpbmVzIGZvciBhIHNlcmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZSA9IGUuc2V0TmFtZTtcbiAgdmFyIHN0cm9rZVdpZHRoID0gZS5zdHJva2VXaWR0aDtcblxuICAvLyBUT0RPKGRhbnZrKTogQ2hlY2sgaWYgdGhlcmUncyBhbnkgcGVyZm9ybWFuY2UgaW1wYWN0IG9mIGp1c3QgY2FsbGluZ1xuICAvLyBnZXRPcHRpb24oKSBpbnNpZGUgb2YgX2RyYXdTdHlsZWRMaW5lLiBQYXNzaW5nIGluIHNvIG1hbnkgcGFyYW1ldGVycyBtYWtlc1xuICAvLyB0aGlzIGNvZGUgYSBiaXQgbmFzdHkuXG4gIHZhciBib3JkZXJXaWR0aCA9IGcuZ2V0TnVtZXJpY09wdGlvbihcInN0cm9rZUJvcmRlcldpZHRoXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50Q2FsbGJhY2sgPSBnLmdldE9wdGlvbihcImRyYXdQb2ludENhbGxiYWNrXCIsIHNldE5hbWUpIHx8XG4gICAgICB1dGlscy5DaXJjbGVzLkRFRkFVTFQ7XG4gIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oXCJzdHJva2VQYXR0ZXJuXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50cyA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcImRyYXdQb2ludHNcIiwgc2V0TmFtZSk7XG4gIHZhciBwb2ludFNpemUgPSBnLmdldE51bWVyaWNPcHRpb24oXCJwb2ludFNpemVcIiwgc2V0TmFtZSk7XG5cbiAgaWYgKGJvcmRlcldpZHRoICYmIHN0cm9rZVdpZHRoKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgICBnLmdldE9wdGlvbihcInN0cm9rZUJvcmRlckNvbG9yXCIsIHNldE5hbWUpLFxuICAgICAgICBzdHJva2VXaWR0aCArIDIgKiBib3JkZXJXaWR0aCxcbiAgICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgICAgZHJhd1BvaW50cyxcbiAgICAgICAgZHJhd1BvaW50Q2FsbGJhY2ssXG4gICAgICAgIHBvaW50U2l6ZVxuICAgICAgICApO1xuICB9XG5cbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgZS5jb2xvcixcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgIGRyYXdQb2ludHMsXG4gICAgICBkcmF3UG9pbnRDYWxsYmFjayxcbiAgICAgIHBvaW50U2l6ZVxuICApO1xufTtcblxuLyoqXG4gKiBEcmF3cyB0aGUgc2hhZGVkIGVycm9yIGJhcnMvY29uZmlkZW5jZSBpbnRlcnZhbHMgZm9yIGVhY2ggc2VyaWVzLlxuICogVGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgY2VudGVyIGxpbmVzIGFyZSBkcmF3biwgc2luY2UgdGhlIGNlbnRlciBsaW5lc1xuICogbmVlZCB0byBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIGVycm9yIGJhcnMgZm9yIGFsbCBzZXJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgZXJyb3JCYXJzID0gZy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpIHx8XG4gICAgICBnLmdldEJvb2xlYW5PcHRpb24oXCJjdXN0b21CYXJzXCIpO1xuICBpZiAoIWVycm9yQmFycykgcmV0dXJuO1xuXG4gIHZhciBmaWxsR3JhcGggPSBnLmdldEJvb2xlYW5PcHRpb24oXCJmaWxsR3JhcGhcIiwgc2V0TmFtZSk7XG4gIGlmIChmaWxsR3JhcGgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDYW4ndCB1c2UgZmlsbEdyYXBoIG9wdGlvbiB3aXRoIGVycm9yIGJhcnNcIik7XG4gIH1cblxuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGNvbG9yID0gZS5jb2xvcjtcbiAgdmFyIGZpbGxBbHBoYSA9IGcuZ2V0TnVtZXJpY09wdGlvbignZmlsbEFscGhhJywgc2V0TmFtZSk7XG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIHNldE5hbWUpO1xuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG5cbiAgdmFyIGl0ZXIgPSB1dGlscy5jcmVhdGVJdGVyYXRvcihwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsXG4gICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICB2YXIgbmV3WXM7XG5cbiAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dFxuICB2YXIgcHJldlggPSBOYU47XG4gIHZhciBwcmV2WSA9IE5hTjtcbiAgdmFyIHByZXZZcyA9IFstMSwgLTFdO1xuICAvLyBzaG91bGQgYmUgc2FtZSBjb2xvciBhcyB0aGUgbGluZXMgYnV0IG9ubHkgMTUlIG9wYXF1ZS5cbiAgdmFyIHJnYiA9IHV0aWxzLnRvUkdCXyhjb2xvcik7XG4gIHZhciBlcnJfY29sb3IgPVxuICAgICAgJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGZpbGxBbHBoYSArICcpJztcbiAgY3R4LmZpbGxTdHlsZSA9IGVycl9jb2xvcjtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHZhciBpc051bGxVbmRlZmluZWRPck5hTiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggPT09IG51bGwgfHxcbiAgICAgICAgICAgIHggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaXNOYU4oeCkpO1xuICB9O1xuXG4gIHdoaWxlIChpdGVyLmhhc05leHQpIHtcbiAgICB2YXIgcG9pbnQgPSBpdGVyLm5leHQoKTtcbiAgICBpZiAoKCFzdGVwUGxvdCAmJiBpc051bGxVbmRlZmluZWRPck5hTihwb2ludC55KSkgfHxcbiAgICAgICAgKHN0ZXBQbG90ICYmICFpc05hTihwcmV2WSkgJiYgaXNOdWxsVW5kZWZpbmVkT3JOYU4ocHJldlkpKSkge1xuICAgICAgcHJldlggPSBOYU47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXdZcyA9IFsgcG9pbnQueV9ib3R0b20sIHBvaW50LnlfdG9wIF07XG4gICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICBwcmV2WSA9IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IGRpc2FsbG93cyBudWxscyBpbnNpZGUgdGhlIHBvaW50IGFycmF5cyxcbiAgICAvLyBidXQgaW4gY2FzZSBpdCBoYXBwZW5zIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgc2Vuc2libGUuXG4gICAgaWYgKGlzTmFOKG5ld1lzWzBdKSkgbmV3WXNbMF0gPSBwb2ludC55O1xuICAgIGlmIChpc05hTihuZXdZc1sxXSkpIG5ld1lzWzFdID0gcG9pbnQueTtcblxuICAgIG5ld1lzWzBdID0gZS5wbG90QXJlYS5oICogbmV3WXNbMF0gKyBlLnBsb3RBcmVhLnk7XG4gICAgbmV3WXNbMV0gPSBlLnBsb3RBcmVhLmggKiBuZXdZc1sxXSArIGUucGxvdEFyZWEueTtcbiAgICBpZiAoIWlzTmFOKHByZXZYKSkge1xuICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldlgsIHByZXZZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2WXNbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwcmV2WCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMV0pO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVUbyhwcmV2WCwgcHJldllzWzFdKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcHJldllzID0gbmV3WXM7XG4gICAgcHJldlggPSBwb2ludC5jYW52YXN4O1xuICB9XG4gIGN0eC5maWxsKCk7XG59O1xuXG5cbi8qKlxuICogUHJveHkgZm9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB3aGljaCBkcm9wcyBtb3ZlVG8vbGluZVRvIGNhbGxzIHdoaWNoIGFyZVxuICogc3VwZXJmbHVvdXMuIEl0IGFjY3VtdWxhdGVzIGFsbCBtb3ZlbWVudHMgd2hpY2ggaGF2ZW4ndCBjaGFuZ2VkIHRoZSB4LXZhbHVlXG4gKiBhbmQgb25seSBhcHBsaWVzIHRoZSB0d28gd2l0aCB0aGUgbW9zdCBleHRyZW1lIHktdmFsdWVzLlxuICpcbiAqIENhbGxzIHRvIGxpbmVUby9tb3ZlVG8gbXVzdCBoYXZlIG5vbi1kZWNyZWFzaW5nIHgtdmFsdWVzLlxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Zhc3RDYW52YXNQcm94eSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHBlbmRpbmdBY3Rpb25zID0gW107ICAvLyBhcnJheSBvZiBbdHlwZSwgeCwgeV0gdHVwbGVzXG4gIHZhciBsYXN0Um91bmRlZFggPSBudWxsO1xuICB2YXIgbGFzdEZsdXNoZWRYID0gbnVsbDtcblxuICB2YXIgTElORV9UTyA9IDEsXG4gICAgICBNT1ZFX1RPID0gMjtcblxuICB2YXIgYWN0aW9uQ291bnQgPSAwOyAgLy8gbnVtYmVyIG9mIG1vdmVUb3MgYW5kIGxpbmVUb3MgcGFzc2VkIHRvIGNvbnRleHQuXG5cbiAgLy8gRHJvcCBzdXBlcmZsdW91cyBtb3Rpb25zXG4gIC8vIEFzc3VtZXMgYWxsIHBlbmRpbmdBY3Rpb25zIGhhdmUgdGhlIHNhbWUgKHJvdW5kZWQpIHgtdmFsdWUuXG4gIHZhciBjb21wcmVzc0FjdGlvbnMgPSBmdW5jdGlvbihvcHRfbG9zc2xlc3NPbmx5KSB7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCA8PSAxKSByZXR1cm47XG5cbiAgICAvLyBMb3NzbGVzcyBjb21wcmVzc2lvbjogZHJvcCBpbmNvbnNlcXVlbnRpYWwgbW92ZVRvcy5cbiAgICBmb3IgKHZhciBpID0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgdmFyIGFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2ldO1xuICAgICAgaWYgKGFjdGlvblswXSA9PSBNT1ZFX1RPKSB7XG4gICAgICAgIHZhciBwcmV2QWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaSAtIDFdO1xuICAgICAgICBpZiAocHJldkFjdGlvblsxXSA9PSBhY3Rpb25bMV0gJiYgcHJldkFjdGlvblsyXSA9PSBhY3Rpb25bMl0pIHtcbiAgICAgICAgICBwZW5kaW5nQWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb3NzbGVzcyBjb21wcmVzc2lvbjogLi4uIGRyb3AgY29uc2VjdXRpdmUgbW92ZVRvcyAuLi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdBY3Rpb25zLmxlbmd0aCAtIDE7IC8qIGluY3JlbWVudGVkIGludGVybmFsbHkgKi8pIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTU9WRV9UTyAmJiBwZW5kaW5nQWN0aW9uc1tpICsgMV1bMF0gPT0gTU9WRV9UTykge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9zc3kgY29tcHJlc3Npb246IC4uLiBkcm9wIGFsbCBidXQgdGhlIGV4dHJlbWUgeS12YWx1ZXMgLi4uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCA+IDIgJiYgIW9wdF9sb3NzbGVzc09ubHkpIHtcbiAgICAgIC8vIGtlZXAgYW4gaW5pdGlhbCBtb3ZlVG8sIGJ1dCBkcm9wIGFsbCBvdGhlcnMuXG4gICAgICB2YXIgc3RhcnRJZHggPSAwO1xuICAgICAgaWYgKHBlbmRpbmdBY3Rpb25zWzBdWzBdID09IE1PVkVfVE8pIHN0YXJ0SWR4Kys7XG4gICAgICB2YXIgbWluSWR4ID0gbnVsbCwgbWF4SWR4ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydElkeDsgaSA8IHBlbmRpbmdBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgICAgaWYgKGFjdGlvblswXSAhPSBMSU5FX1RPKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG1pbklkeCA9PT0gbnVsbCAmJiBtYXhJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBtaW5JZHggPSBpO1xuICAgICAgICAgIG1heElkeCA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHkgPSBhY3Rpb25bMl07XG4gICAgICAgICAgaWYgKHkgPCBwZW5kaW5nQWN0aW9uc1ttaW5JZHhdWzJdKSB7XG4gICAgICAgICAgICBtaW5JZHggPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeSA+IHBlbmRpbmdBY3Rpb25zW21heElkeF1bMl0pIHtcbiAgICAgICAgICAgIG1heElkeCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWluQWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbbWluSWR4XSxcbiAgICAgICAgICBtYXhBY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1ttYXhJZHhdO1xuICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKHN0YXJ0SWR4LCBwZW5kaW5nQWN0aW9ucy5sZW5ndGggLSBzdGFydElkeCk7XG4gICAgICBpZiAobWluSWR4IDwgbWF4SWR4KSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWluQWN0aW9uKTtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtYXhBY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChtaW5JZHggPiBtYXhJZHgpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtYXhBY3Rpb24pO1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBmbHVzaEFjdGlvbnMgPSBmdW5jdGlvbihvcHRfbm9Mb3NzeUNvbXByZXNzaW9uKSB7XG4gICAgY29tcHJlc3NBY3Rpb25zKG9wdF9ub0xvc3N5Q29tcHJlc3Npb24pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwZW5kaW5nQWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2ldO1xuICAgICAgaWYgKGFjdGlvblswXSA9PSBMSU5FX1RPKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGFjdGlvblsxXSwgYWN0aW9uWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uWzBdID09IE1PVkVfVE8pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oYWN0aW9uWzFdLCBhY3Rpb25bMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGVuZGluZ0FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0Rmx1c2hlZFggPSBwZW5kaW5nQWN0aW9uc1twZW5kaW5nQWN0aW9ucy5sZW5ndGggLSAxXVsxXTtcbiAgICB9XG4gICAgYWN0aW9uQ291bnQgKz0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoO1xuICAgIHBlbmRpbmdBY3Rpb25zID0gW107XG4gIH07XG5cbiAgdmFyIGFkZEFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgeCwgeSkge1xuICAgIHZhciByeCA9IE1hdGgucm91bmQoeCk7XG4gICAgaWYgKGxhc3RSb3VuZGVkWCA9PT0gbnVsbCB8fCByeCAhPSBsYXN0Um91bmRlZFgpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBsYXJnZSBnYXBzIG9uIHRoZSB4LWF4aXMsIGl0J3MgZXNzZW50aWFsIHRvIGtlZXAgdGhlXG4gICAgICAvLyBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcyB3ZWxsLlxuICAgICAgdmFyIGhhc0dhcE9uTGVmdCA9IChsYXN0Um91bmRlZFggLSBsYXN0Rmx1c2hlZFggPiAxKSxcbiAgICAgICAgICBoYXNHYXBPblJpZ2h0ID0gKHJ4IC0gbGFzdFJvdW5kZWRYID4gMSksXG4gICAgICAgICAgaGFzR2FwID0gaGFzR2FwT25MZWZ0IHx8IGhhc0dhcE9uUmlnaHQ7XG4gICAgICBmbHVzaEFjdGlvbnMoaGFzR2FwKTtcbiAgICAgIGxhc3RSb3VuZGVkWCA9IHJ4O1xuICAgIH1cbiAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKFthY3Rpb24sIHgsIHldKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgYWRkQWN0aW9uKE1PVkVfVE8sIHgsIHkpO1xuICAgIH0sXG4gICAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBhZGRBY3Rpb24oTElORV9UTywgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIGZvciBtYWpvciBvcGVyYXRpb25zIGxpa2Ugc3Ryb2tlL2ZpbGwsIHdlIHNraXAgY29tcHJlc3Npb24gdG8gZW5zdXJlXG4gICAgLy8gdGhhdCB0aGVyZSBhcmUgbm8gYXJ0aWZhY3RzIGF0IHRoZSByaWdodCBlZGdlLlxuICAgIHN0cm9rZTogICAgZnVuY3Rpb24oKSB7IGZsdXNoQWN0aW9ucyh0cnVlKTsgY29udGV4dC5zdHJva2UoKTsgfSxcbiAgICBmaWxsOiAgICAgIGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuZmlsbCgpOyB9LFxuICAgIGJlZ2luUGF0aDogZnVuY3Rpb24oKSB7IGZsdXNoQWN0aW9ucyh0cnVlKTsgY29udGV4dC5iZWdpblBhdGgoKTsgfSxcbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG5cbiAgICBfY291bnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gYWN0aW9uQ291bnQ7IH1cbiAgfTtcbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIHNoYWRlZCByZWdpb25zIHdoZW4gXCJmaWxsR3JhcGhcIiBpcyBzZXQuIE5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG4gKiBlcnJvciBiYXJzLlxuICpcbiAqIEZvciBzdGFja2VkIGNoYXJ0cywgaXQncyBtb3JlIGNvbnZlbmllbnQgdG8gaGFuZGxlIGFsbCB0aGUgc2VyaWVzXG4gKiBzaW11bHRhbmVvdXNseS4gU28gdGhpcyBwbG90dGVyIHBsb3RzIGFsbCB0aGUgcG9pbnRzIG9uIHRoZSBmaXJzdCBzZXJpZXNcbiAqIGl0J3MgYXNrZWQgdG8gZHJhdywgdGhlbiBpZ25vcmVzIGFsbCB0aGUgb3RoZXIgc2VyaWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZmlsbFBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFNraXAgaWYgd2UncmUgZHJhd2luZyBhIHNpbmdsZSBzZXJpZXMgZm9yIGludGVyYWN0aXZlIGhpZ2hsaWdodCBvdmVybGF5LlxuICBpZiAoZS5zaW5nbGVTZXJpZXNOYW1lKSByZXR1cm47XG5cbiAgLy8gV2UnbGwgaGFuZGxlIGFsbCB0aGUgc2VyaWVzIGF0IG9uY2UsIG5vdCBvbmUtYnktb25lLlxuICBpZiAoZS5zZXJpZXNJbmRleCAhPT0gMCkgcmV0dXJuO1xuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZXMgPSBnLmdldExhYmVscygpLnNsaWNlKDEpOyAgLy8gcmVtb3ZlIHgtYXhpc1xuXG4gIC8vIGdldExhYmVscygpIGluY2x1ZGVzIG5hbWVzIGZvciBpbnZpc2libGUgc2VyaWVzLCB3aGljaCBhcmUgbm90IGluY2x1ZGVkIGluXG4gIC8vIGFsbFNlcmllc1BvaW50cy4gV2UgcmVtb3ZlIHRob3NlIHRvIG1ha2UgdGhlIHR3byBtYXRjaC5cbiAgLy8gVE9ETyhkYW52ayk6IHByb3ZpZGUgYSBzaW1wbGVyIHdheSB0byBnZXQgdGhpcyBpbmZvcm1hdGlvbi5cbiAgZm9yICh2YXIgaSA9IHNldE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoIWcudmlzaWJpbGl0eSgpW2ldKSBzZXROYW1lcy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICB2YXIgYW55U2VyaWVzRmlsbGVkID0gKGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChnLmdldEJvb2xlYW5PcHRpb24oXCJmaWxsR3JhcGhcIiwgc2V0TmFtZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSgpO1xuXG4gIGlmICghYW55U2VyaWVzRmlsbGVkKSByZXR1cm47XG5cbiAgdmFyIGFyZWEgPSBlLnBsb3RBcmVhO1xuICB2YXIgc2V0cyA9IGUuYWxsU2VyaWVzUG9pbnRzO1xuICB2YXIgc2V0Q291bnQgPSBzZXRzLmxlbmd0aDtcblxuICB2YXIgc3RhY2tlZEdyYXBoID0gZy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpO1xuICB2YXIgY29sb3JzID0gZy5nZXRDb2xvcnMoKTtcblxuICAvLyBGb3Igc3RhY2tlZCBncmFwaHMsIHRyYWNrIHRoZSBiYXNlbGluZSBmb3IgZmlsbGluZy5cbiAgLy9cbiAgLy8gVGhlIGZpbGxlZCBhcmVhcyBiZWxvdyBncmFwaCBsaW5lcyBhcmUgdHJhcGV6b2lkcyB3aXRoIHR3b1xuICAvLyB2ZXJ0aWNhbCBlZGdlcy4gVGhlIHRvcCBlZGdlIGlzIHRoZSBsaW5lIHNlZ21lbnQgYmVpbmcgZHJhd24sIGFuZFxuICAvLyB0aGUgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBlZGdlLiBFYWNoIGJhc2VsaW5lIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAvLyB0b3AgbGluZSBzZWdtZW50IGZyb20gdGhlIHByZXZpb3VzIHN0YWNrZWQgbGluZS4gSW4gdGhlIGNhc2Ugb2ZcbiAgLy8gc3RlcCBwbG90cywgdGhlIHRyYXBlem9pZHMgYXJlIHJlY3RhbmdsZXMuXG4gIHZhciBiYXNlbGluZSA9IHt9O1xuICB2YXIgY3VyckJhc2VsaW5lO1xuICB2YXIgcHJldlN0ZXBQbG90OyAgLy8gZm9yIGRpZmZlcmVudCBsaW5lIGRyYXdpbmcgbW9kZXMgKGxpbmUvc3RlcCkgcGVyIHNlcmllc1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byB0cmFjZSBhIGxpbmUgYmFjayBhbG9uZyB0aGUgYmFzZWxpbmUuXG4gIHZhciB0cmFjZUJhY2tQYXRoID0gZnVuY3Rpb24oY3R4LCBiYXNlbGluZVgsIGJhc2VsaW5lWSwgcGF0aEJhY2spIHtcbiAgICBjdHgubGluZVRvKGJhc2VsaW5lWCwgYmFzZWxpbmVZKTtcbiAgICBpZiAoc3RhY2tlZEdyYXBoKSB7XG4gICAgICBmb3IgKHZhciBpID0gcGF0aEJhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHB0ID0gcGF0aEJhY2tbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocHRbMF0sIHB0WzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcHJvY2VzcyBzZXRzIGluIHJldmVyc2Ugb3JkZXIgKG5lZWRlZCBmb3Igc3RhY2tlZCBncmFwaHMpXG4gIGZvciAodmFyIHNldElkeCA9IHNldENvdW50IC0gMTsgc2V0SWR4ID49IDA7IHNldElkeC0tKSB7XG4gICAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gICAgdmFyIHNldE5hbWUgPSBzZXROYW1lc1tzZXRJZHhdO1xuICAgIGlmICghZy5nZXRCb29sZWFuT3B0aW9uKCdmaWxsR3JhcGgnLCBzZXROYW1lKSkgY29udGludWU7XG5cbiAgICB2YXIgZmlsbEFscGhhID0gZy5nZXROdW1lcmljT3B0aW9uKCdmaWxsQWxwaGEnLCBzZXROYW1lKTtcbiAgICB2YXIgc3RlcFBsb3QgPSBnLmdldEJvb2xlYW5PcHRpb24oJ3N0ZXBQbG90Jywgc2V0TmFtZSk7XG4gICAgdmFyIGNvbG9yID0gY29sb3JzW3NldElkeF07XG4gICAgdmFyIGF4aXMgPSBnLmF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzKHNldE5hbWUpO1xuICAgIHZhciBheGlzWSA9IDEuMCArIGF4aXMubWlueXZhbCAqIGF4aXMueXNjYWxlO1xuICAgIGlmIChheGlzWSA8IDAuMCkgYXhpc1kgPSAwLjA7XG4gICAgZWxzZSBpZiAoYXhpc1kgPiAxLjApIGF4aXNZID0gMS4wO1xuICAgIGF4aXNZID0gYXJlYS5oICogYXhpc1kgKyBhcmVhLnk7XG5cbiAgICB2YXIgcG9pbnRzID0gc2V0c1tzZXRJZHhdO1xuICAgIHZhciBpdGVyID0gdXRpbHMuY3JlYXRlSXRlcmF0b3IocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLFxuICAgICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiLCBzZXROYW1lKSkpO1xuXG4gICAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBwcmV2WCA9IE5hTjtcbiAgICB2YXIgcHJldllzID0gWy0xLCAtMV07XG4gICAgdmFyIG5ld1lzO1xuICAgIC8vIHNob3VsZCBiZSBzYW1lIGNvbG9yIGFzIHRoZSBsaW5lcyBidXQgb25seSAxNSUgb3BhcXVlLlxuICAgIHZhciByZ2IgPSB1dGlscy50b1JHQl8oY29sb3IpO1xuICAgIHZhciBlcnJfY29sb3IgPVxuICAgICAgICAncmdiYSgnICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJywnICsgZmlsbEFscGhhICsgJyknO1xuICAgIGN0eC5maWxsU3R5bGUgPSBlcnJfY29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHZhciBsYXN0X3gsIGlzX2ZpcnN0ID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSBwb2ludCBkZW5zaXR5IGlzIGhpZ2ggZW5vdWdoLCBkcm9wcGluZyBzZWdtZW50cyBvbiB0aGVpciB3YXkgdG9cbiAgICAvLyB0aGUgY2FudmFzIGp1c3RpZmllcyB0aGUgb3ZlcmhlYWQgb2YgZG9pbmcgc28uXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPiAyICogZy53aWR0aF8gfHwgRHlncmFwaC5GT1JDRV9GQVNUX1BST1hZKSB7XG4gICAgICBjdHggPSBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Zhc3RDYW52YXNQcm94eShjdHgpO1xuICAgIH1cblxuICAgIC8vIEZvciBmaWxsZWQgY2hhcnRzLCB3ZSBkcmF3IHBvaW50cyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZW4gYmFjayBhbG9uZ1xuICAgIC8vIHRoZSB4LWF4aXMgdG8gY29tcGxldGUgYSBzaGFwZSBmb3IgZmlsbGluZy5cbiAgICAvLyBGb3Igc3RhY2tlZCBwbG90cywgdGhpcyBcImJhY2sgcGF0aFwiIGlzIGEgbW9yZSBjb21wbGV4IHNoYXBlLiBUaGlzIGFycmF5XG4gICAgLy8gc3RvcmVzIHRoZSBbeCwgeV0gdmFsdWVzIG5lZWRlZCB0byB0cmFjZSB0aGF0IHNoYXBlLlxuICAgIHZhciBwYXRoQmFjayA9IFtdO1xuXG4gICAgLy8gVE9ETyhkYW52ayk6IHRoZXJlIGFyZSBhIGxvdCBvZiBvcHRpb25zIGF0IHBsYXkgaW4gdGhpcyBsb29wLlxuICAgIC8vICAgICBUaGUgbG9naWMgd291bGQgYmUgbXVjaCBjbGVhcmVyIGlmIHNvbWUgKGUuZy4gc3RhY2tHcmFwaCBhbmRcbiAgICAvLyAgICAgc3RlcFBsb3QpIHdlcmUgc3BsaXQgb2ZmIGludG8gc2VwYXJhdGUgc3ViLXBsb3R0ZXJzLlxuICAgIHZhciBwb2ludDtcbiAgICB3aGlsZSAoaXRlci5oYXNOZXh0KSB7XG4gICAgICBwb2ludCA9IGl0ZXIubmV4dCgpO1xuICAgICAgaWYgKCF1dGlscy5pc09LKHBvaW50LnkpICYmICFzdGVwUGxvdCkge1xuICAgICAgICB0cmFjZUJhY2tQYXRoKGN0eCwgcHJldlgsIHByZXZZc1sxXSwgcGF0aEJhY2spO1xuICAgICAgICBwYXRoQmFjayA9IFtdO1xuICAgICAgICBwcmV2WCA9IE5hTjtcbiAgICAgICAgaWYgKHBvaW50Lnlfc3RhY2tlZCAhPT0gbnVsbCAmJiAhaXNOYU4ocG9pbnQueV9zdGFja2VkKSkge1xuICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gYXJlYS5oICogcG9pbnQueV9zdGFja2VkICsgYXJlYS55O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWRHcmFwaCkge1xuICAgICAgICBpZiAoIWlzX2ZpcnN0ICYmIGxhc3RfeCA9PSBwb2ludC54dmFsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNfZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICBsYXN0X3ggPSBwb2ludC54dmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyckJhc2VsaW5lID0gYmFzZWxpbmVbcG9pbnQuY2FudmFzeF07XG4gICAgICAgIHZhciBsYXN0WTtcbiAgICAgICAgaWYgKGN1cnJCYXNlbGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFzdFkgPSBheGlzWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihwcmV2U3RlcFBsb3QpIHtcbiAgICAgICAgICAgIGxhc3RZID0gY3VyckJhc2VsaW5lWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0WSA9IGN1cnJCYXNlbGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3WXMgPSBbIHBvaW50LmNhbnZhc3ksIGxhc3RZIF07XG5cbiAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgLy8gU3RlcCBwbG90cyBtdXN0IGtlZXAgdHJhY2sgb2YgdGhlIHRvcCBhbmQgYm90dG9tIG9mXG4gICAgICAgICAgLy8gdGhlIGJhc2VsaW5lIGF0IGVhY2ggcG9pbnQuXG4gICAgICAgICAgaWYgKHByZXZZc1swXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gWyBwb2ludC5jYW52YXN5LCBheGlzWSBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IFsgcG9pbnQuY2FudmFzeSwgcHJldllzWzBdIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdID0gcG9pbnQuY2FudmFzeTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOYU4ocG9pbnQuY2FudmFzeSkgJiYgc3RlcFBsb3QpIHtcbiAgICAgICAgICBuZXdZcyA9IFsgYXJlYS55ICsgYXJlYS5oLCBheGlzWSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1lzID0gWyBwb2ludC5jYW52YXN5LCBheGlzWSBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzTmFOKHByZXZYKSkge1xuICAgICAgICAvLyBNb3ZlIHRvIHRvcCBmaWxsIHBvaW50XG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzBdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29yZCB0aGUgYmFzZWxpbmUgZm9yIHRoZSByZXZlcnNlIHBhdGguXG4gICAgICAgIGlmIChzdGFja2VkR3JhcGgpIHtcbiAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwcmV2WCwgcHJldllzWzFdXSk7XG4gICAgICAgICAgaWYgKHByZXZTdGVwUGxvdCAmJiBjdXJyQmFzZWxpbmUpIHtcbiAgICAgICAgICAgIC8vIERyYXcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgYmFzZWxpbmVcbiAgICAgICAgICAgIHBhdGhCYWNrLnB1c2goW3BvaW50LmNhbnZhc3gsIGN1cnJCYXNlbGluZVsxXV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwb2ludC5jYW52YXN4LCBuZXdZc1sxXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1sxXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMF0pO1xuICAgICAgfVxuICAgICAgcHJldllzID0gbmV3WXM7XG4gICAgICBwcmV2WCA9IHBvaW50LmNhbnZhc3g7XG4gICAgfVxuICAgIHByZXZTdGVwUGxvdCA9IHN0ZXBQbG90O1xuICAgIGlmIChuZXdZcyAmJiBwb2ludCkge1xuICAgICAgdHJhY2VCYWNrUGF0aChjdHgsIHBvaW50LmNhbnZhc3gsIG5ld1lzWzFdLCBwYXRoQmFjayk7XG4gICAgICBwYXRoQmFjayA9IFtdO1xuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoQ2FudmFzUmVuZGVyZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var _dygraph_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);\n/* harmony import */ var _dygraph_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n/* harmony import */ var _dygraph_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);\n/* harmony import */ var _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);\n/* harmony import */ var _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);\n/* harmony import */ var _dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);\n/* harmony import */ var _dygraph_options_reference__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(22);\n/* harmony import */ var _iframe_tarp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10);\n/* harmony import */ var _datahandler_default__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9);\n/* harmony import */ var _datahandler_bars_error__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);\n/* harmony import */ var _datahandler_bars_custom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13);\n/* harmony import */ var _datahandler_default_fractions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(14);\n/* harmony import */ var _datahandler_bars_fractions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(15);\n/* harmony import */ var _datahandler_bars__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(3);\n/* harmony import */ var _plugins_annotations__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(16);\n/* harmony import */ var _plugins_axes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(17);\n/* harmony import */ var _plugins_chart_labels__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(18);\n/* harmony import */ var _plugins_grid__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(19);\n/* harmony import */ var _plugins_legend__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(20);\n/* harmony import */ var _plugins_range_selector__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(21);\n/* harmony import */ var _dygraph_gviz__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(24);\n/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Creates an interactive, zoomable graph based on a CSV file or\n * string. Dygraph can handle multiple series with or without error bars. The\n * date/value ranges will be automatically set. Dygraph uses the\n * &lt;canvas&gt; tag, so it only works in FF1.5+.\n * @author danvdk@gmail.com (Dan Vanderkam)\n\n  Usage:\n   <div id="graphdiv" style="width:800px; height:500px;"></div>\n   <script type="text/javascript">\n     new Dygraph(document.getElementById("graphdiv"),\n                 "datafile.csv",  // CSV file with headers\n                 { }); // options\n   <\/script>\n\n The CSV file is of the form\n\n   Date,SeriesA,SeriesB,SeriesC\n   YYYYMMDD,A1,B1,C1\n   YYYYMMDD,A2,B2,C2\n\n If the \'errorBars\' option is set in the constructor, the input should be of\n the form\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...\n   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...\n\n If the \'fractions\' option is set, the input should be of the form:\n\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1/B1,A2/B2,...\n   YYYYMMDD,A1/B1,A2/B2,...\n\n And error bars will be calculated automatically using a binomial distribution.\n\n For further documentation and examples, see http://dygraphs.com/\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\n\n/**\n * Creates an interactive, zoomable chart.\n *\n * @constructor\n * @param {div | String} div A div or the id of a div into which to construct\n * the chart.\n * @param {String | Function} file A file containing CSV data or a function\n * that returns this data. The most basic expected format for each line is\n * "YYYY/MM/DD,val1,val2,...". For more information, see\n * http://dygraphs.com/data.html.\n * @param {Object} attrs Various other attributes, e.g. errorBars determines\n * whether the input data contains error ranges. For a complete list of\n * options, see http://dygraphs.com/options.html.\n */\nvar Dygraph = function(div, data, opts) {\n  this.__init__(div, data, opts);\n};\n\nDygraph.NAME = "Dygraph";\nDygraph.VERSION = "2.0.0";\n\n// Various default values\nDygraph.DEFAULT_ROLL_PERIOD = 1;\nDygraph.DEFAULT_WIDTH = 480;\nDygraph.DEFAULT_HEIGHT = 320;\n\n// For max 60 Hz. animation:\nDygraph.ANIMATION_STEPS = 12;\nDygraph.ANIMATION_DURATION = 200;\n\n/**\n * Standard plotters. These may be used by clients.\n * Available plotters are:\n * - Dygraph.Plotters.linePlotter: draws central lines (most common)\n * - Dygraph.Plotters.errorPlotter: draws error bars\n * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)\n *\n * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].\n * This causes all the lines to be drawn over all the fills/error bars.\n */\nDygraph.Plotters = _dygraph_canvas__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]._Plotters;\n\n\n// Used for initializing annotation CSS rules only once.\nDygraph.addedAnnotationCSS = false;\n\n/**\n * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit\n * and context &lt;canvas&gt; inside of it. See the constructor for details.\n * on the parameters.\n * @param {Element} div the Element to render the graph into.\n * @param {string | Function} file Source data\n * @param {Object} attrs Miscellaneous other options\n * @private\n */\nDygraph.prototype.__init__ = function(div, file, attrs) {\n  this.is_initial_draw_ = true;\n  this.readyFns_ = [];\n\n  // Support two-argument constructor\n  if (attrs === null || attrs === undefined) { attrs = {}; }\n\n  attrs = Dygraph.copyUserAttrs_(attrs);\n\n  if (typeof(div) == \'string\') {\n    div = document.getElementById(div);\n  }\n\n  if (!div) {\n    throw new Error(\'Constructing dygraph with a non-existent div!\');\n  }\n\n  // Copy the important bits into the object\n  // TODO(danvk): most of these should just stay in the attrs_ dictionary.\n  this.maindiv_ = div;\n  this.file_ = file;\n  this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;\n  this.previousVerticalX_ = -1;\n  this.fractions_ = attrs.fractions || false;\n  this.dateWindow_ = attrs.dateWindow || null;\n\n  this.annotations_ = [];\n\n  // Clear the div. This ensure that, if multiple dygraphs are passed the same\n  // div, then only one will be drawn.\n  div.innerHTML = "";\n\n  // For historical reasons, the \'width\' and \'height\' options trump all CSS\n  // rules _except_ for an explicit \'width\' or \'height\' on the div.\n  // As an added convenience, if the div has zero height (like <div></div> does\n  // without any styles), then we use a default height/width.\n  if (div.style.width === \'\' && attrs.width) {\n    div.style.width = attrs.width + "px";\n  }\n  if (div.style.height === \'\' && attrs.height) {\n    div.style.height = attrs.height + "px";\n  }\n  if (div.style.height === \'\' && div.clientHeight === 0) {\n    div.style.height = Dygraph.DEFAULT_HEIGHT + "px";\n    if (div.style.width === \'\') {\n      div.style.width = Dygraph.DEFAULT_WIDTH + "px";\n    }\n  }\n  // These will be zero if the dygraph\'s div is hidden. In that case,\n  // use the user-specified attributes if present. If not, use zero\n  // and assume the user will call resize to fix things later.\n  this.width_ = div.clientWidth || attrs.width || 0;\n  this.height_ = div.clientHeight || attrs.height || 0;\n\n  // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.\n  if (attrs.stackedGraph) {\n    attrs.fillGraph = true;\n    // TODO(nikhilk): Add any other stackedGraph checks here.\n  }\n\n  // DEPRECATION WARNING: All option processing should be moved from\n  // attrs_ and user_attrs_ to options_, which holds all this information.\n  //\n  // Dygraphs has many options, some of which interact with one another.\n  // To keep track of everything, we maintain two sets of options:\n  //\n  //  this.user_attrs_   only options explicitly set by the user.\n  //  this.attrs_        defaults, options derived from user_attrs_, data.\n  //\n  // Options are then accessed this.attr_(\'attr\'), which first looks at\n  // user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent\n  // defaults without overriding behavior that the user specifically asks for.\n  this.user_attrs_ = {};\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* update */ "R"](this.user_attrs_, attrs);\n\n  // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.\n  this.attrs_ = {};\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* updateDeep */ "S"](this.attrs_, _dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]);\n\n  this.boundaryIds_ = [];\n  this.setIndexByName_ = {};\n  this.datasetIndex_ = [];\n\n  this.registeredEvents_ = [];\n  this.eventListeners_ = {};\n\n  this.attributes_ = new _dygraph_options__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](this);\n\n  // Create the containing DIV and other interactive elements\n  this.createInterface_();\n\n  // Activate plugins.\n  this.plugins_ = [];\n  var plugins = Dygraph.PLUGINS.concat(this.getOption(\'plugins\'));\n  for (var i = 0; i < plugins.length; i++) {\n    // the plugins option may contain either plugin classes or instances.\n    // Plugin instances contain an activate method.\n    var Plugin = plugins[i];  // either a constructor or an instance.\n    var pluginInstance;\n    if (typeof(Plugin.activate) !== \'undefined\') {\n      pluginInstance = Plugin;\n    } else {\n      pluginInstance = new Plugin();\n    }\n\n    var pluginDict = {\n      plugin: pluginInstance,\n      events: {},\n      options: {},\n      pluginOptions: {}\n    };\n\n    var handlers = pluginInstance.activate(this);\n    for (var eventName in handlers) {\n      if (!handlers.hasOwnProperty(eventName)) continue;\n      // TODO(danvk): validate eventName.\n      pluginDict.events[eventName] = handlers[eventName];\n    }\n\n    this.plugins_.push(pluginDict);\n  }\n\n  // At this point, plugins can no longer register event handlers.\n  // Construct a map from event -> ordered list of [callback, plugin].\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var plugin_dict = this.plugins_[i];\n    for (var eventName in plugin_dict.events) {\n      if (!plugin_dict.events.hasOwnProperty(eventName)) continue;\n      var callback = plugin_dict.events[eventName];\n\n      var pair = [plugin_dict.plugin, callback];\n      if (!(eventName in this.eventListeners_)) {\n        this.eventListeners_[eventName] = [pair];\n      } else {\n        this.eventListeners_[eventName].push(pair);\n      }\n    }\n  }\n\n  this.createDragInterface_();\n\n  this.start_();\n};\n\n/**\n * Triggers a cascade of events to the various plugins which are interested in them.\n * Returns true if the "default behavior" should be prevented, i.e. if one\n * of the event listeners called event.preventDefault().\n * @private\n */\nDygraph.prototype.cascadeEvents_ = function(name, extra_props) {\n  if (!(name in this.eventListeners_)) return false;\n\n  // QUESTION: can we use objects & prototypes to speed this up?\n  var e = {\n    dygraph: this,\n    cancelable: false,\n    defaultPrevented: false,\n    preventDefault: function() {\n      if (!e.cancelable) throw "Cannot call preventDefault on non-cancelable event.";\n      e.defaultPrevented = true;\n    },\n    propagationStopped: false,\n    stopPropagation: function() {\n      e.propagationStopped = true;\n    }\n  };\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* update */ "R"](e, extra_props);\n\n  var callback_plugin_pairs = this.eventListeners_[name];\n  if (callback_plugin_pairs) {\n    for (var i = callback_plugin_pairs.length - 1; i >= 0; i--) {\n      var plugin = callback_plugin_pairs[i][0];\n      var callback = callback_plugin_pairs[i][1];\n      callback.call(plugin, e);\n      if (e.propagationStopped) break;\n    }\n  }\n  return e.defaultPrevented;\n};\n\n/**\n * Fetch a plugin instance of a particular class. Only for testing.\n * @private\n * @param {!Class} type The type of the plugin.\n * @return {Object} Instance of the plugin, or null if there is none.\n */\nDygraph.prototype.getPluginInstance_ = function(type) {\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var p = this.plugins_[i];\n    if (p.plugin instanceof type) {\n      return p.plugin;\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the zoomed status of the chart for one or both axes.\n *\n * Axis is an optional parameter. Can be set to \'x\' or \'y\'.\n *\n * The zoomed status for an axis is set whenever a user zooms using the mouse\n * or when the dateWindow or valueRange are updated. Double-clicking or calling\n * resetZoom() resets the zoom status for the chart.\n */\nDygraph.prototype.isZoomed = function(axis) {\n  const isZoomedX = !!this.dateWindow_;\n  if (axis === \'x\') return isZoomedX;\n\n  const isZoomedY = this.axes_.map(axis => !!axis.valueRange).indexOf(true) >= 0;\n  if (axis === null || axis === undefined) {\n    return isZoomedX || isZoomedY;\n  }\n  if (axis === \'y\') return isZoomedY;\n\n  throw new Error(`axis parameter is [${axis}] must be null, \'x\' or \'y\'.`);\n};\n\n/**\n * Returns information about the Dygraph object, including its containing ID.\n */\nDygraph.prototype.toString = function() {\n  var maindiv = this.maindiv_;\n  var id = (maindiv && maindiv.id) ? maindiv.id : maindiv;\n  return "[Dygraph " + id + "]";\n};\n\n/**\n * @private\n * Returns the value of an option. This may be set by the user (either in the\n * constructor or by calling updateOptions) or by dygraphs, and may be set to a\n * per-series value.\n * @param {string} name The name of the option, e.g. \'rollPeriod\'.\n * @param {string} [seriesName] The name of the series to which the option\n * will be applied. If no per-series value of this option is available, then\n * the global value is returned. This is optional.\n * @return { ... } The value of the option.\n */\nDygraph.prototype.attr_ = function(name, seriesName) {\n  // For "production" code, this gets removed by uglifyjs.\n  if (typeof(process) !== \'undefined\') {\n    if (false) {}\n  }\n  return seriesName ? this.attributes_.getForSeries(name, seriesName) : this.attributes_.get(name);\n};\n\n/**\n * Returns the current value for an option, as set in the constructor or via\n * updateOptions. You may pass in an (optional) series name to get per-series\n * values for the option.\n *\n * All values returned by this method should be considered immutable. If you\n * modify them, there is no guarantee that the changes will be honored or that\n * dygraphs will remain in a consistent state. If you want to modify an option,\n * use updateOptions() instead.\n *\n * @param {string} name The name of the option (e.g. \'strokeWidth\')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {*} The value of the option.\n */\nDygraph.prototype.getOption = function(name, opt_seriesName) {\n  return this.attr_(name, opt_seriesName);\n};\n\n/**\n * Like getOption(), but specifically returns a number.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. \'strokeWidth\')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {number} The value of the option.\n * @private\n */\nDygraph.prototype.getNumericOption = function(name, opt_seriesName) {\n  return /** @type{number} */(this.getOption(name, opt_seriesName));\n};\n\n/**\n * Like getOption(), but specifically returns a string.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. \'strokeWidth\')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {string} The value of the option.\n * @private\n */\nDygraph.prototype.getStringOption = function(name, opt_seriesName) {\n  return /** @type{string} */(this.getOption(name, opt_seriesName));\n};\n\n/**\n * Like getOption(), but specifically returns a boolean.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. \'strokeWidth\')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {boolean} The value of the option.\n * @private\n */\nDygraph.prototype.getBooleanOption = function(name, opt_seriesName) {\n  return /** @type{boolean} */(this.getOption(name, opt_seriesName));\n};\n\n/**\n * Like getOption(), but specifically returns a function.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. \'strokeWidth\')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {function(...)} The value of the option.\n * @private\n */\nDygraph.prototype.getFunctionOption = function(name, opt_seriesName) {\n  return /** @type{function(...)} */(this.getOption(name, opt_seriesName));\n};\n\nDygraph.prototype.getOptionForAxis = function(name, axis) {\n  return this.attributes_.getForAxis(name, axis);\n};\n\n/**\n * @private\n * @param {string} axis The name of the axis (i.e. \'x\', \'y\' or \'y2\')\n * @return { ... } A function mapping string -> option value\n */\nDygraph.prototype.optionsViewForAxis_ = function(axis) {\n  var self = this;\n  return function(opt) {\n    var axis_opts = self.user_attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n\n    // I don\'t like that this is in a second spot.\n    if (axis === \'x\' && opt === \'logscale\') {\n      // return the default value.\n      // TODO(konigsberg): pull the default from a global default.\n      return false;\n    }\n\n    // user-specified attributes always trump defaults, even if they\'re less\n    // specific.\n    if (typeof(self.user_attrs_[opt]) != \'undefined\') {\n      return self.user_attrs_[opt];\n    }\n\n    axis_opts = self.attrs_.axes;\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    }\n    // check old-style axis options\n    // TODO(danvk): add a deprecation warning if either of these match.\n    if (axis == \'y\' && self.axes_[0].hasOwnProperty(opt)) {\n      return self.axes_[0][opt];\n    } else if (axis == \'y2\' && self.axes_[1].hasOwnProperty(opt)) {\n      return self.axes_[1][opt];\n    }\n    return self.attr_(opt);\n  };\n};\n\n/**\n * Returns the current rolling period, as set by the user or an option.\n * @return {number} The number of points in the rolling window\n */\nDygraph.prototype.rollPeriod = function() {\n  return this.rollPeriod_;\n};\n\n/**\n * Returns the currently-visible x-range. This can be affected by zooming,\n * panning or a call to updateOptions.\n * Returns a two-element array: [left, right].\n * If the Dygraph has dates on the x-axis, these will be millis since epoch.\n */\nDygraph.prototype.xAxisRange = function() {\n  return this.dateWindow_ ? this.dateWindow_ : this.xAxisExtremes();\n};\n\n/**\n * Returns the lower- and upper-bound x-axis values of the data set.\n */\nDygraph.prototype.xAxisExtremes = function() {\n  var pad = this.getNumericOption(\'xRangePad\') / this.plotter_.area.w;\n  if (this.numRows() === 0) {\n    return [0 - pad, 1 + pad];\n  }\n  var left = this.rawData_[0][0];\n  var right = this.rawData_[this.rawData_.length - 1][0];\n  if (pad) {\n    // Must keep this in sync with dygraph-layout _evaluateLimits()\n    var range = right - left;\n    left -= range * pad;\n    right += range * pad;\n  }\n  return [left, right];\n};\n\n/**\n * Returns the lower- and upper-bound y-axis values for each axis. These are\n * the ranges you\'ll get if you double-click to zoom out or call resetZoom().\n * The return value is an array of [low, high] tuples, one for each y-axis.\n */\nDygraph.prototype.yAxisExtremes = function() {\n  // TODO(danvk): this is pretty inefficient\n  const packed = this.gatherDatasets_(this.rolledSeries_, null);\n  const { extremes } = packed;\n  const saveAxes = this.axes_;\n  this.computeYAxisRanges_(extremes);\n  const newAxes = this.axes_;\n  this.axes_ = saveAxes;\n  return newAxes.map(axis => axis.extremeRange);\n}\n\n/**\n * Returns the currently-visible y-range for an axis. This can be affected by\n * zooming, panning or a call to updateOptions. Axis indices are zero-based. If\n * called with no arguments, returns the range of the first axis.\n * Returns a two-element array: [bottom, top].\n */\nDygraph.prototype.yAxisRange = function(idx) {\n  if (typeof(idx) == "undefined") idx = 0;\n  if (idx < 0 || idx >= this.axes_.length) {\n    return null;\n  }\n  var axis = this.axes_[idx];\n  return [ axis.computedValueRange[0], axis.computedValueRange[1] ];\n};\n\n/**\n * Returns the currently-visible y-ranges for each axis. This can be affected by\n * zooming, panning, calls to updateOptions, etc.\n * Returns an array of [bottom, top] pairs, one for each y-axis.\n */\nDygraph.prototype.yAxisRanges = function() {\n  var ret = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    ret.push(this.yAxisRange(i));\n  }\n  return ret;\n};\n\n// TODO(danvk): use these functions throughout dygraphs.\n/**\n * Convert from data coordinates to canvas/div X/Y coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y]\n *\n * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord\n * instead of toDomCoords(null, y, axis).\n */\nDygraph.prototype.toDomCoords = function(x, y, axis) {\n  return [ this.toDomXCoord(x), this.toDomYCoord(y, axis) ];\n};\n\n/**\n * Convert from data x coordinates to canvas/div X coordinate.\n * If specified, do this conversion for the coordinate system of a particular\n * axis.\n * Returns a single value or null if x is null.\n */\nDygraph.prototype.toDomXCoord = function(x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n  return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;\n};\n\n/**\n * Convert from data x coordinates to canvas/div Y coordinate and optional\n * axis. Uses the first axis by default.\n *\n * returns a single value or null if y is null.\n */\nDygraph.prototype.toDomYCoord = function(y, axis) {\n  var pct = this.toPercentYCoord(y, axis);\n\n  if (pct === null) {\n    return null;\n  }\n  var area = this.plotter_.area;\n  return area.y + pct * area.h;\n};\n\n/**\n * Convert from canvas/div coords to data coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y].\n *\n * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord\n * instead of toDataCoords(null, y, axis).\n */\nDygraph.prototype.toDataCoords = function(x, y, axis) {\n  return [ this.toDataXCoord(x), this.toDataYCoord(y, axis) ];\n};\n\n/**\n * Convert from canvas/div x coordinate to data coordinate.\n *\n * If x is null, this returns null.\n */\nDygraph.prototype.toDataXCoord = function(x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n\n  if (!this.attributes_.getForAxis("logscale", \'x\')) {\n    return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);\n  } else {\n    var pct = (x - area.x) / area.w;\n    return _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* logRangeFraction */ "I"](xRange[0], xRange[1], pct);\n  }\n};\n\n/**\n * Convert from canvas/div y coord to value.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n */\nDygraph.prototype.toDataYCoord = function(y, axis) {\n  if (y === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var yRange = this.yAxisRange(axis);\n\n  if (typeof(axis) == "undefined") axis = 0;\n  if (!this.attributes_.getForAxis("logscale", axis)) {\n    return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);\n  } else {\n    // Computing the inverse of toDomCoord.\n    var pct = (y - area.y) / area.h;\n    // Note reversed yRange, y1 is on top with pct==0.\n    return _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* logRangeFraction */ "I"](yRange[1], yRange[0], pct);\n  }\n};\n\n/**\n * Converts a y for an axis to a percentage from the top to the\n * bottom of the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the top of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n *\n * @param {number} y The data y-coordinate.\n * @param {number} [axis] The axis number on which the data coordinate lives.\n * @return {number} A fraction in [0, 1] where 0 = the top edge.\n */\nDygraph.prototype.toPercentYCoord = function(y, axis) {\n  if (y === null) {\n    return null;\n  }\n  if (typeof(axis) == "undefined") axis = 0;\n\n  var yRange = this.yAxisRange(axis);\n\n  var pct;\n  var logscale = this.attributes_.getForAxis("logscale", axis);\n  if (logscale) {\n    var logr0 = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](yRange[0]);\n    var logr1 = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](yRange[1]);\n    pct = (logr1 - _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](y)) / (logr1 - logr0);\n  } else {\n    // yRange[1] - y is unit distance from the bottom.\n    // yRange[1] - yRange[0] is the scale of the range.\n    // (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.\n    pct = (yRange[1] - y) / (yRange[1] - yRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Converts an x value to a percentage from the left to the right of\n * the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the left of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If x is null, this returns null.\n * @param {number} x The data x-coordinate.\n * @return {number} A fraction in [0, 1] where 0 = the left edge.\n */\nDygraph.prototype.toPercentXCoord = function(x) {\n  if (x === null) {\n    return null;\n  }\n\n  var xRange = this.xAxisRange();\n  var pct;\n  var logscale = this.attributes_.getForAxis("logscale", \'x\') ;\n  if (logscale === true) {  // logscale can be null so we test for true explicitly.\n    var logr0 = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](xRange[0]);\n    var logr1 = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](xRange[1]);\n    pct = (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* log10 */ "H"](x) - logr0) / (logr1 - logr0);\n  } else {\n    // x - xRange[0] is unit distance from the left.\n    // xRange[1] - xRange[0] is the scale of the range.\n    // The full expression below is the % from the left.\n    pct = (x - xRange[0]) / (xRange[1] - xRange[0]);\n  }\n  return pct;\n};\n\n/**\n * Returns the number of columns (including the independent variable).\n * @return {number} The number of columns.\n */\nDygraph.prototype.numColumns = function() {\n  if (!this.rawData_) return 0;\n  return this.rawData_[0] ? this.rawData_[0].length : this.attr_("labels").length;\n};\n\n/**\n * Returns the number of rows (excluding any header/label row).\n * @return {number} The number of rows, less any header.\n */\nDygraph.prototype.numRows = function() {\n  if (!this.rawData_) return 0;\n  return this.rawData_.length;\n};\n\n/**\n * Returns the value in the given row and column. If the row and column exceed\n * the bounds on the data, returns null. Also returns null if the value is\n * missing.\n * @param {number} row The row number of the data (0-based). Row 0 is the\n *     first row of data, not a header row.\n * @param {number} col The column number of the data (0-based)\n * @return {number} The value in the specified cell or null if the row/col\n *     were out of range.\n */\nDygraph.prototype.getValue = function(row, col) {\n  if (row < 0 || row > this.rawData_.length) return null;\n  if (col < 0 || col > this.rawData_[row].length) return null;\n\n  return this.rawData_[row][col];\n};\n\n/**\n * Generates interface elements for the Dygraph: a containing div, a div to\n * display the current point, and a textbox to adjust the rolling average\n * period. Also creates the Renderer/Layout elements.\n * @private\n */\nDygraph.prototype.createInterface_ = function() {\n  // Create the all-enclosing graph div\n  var enclosing = this.maindiv_;\n\n  this.graphDiv = document.createElement("div");\n\n  // TODO(danvk): any other styles that are useful to set here?\n  this.graphDiv.style.textAlign = \'left\';  // This is a CSS "reset"\n  this.graphDiv.style.position = \'relative\';\n  enclosing.appendChild(this.graphDiv);\n\n  // Create the canvas for interactive parts of the chart.\n  this.canvas_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* createCanvas */ "m"]();\n  this.canvas_.style.position = "absolute";\n\n  // ... and for static parts of the chart.\n  this.hidden_ = this.createPlotKitCanvas_(this.canvas_);\n\n  this.canvas_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* getContext */ "x"](this.canvas_);\n  this.hidden_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* getContext */ "x"](this.hidden_);\n\n  this.resizeElements_();\n\n  // The interactive parts of the graph are drawn on top of the chart.\n  this.graphDiv.appendChild(this.hidden_);\n  this.graphDiv.appendChild(this.canvas_);\n  this.mouseEventElement_ = this.createMouseEventElement_();\n\n  // Create the grapher\n  this.layout_ = new _dygraph_layout__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](this);\n\n  var dygraph = this;\n\n  this.mouseMoveHandler_ = function(e) {\n    dygraph.mouseMove_(e);\n  };\n\n  this.mouseOutHandler_ = function(e) {\n    // The mouse has left the chart if:\n    // 1. e.target is inside the chart\n    // 2. e.relatedTarget is outside the chart\n    var target = e.target || e.fromElement;\n    var relatedTarget = e.relatedTarget || e.toElement;\n    if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isNodeContainedBy */ "D"](target, dygraph.graphDiv) &&\n        !_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isNodeContainedBy */ "D"](relatedTarget, dygraph.graphDiv)) {\n      dygraph.mouseOut_(e);\n    }\n  };\n\n  this.addAndTrackEvent(window, \'mouseout\', this.mouseOutHandler_);\n  this.addAndTrackEvent(this.mouseEventElement_, \'mousemove\', this.mouseMoveHandler_);\n\n  // Don\'t recreate and register the resize handler on subsequent calls.\n  // This happens when the graph is resized.\n  if (!this.resizeHandler_) {\n    this.resizeHandler_ = function(e) {\n      dygraph.resize();\n    };\n\n    // Update when the window is resized.\n    // TODO(danvk): drop frames depending on complexity of the chart.\n    this.addAndTrackEvent(window, \'resize\', this.resizeHandler_);\n  }\n};\n\nDygraph.prototype.resizeElements_ = function() {\n  this.graphDiv.style.width = this.width_ + "px";\n  this.graphDiv.style.height = this.height_ + "px";\n\n  var pixelRatioOption = this.getNumericOption(\'pixelRatio\')\n\n  var canvasScale = pixelRatioOption || _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* getContextPixelRatio */ "y"](this.canvas_ctx_);\n  this.canvas_.width = this.width_ * canvasScale;\n  this.canvas_.height = this.height_ * canvasScale;\n  this.canvas_.style.width = this.width_ + "px";    // for IE\n  this.canvas_.style.height = this.height_ + "px";  // for IE\n  if (canvasScale !== 1) {\n    this.canvas_ctx_.scale(canvasScale, canvasScale);\n  }\n\n  var hiddenScale = pixelRatioOption || _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* getContextPixelRatio */ "y"](this.hidden_ctx_);\n  this.hidden_.width = this.width_ * hiddenScale;\n  this.hidden_.height = this.height_ * hiddenScale;\n  this.hidden_.style.width = this.width_ + "px";    // for IE\n  this.hidden_.style.height = this.height_ + "px";  // for IE\n  if (hiddenScale !== 1) {\n    this.hidden_ctx_.scale(hiddenScale, hiddenScale);\n  }\n};\n\n/**\n * Detach DOM elements in the dygraph and null out all data references.\n * Calling this when you\'re done with a dygraph can dramatically reduce memory\n * usage. See, e.g., the tests/perf.html example.\n */\nDygraph.prototype.destroy = function() {\n  this.canvas_ctx_.restore();\n  this.hidden_ctx_.restore();\n\n  // Destroy any plugins, in the reverse order that they were registered.\n  for (var i = this.plugins_.length - 1; i >= 0; i--) {\n    var p = this.plugins_.pop();\n    if (p.plugin.destroy) p.plugin.destroy();\n  }\n\n  var removeRecursive = function(node) {\n    while (node.hasChildNodes()) {\n      removeRecursive(node.firstChild);\n      node.removeChild(node.firstChild);\n    }\n  };\n\n  this.removeTrackedEvents_();\n\n  // remove mouse event handlers (This may not be necessary anymore)\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* removeEvent */ "O"](window, \'mouseout\', this.mouseOutHandler_);\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* removeEvent */ "O"](this.mouseEventElement_, \'mousemove\', this.mouseMoveHandler_);\n\n  // remove window handlers\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* removeEvent */ "O"](window,\'resize\', this.resizeHandler_);\n  this.resizeHandler_ = null;\n\n  removeRecursive(this.maindiv_);\n\n  var nullOut = function(obj) {\n    for (var n in obj) {\n      if (typeof(obj[n]) === \'object\') {\n        obj[n] = null;\n      }\n    }\n  };\n  // These may not all be necessary, but it can\'t hurt...\n  nullOut(this.layout_);\n  nullOut(this.plotter_);\n  nullOut(this);\n};\n\n/**\n * Creates the canvas on which the chart will be drawn. Only the Renderer ever\n * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots\n * or the zoom rectangles) is done on this.canvas_.\n * @param {Object} canvas The Dygraph canvas over which to overlay the plot\n * @return {Object} The newly-created canvas\n * @private\n */\nDygraph.prototype.createPlotKitCanvas_ = function(canvas) {\n  var h = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* createCanvas */ "m"]();\n  h.style.position = "absolute";\n  // TODO(danvk): h should be offset from canvas. canvas needs to include\n  // some extra area to make it easier to zoom in on the far left and far\n  // right. h needs to be precisely the plot area, so that clipping occurs.\n  h.style.top = canvas.style.top;\n  h.style.left = canvas.style.left;\n  h.width = this.width_;\n  h.height = this.height_;\n  h.style.width = this.width_ + "px";    // for IE\n  h.style.height = this.height_ + "px";  // for IE\n  return h;\n};\n\n/**\n * Creates an overlay element used to handle mouse events.\n * @return {Object} The mouse event element.\n * @private\n */\nDygraph.prototype.createMouseEventElement_ = function() {\n  return this.canvas_;\n};\n\n/**\n * Generate a set of distinct colors for the data series. This is done with a\n * color wheel. Saturation/Value are customizable, and the hue is\n * equally-spaced around the color wheel. If a custom set of colors is\n * specified, that is used instead.\n * @private\n */\nDygraph.prototype.setColors_ = function() {\n  var labels = this.getLabels();\n  var num = labels.length - 1;\n  this.colors_ = [];\n  this.colorsMap_ = {};\n\n  // These are used for when no custom colors are specified.\n  var sat = this.getNumericOption(\'colorSaturation\') || 1.0;\n  var val = this.getNumericOption(\'colorValue\') || 0.5;\n  var half = Math.ceil(num / 2);\n\n  var colors = this.getOption(\'colors\');\n  var visibility = this.visibility();\n  for (var i = 0; i < num; i++) {\n    if (!visibility[i]) {\n      continue;\n    }\n    var label = labels[i + 1];\n    var colorStr = this.attributes_.getForSeries(\'color\', label);\n    if (!colorStr) {\n      if (colors) {\n        colorStr = colors[i % colors.length];\n      } else {\n        // alternate colors for high contrast.\n        var idx = i % 2 ? (half + (i + 1)/ 2) : Math.ceil((i + 1) / 2);\n        var hue = (1.0 * idx / (1 + num));\n        colorStr = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* hsvToRGB */ "z"](hue, sat, val);\n      }\n    }\n    this.colors_.push(colorStr);\n    this.colorsMap_[label] = colorStr;\n  }\n};\n\n/**\n * Return the list of colors. This is either the list of colors passed in the\n * attributes or the autogenerated list of rgb(r,g,b) strings.\n * This does not return colors for invisible series.\n * @return {Array.<string>} The list of colors.\n */\nDygraph.prototype.getColors = function() {\n  return this.colors_;\n};\n\n/**\n * Returns a few attributes of a series, i.e. its color, its visibility, which\n * axis it\'s assigned to, and its column in the original data.\n * Returns null if the series does not exist.\n * Otherwise, returns an object with column, visibility, color and axis properties.\n * The "axis" property will be set to 1 for y1 and 2 for y2.\n * The "column" property can be fed back into getValue(row, column) to get\n * values for this series.\n */\nDygraph.prototype.getPropertiesForSeries = function(series_name) {\n  var idx = -1;\n  var labels = this.getLabels();\n  for (var i = 1; i < labels.length; i++) {\n    if (labels[i] == series_name) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) return null;\n\n  return {\n    name: series_name,\n    column: idx,\n    visible: this.visibility()[idx - 1],\n    color: this.colorsMap_[series_name],\n    axis: 1 + this.attributes_.axisForSeries(series_name)\n  };\n};\n\n/**\n * Create the text box to adjust the averaging period\n * @private\n */\nDygraph.prototype.createRollInterface_ = function() {\n  // Create a roller if one doesn\'t exist already.\n  var roller = this.roller_;\n  if (!roller) {\n    this.roller_ = roller = document.createElement("input");\n    roller.type = "text";\n    roller.style.display = "none";\n    roller.className = \'dygraph-roller\';\n    this.graphDiv.appendChild(roller);\n  }\n\n  var display = this.getBooleanOption(\'showRoller\') ? \'block\' : \'none\';\n\n  var area = this.getArea();\n  var textAttr = {\n                   "top": (area.y + area.h - 25) + "px",\n                   "left": (area.x + 1) + "px",\n                   "display": display\n                 };\n  roller.size = "2";\n  roller.value = this.rollPeriod_;\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* update */ "R"](roller.style, textAttr);\n\n  roller.onchange = () => this.adjustRoll(roller.value);\n};\n\n/**\n * Set up all the mouse handlers needed to capture dragging behavior for zoom\n * events.\n * @private\n */\nDygraph.prototype.createDragInterface_ = function() {\n  var context = {\n    // Tracks whether the mouse is down right now\n    isZooming: false,\n    isPanning: false,  // is this drag part of a pan?\n    is2DPan: false,    // if so, is that pan 1- or 2-dimensional?\n    dragStartX: null, // pixel coordinates\n    dragStartY: null, // pixel coordinates\n    dragEndX: null, // pixel coordinates\n    dragEndY: null, // pixel coordinates\n    dragDirection: null,\n    prevEndX: null, // pixel coordinates\n    prevEndY: null, // pixel coordinates\n    prevDragDirection: null,\n    cancelNextDblclick: false,  // see comment in dygraph-interaction-model.js\n\n    // The value on the left side of the graph when a pan operation starts.\n    initialLeftmostDate: null,\n\n    // The number of units each pixel spans. (This won\'t be valid for log\n    // scales)\n    xUnitsPerPixel: null,\n\n    // TODO(danvk): update this comment\n    // The range in second/value units that the viewport encompasses during a\n    // panning operation.\n    dateRange: null,\n\n    // Top-left corner of the canvas, in DOM coords\n    // TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.\n    px: 0,\n    py: 0,\n\n    // Values for use with panEdgeFraction, which limit how far outside the\n    // graph\'s data boundaries it can be panned.\n    boundedDates: null, // [minDate, maxDate]\n    boundedValues: null, // [[minValue, maxValue] ...]\n\n    // We cover iframes during mouse interactions. See comments in\n    // dygraph-utils.js for more info on why this is a good idea.\n    tarp: new _iframe_tarp__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](),\n\n    // contextB is the same thing as this context object but renamed.\n    initializeMouseDown: function(event, g, contextB) {\n      // prevents mouse drags from selecting page text.\n      if (event.preventDefault) {\n        event.preventDefault();  // Firefox, Chrome, etc.\n      } else {\n        event.returnValue = false;  // IE\n        event.cancelBubble = true;\n      }\n\n      var canvasPos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* findPos */ "v"](g.canvas_);\n      contextB.px = canvasPos.x;\n      contextB.py = canvasPos.y;\n      contextB.dragStartX = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dragGetX_ */ "t"](event, contextB);\n      contextB.dragStartY = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dragGetY_ */ "u"](event, contextB);\n      contextB.cancelNextDblclick = false;\n      contextB.tarp.cover();\n    },\n    destroy: function() {\n      var context = this;\n      if (context.isZooming || context.isPanning) {\n        context.isZooming = false;\n        context.dragStartX = null;\n        context.dragStartY = null;\n      }\n\n      if (context.isPanning) {\n        context.isPanning = false;\n        context.draggingDate = null;\n        context.dateRange = null;\n        for (var i = 0; i < self.axes_.length; i++) {\n          delete self.axes_[i].draggingValue;\n          delete self.axes_[i].dragValueRange;\n        }\n      }\n\n      context.tarp.uncover();\n    }\n  };\n\n  var interactionModel = this.getOption("interactionModel");\n\n  // Self is the graph.\n  var self = this;\n\n  // Function that binds the graph and context to the handler.\n  var bindHandler = function(handler) {\n    return function(event) {\n      handler(event, self, context);\n    };\n  };\n\n  for (var eventName in interactionModel) {\n    if (!interactionModel.hasOwnProperty(eventName)) continue;\n    this.addAndTrackEvent(this.mouseEventElement_, eventName,\n        bindHandler(interactionModel[eventName]));\n  }\n\n  // If the user releases the mouse button during a drag, but not over the\n  // canvas, then it doesn\'t count as a zooming action.\n  if (!interactionModel.willDestroyContextMyself) {\n    var mouseUpHandler = function(event) {\n      context.destroy();\n    };\n\n    this.addAndTrackEvent(document, \'mouseup\', mouseUpHandler);\n  }\n};\n\n/**\n * Draw a gray zoom rectangle over the desired area of the canvas. Also clears\n * up any previous zoom rectangles that were drawn. This could be optimized to\n * avoid extra redrawing, but it\'s tricky to avoid interactions with the status\n * dots.\n *\n * @param {number} direction the direction of the zoom rectangle. Acceptable\n *     values are utils.HORIZONTAL and utils.VERTICAL.\n * @param {number} startX The X position where the drag started, in canvas\n *     coordinates.\n * @param {number} endX The current X position of the drag, in canvas coords.\n * @param {number} startY The Y position where the drag started, in canvas\n *     coordinates.\n * @param {number} endY The current Y position of the drag, in canvas coords.\n * @param {number} prevDirection the value of direction on the previous call to\n *     this function. Used to avoid excess redrawing\n * @param {number} prevEndX The value of endX on the previous call to this\n *     function. Used to avoid excess redrawing\n * @param {number} prevEndY The value of endY on the previous call to this\n *     function. Used to avoid excess redrawing\n * @private\n */\nDygraph.prototype.drawZoomRect_ = function(direction, startX, endX, startY,\n                                           endY, prevDirection, prevEndX,\n                                           prevEndY) {\n  var ctx = this.canvas_ctx_;\n\n  // Clean up from the previous rect if necessary\n  if (prevDirection == _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* HORIZONTAL */ "f"]) {\n    ctx.clearRect(Math.min(startX, prevEndX), this.layout_.getPlotArea().y,\n                  Math.abs(startX - prevEndX), this.layout_.getPlotArea().h);\n  } else if (prevDirection == _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* VERTICAL */ "h"]) {\n    ctx.clearRect(this.layout_.getPlotArea().x, Math.min(startY, prevEndY),\n                  this.layout_.getPlotArea().w, Math.abs(startY - prevEndY));\n  }\n\n  // Draw a light-grey rectangle to show the new viewing area\n  if (direction == _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* HORIZONTAL */ "f"]) {\n    if (endX && startX) {\n      ctx.fillStyle = "rgba(128,128,128,0.33)";\n      ctx.fillRect(Math.min(startX, endX), this.layout_.getPlotArea().y,\n                   Math.abs(endX - startX), this.layout_.getPlotArea().h);\n    }\n  } else if (direction == _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* VERTICAL */ "h"]) {\n    if (endY && startY) {\n      ctx.fillStyle = "rgba(128,128,128,0.33)";\n      ctx.fillRect(this.layout_.getPlotArea().x, Math.min(startY, endY),\n                   this.layout_.getPlotArea().w, Math.abs(endY - startY));\n    }\n  }\n};\n\n/**\n * Clear the zoom rectangle (and perform no zoom).\n * @private\n */\nDygraph.prototype.clearZoomRect_ = function() {\n  this.currentZoomRectArgs_ = null;\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n};\n\n/**\n * Zoom to something containing [lowX, highX]. These are pixel coordinates in\n * the canvas. The exact zoom window may be slightly larger if there are no data\n * points near lowX or highX. Don\'t confuse this function with doZoomXDates,\n * which accepts dates that match the raw data. This function redraws the graph.\n *\n * @param {number} lowX The leftmost pixel value that should be visible.\n * @param {number} highX The rightmost pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomX_ = function(lowX, highX) {\n  this.currentZoomRectArgs_ = null;\n  // Find the earliest and latest dates contained in this canvasx range.\n  // Convert the call to date ranges of the raw data.\n  var minDate = this.toDataXCoord(lowX);\n  var maxDate = this.toDataXCoord(highX);\n  this.doZoomXDates_(minDate, maxDate);\n};\n\n/**\n * Zoom to something containing [minDate, maxDate] values. Don\'t confuse this\n * method with doZoomX which accepts pixel coordinates. This function redraws\n * the graph.\n *\n * @param {number} minDate The minimum date that should be visible.\n * @param {number} maxDate The maximum date that should be visible.\n * @private\n */\nDygraph.prototype.doZoomXDates_ = function(minDate, maxDate) {\n  // TODO(danvk): when xAxisRange is null (i.e. "fit to data", the animation\n  // can produce strange effects. Rather than the x-axis transitioning slowly\n  // between values, it can jerk around.)\n  var old_window = this.xAxisRange();\n  var new_window = [minDate, maxDate];\n  const zoomCallback = this.getFunctionOption(\'zoomCallback\');\n  this.doAnimatedZoom(old_window, new_window, null, null, () => {\n    if (zoomCallback) {\n      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Zoom to something containing [lowY, highY]. These are pixel coordinates in\n * the canvas. This function redraws the graph.\n *\n * @param {number} lowY The topmost pixel value that should be visible.\n * @param {number} highY The lowest pixel value that should be visible.\n * @private\n */\nDygraph.prototype.doZoomY_ = function(lowY, highY) {\n  this.currentZoomRectArgs_ = null;\n  // Find the highest and lowest values in pixel range for each axis.\n  // Note that lowY (in pixels) corresponds to the max Value (in data coords).\n  // This is because pixels increase as you go down on the screen, whereas data\n  // coordinates increase as you go up the screen.\n  var oldValueRanges = this.yAxisRanges();\n  var newValueRanges = [];\n  for (var i = 0; i < this.axes_.length; i++) {\n    var hi = this.toDataYCoord(lowY, i);\n    var low = this.toDataYCoord(highY, i);\n    newValueRanges.push([low, hi]);\n  }\n\n  const zoomCallback = this.getFunctionOption(\'zoomCallback\');\n  this.doAnimatedZoom(null, null, oldValueRanges, newValueRanges, () => {\n    if (zoomCallback) {\n      const [minX, maxX] = this.xAxisRange();\n      zoomCallback.call(this, minX, maxX, this.yAxisRanges());\n    }\n  });\n};\n\n/**\n * Transition function to use in animations. Returns values between 0.0\n * (totally old values) and 1.0 (totally new values) for each frame.\n * @private\n */\nDygraph.zoomAnimationFunction = function(frame, numFrames) {\n  var k = 1.5;\n  return (1.0 - Math.pow(k, -frame)) / (1.0 - Math.pow(k, -numFrames));\n};\n\n/**\n * Reset the zoom to the original view coordinates. This is the same as\n * double-clicking on the graph.\n */\nDygraph.prototype.resetZoom = function() {\n  const dirtyX = this.isZoomed(\'x\');\n  const dirtyY = this.isZoomed(\'y\');\n  const dirty = dirtyX || dirtyY;\n\n  // Clear any selection, since it\'s likely to be drawn in the wrong place.\n  this.clearSelection();\n\n  if (!dirty) return;\n\n  // Calculate extremes to avoid lack of padding on reset.\n  const [minDate, maxDate] = this.xAxisExtremes();\n\n  const animatedZooms = this.getBooleanOption(\'animatedZooms\');\n  const zoomCallback = this.getFunctionOption(\'zoomCallback\');\n\n  // TODO(danvk): merge this block w/ the code below.\n  // TODO(danvk): factor out a generic, public zoomTo method.\n  if (!animatedZooms) {\n    this.dateWindow_ = null;\n    this.axes_.forEach(axis => {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n\n    this.drawGraph_();\n    if (zoomCallback) {\n      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n    }\n    return;\n  }\n\n  var oldWindow=null, newWindow=null, oldValueRanges=null, newValueRanges=null;\n  if (dirtyX) {\n    oldWindow = this.xAxisRange();\n    newWindow = [minDate, maxDate];\n  }\n\n  if (dirtyY) {\n    oldValueRanges = this.yAxisRanges();\n    newValueRanges = this.yAxisExtremes();\n  }\n\n  this.doAnimatedZoom(oldWindow, newWindow, oldValueRanges, newValueRanges,\n      () => {\n        this.dateWindow_ = null;\n        this.axes_.forEach(axis => {\n          if (axis.valueRange) delete axis.valueRange;\n        });\n        if (zoomCallback) {\n          zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n        }\n      });\n};\n\n/**\n * Combined animation logic for all zoom functions.\n * either the x parameters or y parameters may be null.\n * @private\n */\nDygraph.prototype.doAnimatedZoom = function(oldXRange, newXRange, oldYRanges, newYRanges, callback) {\n  var steps = this.getBooleanOption("animatedZooms") ?\n      Dygraph.ANIMATION_STEPS : 1;\n\n  var windows = [];\n  var valueRanges = [];\n  var step, frac;\n\n  if (oldXRange !== null && newXRange !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      windows[step-1] = [oldXRange[0]*(1-frac) + frac*newXRange[0],\n                         oldXRange[1]*(1-frac) + frac*newXRange[1]];\n    }\n  }\n\n  if (oldYRanges !== null && newYRanges !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      var thisRange = [];\n      for (var j = 0; j < this.axes_.length; j++) {\n        thisRange.push([oldYRanges[j][0]*(1-frac) + frac*newYRanges[j][0],\n                        oldYRanges[j][1]*(1-frac) + frac*newYRanges[j][1]]);\n      }\n      valueRanges[step-1] = thisRange;\n    }\n  }\n\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* repeatAndCleanup */ "P"](step => {\n    if (valueRanges.length) {\n      for (var i = 0; i < this.axes_.length; i++) {\n        var w = valueRanges[step][i];\n        this.axes_[i].valueRange = [w[0], w[1]];\n      }\n    }\n    if (windows.length) {\n      this.dateWindow_ = windows[step];\n    }\n    this.drawGraph_();\n  }, steps, Dygraph.ANIMATION_DURATION / steps, callback);\n};\n\n/**\n * Get the current graph\'s area object.\n *\n * Returns: {x, y, w, h}\n */\nDygraph.prototype.getArea = function() {\n  return this.plotter_.area;\n};\n\n/**\n * Convert a mouse event to DOM coordinates relative to the graph origin.\n *\n * Returns a two-element array: [X, Y].\n */\nDygraph.prototype.eventToDomCoords = function(event) {\n  if (event.offsetX && event.offsetY) {\n    return [ event.offsetX, event.offsetY ];\n  } else {\n    var eventElementPos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* findPos */ "v"](this.mouseEventElement_);\n    var canvasx = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* pageX */ "L"](event) - eventElementPos.x;\n    var canvasy = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* pageY */ "M"](event) - eventElementPos.y;\n    return [canvasx, canvasy];\n  }\n};\n\n/**\n * Given a canvas X coordinate, find the closest row.\n * @param {number} domX graph-relative DOM X coordinate\n * Returns {number} row number.\n * @private\n */\nDygraph.prototype.findClosestRow = function(domX) {\n  var minDistX = Infinity;\n  var closestRow = -1;\n  var sets = this.layout_.points;\n  for (var i = 0; i < sets.length; i++) {\n    var points = sets[i];\n    var len = points.length;\n    for (var j = 0; j < len; j++) {\n      var point = points[j];\n      if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isValidPoint */ "G"](point, true)) continue;\n      var dist = Math.abs(point.canvasx - domX);\n      if (dist < minDistX) {\n        minDistX = dist;\n        closestRow = point.idx;\n      }\n    }\n  }\n\n  return closestRow;\n};\n\n/**\n * Given canvas X,Y coordinates, find the closest point.\n *\n * This finds the individual data point across all visible series\n * that\'s closest to the supplied DOM coordinates using the standard\n * Euclidean X,Y distance.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findClosestPoint = function(domX, domY) {\n  var minDist = Infinity;\n  var dist, dx, dy, point, closestPoint, closestSeries, closestRow;\n  for ( var setIdx = this.layout_.points.length - 1 ; setIdx >= 0 ; --setIdx ) {\n    var points = this.layout_.points[setIdx];\n    for (var i = 0; i < points.length; ++i) {\n      point = points[i];\n      if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isValidPoint */ "G"](point)) continue;\n      dx = point.canvasx - domX;\n      dy = point.canvasy - domY;\n      dist = dx * dx + dy * dy;\n      if (dist < minDist) {\n        minDist = dist;\n        closestPoint = point;\n        closestSeries = setIdx;\n        closestRow = point.idx;\n      }\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: closestRow,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * Given canvas X,Y coordinates, find the touched area in a stacked graph.\n *\n * This first finds the X data point closest to the supplied DOM X coordinate,\n * then finds the series which puts the Y coordinate on top of its filled area,\n * using linear interpolation between adjacent point pairs.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\nDygraph.prototype.findStackedPoint = function(domX, domY) {\n  var row = this.findClosestRow(domX);\n  var closestPoint, closestSeries;\n  for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n    var boundary = this.getLeftBoundary_(setIdx);\n    var rowIdx = row - boundary;\n    var points = this.layout_.points[setIdx];\n    if (rowIdx >= points.length) continue;\n    var p1 = points[rowIdx];\n    if (!_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isValidPoint */ "G"](p1)) continue;\n    var py = p1.canvasy;\n    if (domX > p1.canvasx && rowIdx + 1 < points.length) {\n      // interpolate series Y value using next point\n      var p2 = points[rowIdx + 1];\n      if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isValidPoint */ "G"](p2)) {\n        var dx = p2.canvasx - p1.canvasx;\n        if (dx > 0) {\n          var r = (domX - p1.canvasx) / dx;\n          py += r * (p2.canvasy - p1.canvasy);\n        }\n      }\n    } else if (domX < p1.canvasx && rowIdx > 0) {\n      // interpolate series Y value using previous point\n      var p0 = points[rowIdx - 1];\n      if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isValidPoint */ "G"](p0)) {\n        var dx = p1.canvasx - p0.canvasx;\n        if (dx > 0) {\n          var r = (p1.canvasx - domX) / dx;\n          py += r * (p0.canvasy - p1.canvasy);\n        }\n      }\n    }\n    // Stop if the point (domX, py) is above this series\' upper edge\n    if (setIdx === 0 || py < domY) {\n      closestPoint = p1;\n      closestSeries = setIdx;\n    }\n  }\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: row,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n\n/**\n * When the mouse moves in the canvas, display information about a nearby data\n * point and draw dots over those points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @param {Object} event The mousemove event from the browser.\n * @private\n */\nDygraph.prototype.mouseMove_ = function(event) {\n  // This prevents JS errors when mousing over the canvas before data loads.\n  var points = this.layout_.points;\n  if (points === undefined || points === null) return;\n\n  var canvasCoords = this.eventToDomCoords(event);\n  var canvasx = canvasCoords[0];\n  var canvasy = canvasCoords[1];\n\n  var highlightSeriesOpts = this.getOption("highlightSeriesOpts");\n  var selectionChanged = false;\n  if (highlightSeriesOpts && !this.isSeriesLocked()) {\n    var closest;\n    if (this.getBooleanOption("stackedGraph")) {\n      closest = this.findStackedPoint(canvasx, canvasy);\n    } else {\n      closest = this.findClosestPoint(canvasx, canvasy);\n    }\n    selectionChanged = this.setSelection(closest.row, closest.seriesName);\n  } else {\n    var idx = this.findClosestRow(canvasx);\n    selectionChanged = this.setSelection(idx);\n  }\n\n  var callback = this.getFunctionOption("highlightCallback");\n  if (callback && selectionChanged) {\n    callback.call(this, event,\n        this.lastx_,\n        this.selPoints_,\n        this.lastRow_,\n        this.highlightSet_);\n  }\n};\n\n/**\n * Fetch left offset from the specified set index or if not passed, the\n * first defined boundaryIds record (see bug #236).\n * @private\n */\nDygraph.prototype.getLeftBoundary_ = function(setIdx) {\n  if (this.boundaryIds_[setIdx]) {\n      return this.boundaryIds_[setIdx][0];\n  } else {\n    for (var i = 0; i < this.boundaryIds_.length; i++) {\n      if (this.boundaryIds_[i] !== undefined) {\n        return this.boundaryIds_[i][0];\n      }\n    }\n    return 0;\n  }\n};\n\nDygraph.prototype.animateSelection_ = function(direction) {\n  var totalSteps = 10;\n  var millis = 30;\n  if (this.fadeLevel === undefined) this.fadeLevel = 0;\n  if (this.animateId === undefined) this.animateId = 0;\n  var start = this.fadeLevel;\n  var steps = direction < 0 ? start : totalSteps - start;\n  if (steps <= 0) {\n    if (this.fadeLevel) {\n      this.updateSelection_(1.0);\n    }\n    return;\n  }\n\n  var thisId = ++this.animateId;\n  var that = this;\n  var cleanupIfClearing = function() {\n    // if we haven\'t reached fadeLevel 0 in the max frame time,\n    // ensure that the clear happens and just go to 0\n    if (that.fadeLevel !== 0 && direction < 0) {\n      that.fadeLevel = 0;\n      that.clearSelection();\n    }\n  };\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* repeatAndCleanup */ "P"](\n    function(n) {\n      // ignore simultaneous animations\n      if (that.animateId != thisId) return;\n\n      that.fadeLevel += direction;\n      if (that.fadeLevel === 0) {\n        that.clearSelection();\n      } else {\n        that.updateSelection_(that.fadeLevel / totalSteps);\n      }\n    },\n    steps, millis, cleanupIfClearing);\n};\n\n/**\n * Draw dots over the selectied points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @private\n */\nDygraph.prototype.updateSelection_ = function(opt_animFraction) {\n  /*var defaultPrevented = */\n  this.cascadeEvents_(\'select\', {\n    selectedRow: this.lastRow_ === -1 ? undefined : this.lastRow_,\n    selectedX: this.lastx_ === -1 ? undefined : this.lastx_,\n    selectedPoints: this.selPoints_\n  });\n  // TODO(danvk): use defaultPrevented here?\n\n  // Clear the previously drawn vertical, if there is one\n  var i;\n  var ctx = this.canvas_ctx_;\n  if (this.getOption(\'highlightSeriesOpts\')) {\n    ctx.clearRect(0, 0, this.width_, this.height_);\n    var alpha = 1.0 - this.getNumericOption(\'highlightSeriesBackgroundAlpha\');\n    var backgroundColor = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* toRGB_ */ "Q"](this.getOption(\'highlightSeriesBackgroundColor\'));\n\n    if (alpha) {\n      // Activating background fade includes an animation effect for a gradual\n      // fade. TODO(klausw): make this independently configurable if it causes\n      // issues? Use a shared preference to control animations?\n      var animateBackgroundFade = true;\n      if (animateBackgroundFade) {\n        if (opt_animFraction === undefined) {\n          // start a new animation\n          this.animateSelection_(1);\n          return;\n        }\n        alpha *= opt_animFraction;\n      }\n      ctx.fillStyle = \'rgba(\' + backgroundColor.r + \',\' + backgroundColor.g + \',\' + backgroundColor.b + \',\' + alpha + \')\';\n      ctx.fillRect(0, 0, this.width_, this.height_);\n    }\n\n    // Redraw only the highlighted series in the interactive canvas (not the\n    // static plot canvas, which is where series are usually drawn).\n    this.plotter_._renderLineChart(this.highlightSet_, ctx);\n  } else if (this.previousVerticalX_ >= 0) {\n    // Determine the maximum highlight circle size.\n    var maxCircleSize = 0;\n    var labels = this.attr_(\'labels\');\n    for (i = 1; i < labels.length; i++) {\n      var r = this.getNumericOption(\'highlightCircleSize\', labels[i]);\n      if (r > maxCircleSize) maxCircleSize = r;\n    }\n    var px = this.previousVerticalX_;\n    ctx.clearRect(px - maxCircleSize - 1, 0,\n                  2 * maxCircleSize + 2, this.height_);\n  }\n\n  if (this.selPoints_.length > 0) {\n    // Draw colored circles over the center of each selected point\n    var canvasx = this.selPoints_[0].canvasx;\n    ctx.save();\n    for (i = 0; i < this.selPoints_.length; i++) {\n      var pt = this.selPoints_[i];\n      if (isNaN(pt.canvasy)) continue;\n\n      var circleSize = this.getNumericOption(\'highlightCircleSize\', pt.name);\n      var callback = this.getFunctionOption("drawHighlightPointCallback", pt.name);\n      var color = this.plotter_.colors[pt.name];\n      if (!callback) {\n        callback = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* Circles */ "a"].DEFAULT;\n      }\n      ctx.lineWidth = this.getNumericOption(\'strokeWidth\', pt.name);\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      callback.call(this, this, pt.name, ctx, canvasx, pt.canvasy,\n          color, circleSize, pt.idx);\n    }\n    ctx.restore();\n\n    this.previousVerticalX_ = canvasx;\n  }\n};\n\n/**\n * Manually set the selected points and display information about them in the\n * legend. The selection can be cleared using clearSelection() and queried\n * using getSelection().\n *\n * To set a selected series but not a selected point, call setSelection with\n * row=false and the selected series name.\n *\n * @param {number} row Row number that should be highlighted (i.e. appear with\n * hover dots on the chart).\n * @param {seriesName} optional series name to highlight that series with the\n * the highlightSeriesOpts setting.\n * @param { locked } optional If true, keep seriesName selected when mousing\n * over the graph, disabling closest-series highlighting. Call clearSelection()\n * to unlock it.\n */\nDygraph.prototype.setSelection = function(row, opt_seriesName, opt_locked) {\n  // Extract the points we\'ve selected\n  this.selPoints_ = [];\n\n  var changed = false;\n  if (row !== false && row >= 0) {\n    if (row != this.lastRow_) changed = true;\n    this.lastRow_ = row;\n    for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n      var points = this.layout_.points[setIdx];\n      // Check if the point at the appropriate index is the point we\'re looking\n      // for.  If it is, just use it, otherwise search the array for a point\n      // in the proper place.\n      var setRow = row - this.getLeftBoundary_(setIdx);\n      if (setRow >= 0 && setRow < points.length && points[setRow].idx == row) {\n        var point = points[setRow];\n        if (point.yval !== null) this.selPoints_.push(point);\n      } else {\n        for (var pointIdx = 0; pointIdx < points.length; ++pointIdx) {\n          var point = points[pointIdx];\n          if (point.idx == row) {\n            if (point.yval !== null) {\n              this.selPoints_.push(point);\n            }\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    if (this.lastRow_ >= 0) changed = true;\n    this.lastRow_ = -1;\n  }\n\n  if (this.selPoints_.length) {\n    this.lastx_ = this.selPoints_[0].xval;\n  } else {\n    this.lastx_ = -1;\n  }\n\n  if (opt_seriesName !== undefined) {\n    if (this.highlightSet_ !== opt_seriesName) changed = true;\n    this.highlightSet_ = opt_seriesName;\n  }\n\n  if (opt_locked !== undefined) {\n    this.lockedSet_ = opt_locked;\n  }\n\n  if (changed) {\n    this.updateSelection_(undefined);\n  }\n  return changed;\n};\n\n/**\n * The mouse has left the canvas. Clear out whatever artifacts remain\n * @param {Object} event the mouseout event from the browser.\n * @private\n */\nDygraph.prototype.mouseOut_ = function(event) {\n  if (this.getFunctionOption("unhighlightCallback")) {\n    this.getFunctionOption("unhighlightCallback").call(this, event);\n  }\n\n  if (this.getBooleanOption("hideOverlayOnMouseOut") && !this.lockedSet_) {\n    this.clearSelection();\n  }\n};\n\n/**\n * Clears the current selection (i.e. points that were highlighted by moving\n * the mouse over the chart).\n */\nDygraph.prototype.clearSelection = function() {\n  this.cascadeEvents_(\'deselect\', {});\n\n  this.lockedSet_ = false;\n  // Get rid of the overlay data\n  if (this.fadeLevel) {\n    this.animateSelection_(-1);\n    return;\n  }\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n  this.fadeLevel = 0;\n  this.selPoints_ = [];\n  this.lastx_ = -1;\n  this.lastRow_ = -1;\n  this.highlightSet_ = null;\n};\n\n/**\n * Returns the number of the currently selected row. To get data for this row,\n * you can use the getValue method.\n * @return {number} row number, or -1 if nothing is selected\n */\nDygraph.prototype.getSelection = function() {\n  if (!this.selPoints_ || this.selPoints_.length < 1) {\n    return -1;\n  }\n\n  for (var setIdx = 0; setIdx < this.layout_.points.length; setIdx++) {\n    var points = this.layout_.points[setIdx];\n    for (var row = 0; row < points.length; row++) {\n      if (points[row].x == this.selPoints_[0].x) {\n        return points[row].idx;\n      }\n    }\n  }\n  return -1;\n};\n\n/**\n * Returns the name of the currently-highlighted series.\n * Only available when the highlightSeriesOpts option is in use.\n */\nDygraph.prototype.getHighlightSeries = function() {\n  return this.highlightSet_;\n};\n\n/**\n * Returns true if the currently-highlighted series was locked\n * via setSelection(..., seriesName, true).\n */\nDygraph.prototype.isSeriesLocked = function() {\n  return this.lockedSet_;\n};\n\n/**\n * Fires when there\'s data available to be graphed.\n * @param {string} data Raw CSV data to be plotted\n * @private\n */\nDygraph.prototype.loadedEvent_ = function(data) {\n  this.rawData_ = this.parseCSV_(data);\n  this.cascadeDataDidUpdateEvent_();\n  this.predraw_();\n};\n\n/**\n * Add ticks on the x-axis representing years, months, quarters, weeks, or days\n * @private\n */\nDygraph.prototype.addXTicks_ = function() {\n  // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...\n  var range;\n  if (this.dateWindow_) {\n    range = [this.dateWindow_[0], this.dateWindow_[1]];\n  } else {\n    range = this.xAxisExtremes();\n  }\n\n  var xAxisOptionsView = this.optionsViewForAxis_(\'x\');\n  var xTicks = xAxisOptionsView(\'ticker\')(\n      range[0],\n      range[1],\n      this.plotter_.area.w,  // TODO(danvk): should be area.width\n      xAxisOptionsView,\n      this);\n  // var msg = \'ticker(\' + range[0] + \', \' + range[1] + \', \' + this.width_ + \', \' + this.attr_(\'pixelsPerXLabel\') + \') -> \' + JSON.stringify(xTicks);\n  // console.log(msg);\n  this.layout_.setXTicks(xTicks);\n};\n\n/**\n * Returns the correct handler class for the currently set options.\n * @private\n */\nDygraph.prototype.getHandlerClass_ = function() {\n  var handlerClass;\n  if (this.attr_(\'dataHandler\')) {\n    handlerClass =  this.attr_(\'dataHandler\');\n  } else if (this.fractions_) {\n    if (this.getBooleanOption(\'errorBars\')) {\n      handlerClass = _datahandler_bars_fractions__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"];\n    } else {\n      handlerClass = _datahandler_default_fractions__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"];\n    }\n  } else if (this.getBooleanOption(\'customBars\')) {\n    handlerClass = _datahandler_bars_custom__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"];\n  } else if (this.getBooleanOption(\'errorBars\')) {\n    handlerClass = _datahandler_bars_error__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"];\n  } else {\n    handlerClass = _datahandler_default__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"];\n  }\n  return handlerClass;\n};\n\n/**\n * @private\n * This function is called once when the chart\'s data is changed or the options\n * dictionary is updated. It is _not_ called when the user pans or zooms. The\n * idea is that values derived from the chart\'s data can be computed here,\n * rather than every time the chart is drawn. This includes things like the\n * number of axes, rolling averages, etc.\n */\nDygraph.prototype.predraw_ = function() {\n  var start = new Date();\n\n  // Create the correct dataHandler\n  this.dataHandler_ = new (this.getHandlerClass_())();\n\n  this.layout_.computePlotArea();\n\n  // TODO(danvk): move more computations out of drawGraph_ and into here.\n  this.computeYAxes_();\n\n  if (!this.is_initial_draw_) {\n    this.canvas_ctx_.restore();\n    this.hidden_ctx_.restore();\n  }\n\n  this.canvas_ctx_.save();\n  this.hidden_ctx_.save();\n\n  // Create a new plotter.\n  this.plotter_ = new _dygraph_canvas__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](this,\n                                            this.hidden_,\n                                            this.hidden_ctx_,\n                                            this.layout_);\n\n  // The roller sits in the bottom left corner of the chart. We don\'t know where\n  // this will be until the options are available, so it\'s positioned here.\n  this.createRollInterface_();\n\n  this.cascadeEvents_(\'predraw\');\n\n  // Convert the raw data (a 2D array) into the internal format and compute\n  // rolling averages.\n  this.rolledSeries_ = [null];  // x-axis is the first series and it\'s special\n  for (var i = 1; i < this.numColumns(); i++) {\n    // var logScale = this.attr_(\'logscale\', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.\n    var series = this.dataHandler_.extractSeries(this.rawData_, i, this.attributes_);\n    if (this.rollPeriod_ > 1) {\n      series = this.dataHandler_.rollingAverage(series, this.rollPeriod_, this.attributes_);\n    }\n\n    this.rolledSeries_.push(series);\n  }\n\n  // If the data or options have changed, then we\'d better redraw.\n  this.drawGraph_();\n\n  // This is used to determine whether to do various animations.\n  var end = new Date();\n  this.drawingTimeMs_ = (end - start);\n};\n\n/**\n * Point structure.\n *\n * xval_* and yval_* are the original unscaled data values,\n * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.\n * yval_stacked is the cumulative Y value used for stacking graphs,\n * and bottom/top/minus/plus are used for error bar graphs.\n *\n * @typedef {{\n *     idx: number,\n *     name: string,\n *     x: ?number,\n *     xval: ?number,\n *     y_bottom: ?number,\n *     y: ?number,\n *     y_stacked: ?number,\n *     y_top: ?number,\n *     yval_minus: ?number,\n *     yval: ?number,\n *     yval_plus: ?number,\n *     yval_stacked\n * }}\n */\nDygraph.PointType = undefined;\n\n/**\n * Calculates point stacking for stackedGraph=true.\n *\n * For stacking purposes, interpolate or extend neighboring data across\n * NaN values based on stackedGraphNaNFill settings. This is for display\n * only, the underlying data value as shown in the legend remains NaN.\n *\n * @param {Array.<Dygraph.PointType>} points Point array for a single series.\n *     Updates each Point\'s yval_stacked property.\n * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y\n *     values for the series seen so far. Index is the row number. Updated\n *     based on the current series\'s values.\n * @param {Array.<number>} seriesExtremes Min and max values, updated\n *     to reflect the stacked values.\n * @param {string} fillMethod Interpolation method, one of \'all\', \'inside\', or\n *     \'none\'.\n * @private\n */\nDygraph.stackPoints_ = function(\n    points, cumulativeYval, seriesExtremes, fillMethod) {\n  var lastXval = null;\n  var prevPoint = null;\n  var nextPoint = null;\n  var nextPointIdx = -1;\n\n  // Find the next stackable point starting from the given index.\n  var updateNextPoint = function(idx) {\n    // If we\'ve previously found a non-NaN point and haven\'t gone past it yet,\n    // just use that.\n    if (nextPointIdx >= idx) return;\n\n    // We haven\'t found a non-NaN point yet or have moved past it,\n    // look towards the right to find a non-NaN point.\n    for (var j = idx; j < points.length; ++j) {\n      // Clear out a previously-found point (if any) since it\'s no longer\n      // valid, we shouldn\'t use it for interpolation anymore.\n      nextPoint = null;\n      if (!isNaN(points[j].yval) && points[j].yval !== null) {\n        nextPointIdx = j;\n        nextPoint = points[j];\n        break;\n      }\n    }\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    var point = points[i];\n    var xval = point.xval;\n    if (cumulativeYval[xval] === undefined) {\n      cumulativeYval[xval] = 0;\n    }\n\n    var actualYval = point.yval;\n    if (isNaN(actualYval) || actualYval === null) {\n      if(fillMethod == \'none\') {\n        actualYval = 0;\n      } else {\n        // Interpolate/extend for stacking purposes if possible.\n        updateNextPoint(i);\n        if (prevPoint && nextPoint && fillMethod != \'none\') {\n          // Use linear interpolation between prevPoint and nextPoint.\n          actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n              ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n        } else if (prevPoint && fillMethod == \'all\') {\n          actualYval = prevPoint.yval;\n        } else if (nextPoint && fillMethod == \'all\') {\n          actualYval = nextPoint.yval;\n        } else {\n          actualYval = 0;\n        }\n      }\n    } else {\n      prevPoint = point;\n    }\n\n    var stackedYval = cumulativeYval[xval];\n    if (lastXval != xval) {\n      // If an x-value is repeated, we ignore the duplicates.\n      stackedYval += actualYval;\n      cumulativeYval[xval] = stackedYval;\n    }\n    lastXval = xval;\n\n    point.yval_stacked = stackedYval;\n\n    if (stackedYval > seriesExtremes[1]) {\n      seriesExtremes[1] = stackedYval;\n    }\n    if (stackedYval < seriesExtremes[0]) {\n      seriesExtremes[0] = stackedYval;\n    }\n  }\n};\n\n\n/**\n * Loop over all fields and create datasets, calculating extreme y-values for\n * each series and extreme x-indices as we go.\n *\n * dateWindow is passed in as an explicit parameter so that we can compute\n * extreme values "speculatively", i.e. without actually setting state on the\n * dygraph.\n *\n * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where\n *     rolledSeries[seriesIndex][row] = raw point, where\n *     seriesIndex is the column number starting with 1, and\n *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].\n * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.\n * @return {{\n *     points: Array.<Array.<Dygraph.PointType>>,\n *     seriesExtremes: Array.<Array.<number>>,\n *     boundaryIds: Array.<number>}}\n * @private\n */\nDygraph.prototype.gatherDatasets_ = function(rolledSeries, dateWindow) {\n  var boundaryIds = [];\n  var points = [];\n  var cumulativeYval = [];  // For stacked series.\n  var extremes = {};  // series name -> [low, high]\n  var seriesIdx, sampleIdx;\n  var firstIdx, lastIdx;\n  var axisIdx;\n\n  // Loop over the fields (series).  Go from the last to the first,\n  // because if they\'re stacked that\'s how we accumulate the values.\n  var num_series = rolledSeries.length - 1;\n  var series;\n  for (seriesIdx = num_series; seriesIdx >= 1; seriesIdx--) {\n    if (!this.visibility()[seriesIdx - 1]) continue;\n\n    // Prune down to the desired range, if necessary (for zooming)\n    // Because there can be lines going to points outside of the visible area,\n    // we actually prune to visible points, plus one on either side.\n    if (dateWindow) {\n      series = rolledSeries[seriesIdx];\n      var low = dateWindow[0];\n      var high = dateWindow[1];\n\n      // TODO(danvk): do binary search instead of linear search.\n      // TODO(danvk): pass firstIdx and lastIdx directly to the renderer.\n      firstIdx = null;\n      lastIdx = null;\n      for (sampleIdx = 0; sampleIdx < series.length; sampleIdx++) {\n        if (series[sampleIdx][0] >= low && firstIdx === null) {\n          firstIdx = sampleIdx;\n        }\n        if (series[sampleIdx][0] <= high) {\n          lastIdx = sampleIdx;\n        }\n      }\n\n      if (firstIdx === null) firstIdx = 0;\n      var correctedFirstIdx = firstIdx;\n      var isInvalidValue = true;\n      while (isInvalidValue && correctedFirstIdx > 0) {\n        correctedFirstIdx--;\n        // check if the y value is null.\n        isInvalidValue = series[correctedFirstIdx][1] === null;\n      }\n\n      if (lastIdx === null) lastIdx = series.length - 1;\n      var correctedLastIdx = lastIdx;\n      isInvalidValue = true;\n      while (isInvalidValue && correctedLastIdx < series.length - 1) {\n        correctedLastIdx++;\n        isInvalidValue = series[correctedLastIdx][1] === null;\n      }\n\n      if (correctedFirstIdx!==firstIdx) {\n        firstIdx = correctedFirstIdx;\n      }\n      if (correctedLastIdx !== lastIdx) {\n        lastIdx = correctedLastIdx;\n      }\n\n      boundaryIds[seriesIdx-1] = [firstIdx, lastIdx];\n\n      // .slice\'s end is exclusive, we want to include lastIdx.\n      series = series.slice(firstIdx, lastIdx + 1);\n    } else {\n      series = rolledSeries[seriesIdx];\n      boundaryIds[seriesIdx-1] = [0, series.length-1];\n    }\n\n    var seriesName = this.attr_("labels")[seriesIdx];\n    var seriesExtremes = this.dataHandler_.getExtremeYValues(series,\n        dateWindow, this.getBooleanOption("stepPlot",seriesName));\n\n    var seriesPoints = this.dataHandler_.seriesToPoints(series,\n        seriesName, boundaryIds[seriesIdx-1][0]);\n\n    if (this.getBooleanOption("stackedGraph")) {\n      axisIdx = this.attributes_.axisForSeries(seriesName);\n      if (cumulativeYval[axisIdx] === undefined) {\n        cumulativeYval[axisIdx] = [];\n      }\n      Dygraph.stackPoints_(seriesPoints, cumulativeYval[axisIdx], seriesExtremes,\n                           this.getBooleanOption("stackedGraphNaNFill"));\n    }\n\n    extremes[seriesName] = seriesExtremes;\n    points[seriesIdx] = seriesPoints;\n  }\n\n  return { points: points, extremes: extremes, boundaryIds: boundaryIds };\n};\n\n/**\n * Update the graph with new data. This method is called when the viewing area\n * has changed. If the underlying data or options have changed, predraw_ will\n * be called before drawGraph_ is called.\n *\n * @private\n */\nDygraph.prototype.drawGraph_ = function() {\n  var start = new Date();\n\n  // This is used to set the second parameter to drawCallback, below.\n  var is_initial_draw = this.is_initial_draw_;\n  this.is_initial_draw_ = false;\n\n  this.layout_.removeAllDatasets();\n  this.setColors_();\n  this.attrs_.pointSize = 0.5 * this.getNumericOption(\'highlightCircleSize\');\n\n  var packed = this.gatherDatasets_(this.rolledSeries_, this.dateWindow_);\n  var points = packed.points;\n  var extremes = packed.extremes;\n  this.boundaryIds_ = packed.boundaryIds;\n\n  this.setIndexByName_ = {};\n  var labels = this.attr_("labels");\n  var dataIdx = 0;\n  for (var i = 1; i < points.length; i++) {\n    if (!this.visibility()[i - 1]) continue;\n    this.layout_.addDataset(labels[i], points[i]);\n    this.datasetIndex_[i] = dataIdx++;\n  }\n  for (var i = 0; i < labels.length; i++) {\n    this.setIndexByName_[labels[i]] = i;\n  }\n\n  this.computeYAxisRanges_(extremes);\n  this.layout_.setYAxes(this.axes_);\n\n  this.addXTicks_();\n\n  // Tell PlotKit to use this new data and render itself\n  this.layout_.evaluate();\n  this.renderGraph_(is_initial_draw);\n\n  if (this.getStringOption("timingName")) {\n    var end = new Date();\n    console.log(this.getStringOption("timingName") + " - drawGraph: " + (end - start) + "ms");\n  }\n};\n\n/**\n * This does the work of drawing the chart. It assumes that the layout and axis\n * scales have already been set (e.g. by predraw_).\n *\n * @private\n */\nDygraph.prototype.renderGraph_ = function(is_initial_draw) {\n  this.cascadeEvents_(\'clearChart\');\n  this.plotter_.clear();\n\n  const underlayCallback = this.getFunctionOption(\'underlayCallback\');\n  if (underlayCallback) {\n    // NOTE: we pass the dygraph object to this callback twice to avoid breaking\n    // users who expect a deprecated form of this callback.\n    underlayCallback.call(this,\n        this.hidden_ctx_, this.layout_.getPlotArea(), this, this);\n  }\n\n  var e = {\n    canvas: this.hidden_,\n    drawingContext: this.hidden_ctx_\n  };\n  this.cascadeEvents_(\'willDrawChart\', e);\n  this.plotter_.render();\n  this.cascadeEvents_(\'didDrawChart\', e);\n  this.lastRow_ = -1;  // because plugins/legend.js clears the legend\n\n  // TODO(danvk): is this a performance bottleneck when panning?\n  // The interaction canvas should already be empty in that situation.\n  this.canvas_.getContext(\'2d\').clearRect(0, 0, this.width_, this.height_);\n\n  const drawCallback = this.getFunctionOption("drawCallback");\n  if (drawCallback !== null) {\n    drawCallback.call(this, this, is_initial_draw);\n  }\n  if (is_initial_draw) {\n    this.readyFired_ = true;\n    while (this.readyFns_.length > 0) {\n      var fn = this.readyFns_.pop();\n      fn(this);\n    }\n  }\n};\n\n/**\n * @private\n * Determine properties of the y-axes which are independent of the data\n * currently being displayed. This includes things like the number of axes and\n * the style of the axes. It does not include the range of each axis and its\n * tick marks.\n * This fills in this.axes_.\n * axes_ = [ { options } ]\n *   indices are into the axes_ array.\n */\nDygraph.prototype.computeYAxes_ = function() {\n  var axis, index, opts, v;\n\n  // this.axes_ doesn\'t match this.attributes_.axes_.options. It\'s used for\n  // data computation as well as options storage.\n  // Go through once and add all the axes.\n  this.axes_ = [];\n\n  for (axis = 0; axis < this.attributes_.numAxes(); axis++) {\n    // Add a new axis, making a copy of its per-axis options.\n    opts = { g : this };\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* update */ "R"](opts, this.attributes_.axisOptions(axis));\n    this.axes_[axis] = opts;\n  }\n\n  for (axis = 0; axis < this.axes_.length; axis++) {\n    if (axis === 0) {\n      opts = this.optionsViewForAxis_(\'y\' + (axis ? \'2\' : \'\'));\n      v = opts("valueRange");\n      if (v) this.axes_[axis].valueRange = v;\n    } else {  // To keep old behavior\n      var axes = this.user_attrs_.axes;\n      if (axes && axes.y2) {\n        v = axes.y2.valueRange;\n        if (v) this.axes_[axis].valueRange = v;\n      }\n    }\n  }\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraph.prototype.numAxes = function() {\n  return this.attributes_.numAxes();\n};\n\n/**\n * @private\n * Returns axis properties for the given series.\n * @param {string} setName The name of the series for which to get axis\n * properties, e.g. \'Y1\'.\n * @return {Object} The axis properties.\n */\nDygraph.prototype.axisPropertiesForSeries = function(series) {\n  // TODO(danvk): handle errors.\n  return this.axes_[this.attributes_.axisForSeries(series)];\n};\n\n/**\n * @private\n * Determine the value range and tick marks for each axis.\n * @param {Object} extremes A mapping from seriesName -> [low, high]\n * This fills in the valueRange and ticks fields in each entry of this.axes_.\n */\nDygraph.prototype.computeYAxisRanges_ = function(extremes) {\n  var isNullUndefinedOrNaN = function(num) {\n    return isNaN(parseFloat(num));\n  };\n  var numAxes = this.attributes_.numAxes();\n  var ypadCompat, span, series, ypad;\n\n  var p_axis;\n\n  // Compute extreme values, a span and tick marks for each axis.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n    var logscale = this.attributes_.getForAxis("logscale", i);\n    var includeZero = this.attributes_.getForAxis("includeZero", i);\n    var independentTicks = this.attributes_.getForAxis("independentTicks", i);\n    series = this.attributes_.seriesForAxis(i);\n\n    // Add some padding. This supports two Y padding operation modes:\n    //\n    // - backwards compatible (yRangePad not set):\n    //   10% padding for automatic Y ranges, but not for user-supplied\n    //   ranges, and move a close-to-zero edge to zero, since drawing at the edge\n    //   results in invisible lines. Unfortunately lines drawn at the edge of a\n    //   user-supplied range will still be invisible. If logscale is\n    //   set, add a variable amount of padding at the top but\n    //   none at the bottom.\n    //\n    // - new-style (yRangePad set by the user):\n    //   always add the specified Y padding.\n    //\n    ypadCompat = true;\n    ypad = 0.1; // add 10%\n    const yRangePad = this.getNumericOption(\'yRangePad\');\n    if (yRangePad !== null) {\n      ypadCompat = false;\n      // Convert pixel padding to ratio\n      ypad = yRangePad / this.plotter_.area.h;\n    }\n\n    if (series.length === 0) {\n      // If no series are defined or visible then use a reasonable default\n      axis.extremeRange = [0, 1];\n    } else {\n      // Calculate the extremes of extremes.\n      var minY = Infinity;  // extremes[series[0]][0];\n      var maxY = -Infinity;  // extremes[series[0]][1];\n      var extremeMinY, extremeMaxY;\n\n      for (var j = 0; j < series.length; j++) {\n        // this skips invisible series\n        if (!extremes.hasOwnProperty(series[j])) continue;\n\n        // Only use valid extremes to stop null data series\' from corrupting the scale.\n        extremeMinY = extremes[series[j]][0];\n        if (extremeMinY !== null) {\n          minY = Math.min(extremeMinY, minY);\n        }\n        extremeMaxY = extremes[series[j]][1];\n        if (extremeMaxY !== null) {\n          maxY = Math.max(extremeMaxY, maxY);\n        }\n      }\n\n      // Include zero if requested by the user.\n      if (includeZero && !logscale) {\n        if (minY > 0) minY = 0;\n        if (maxY < 0) maxY = 0;\n      }\n\n      // Ensure we have a valid scale, otherwise default to [0, 1] for safety.\n      if (minY == Infinity) minY = 0;\n      if (maxY == -Infinity) maxY = 1;\n\n      span = maxY - minY;\n      // special case: if we have no sense of scale, center on the sole value.\n      if (span === 0) {\n        if (maxY !== 0) {\n          span = Math.abs(maxY);\n        } else {\n          // ... and if the sole value is zero, use range 0-1.\n          maxY = 1;\n          span = 1;\n        }\n      }\n\n      var maxAxisY = maxY, minAxisY = minY;\n      if (ypadCompat) {\n        if (logscale) {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY;\n        } else {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY - ypad * span;\n\n          // Backwards-compatible behavior: Move the span to start or end at zero if it\'s\n          // close to zero.\n          if (minAxisY < 0 && minY >= 0) minAxisY = 0;\n          if (maxAxisY > 0 && maxY <= 0) maxAxisY = 0;\n        }\n      }\n      axis.extremeRange = [minAxisY, maxAxisY];\n    }\n    if (axis.valueRange) {\n      // This is a user-set value range for this axis.\n      var y0 = isNullUndefinedOrNaN(axis.valueRange[0]) ? axis.extremeRange[0] : axis.valueRange[0];\n      var y1 = isNullUndefinedOrNaN(axis.valueRange[1]) ? axis.extremeRange[1] : axis.valueRange[1];\n      axis.computedValueRange = [y0, y1];\n    } else {\n      axis.computedValueRange = axis.extremeRange;\n    }\n    if (!ypadCompat) {\n      // When using yRangePad, adjust the upper/lower bounds to add\n      // padding unless the user has zoomed/panned the Y axis range.\n      if (logscale) {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        var y0pct = ypad / (2 * ypad - 1);\n        var y1pct = (ypad - 1) / (2 * ypad - 1);\n        axis.computedValueRange[0] = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* logRangeFraction */ "I"](y0, y1, y0pct);\n        axis.computedValueRange[1] = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* logRangeFraction */ "I"](y0, y1, y1pct);\n      } else {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        span = y1 - y0;\n        axis.computedValueRange[0] = y0 - span * ypad;\n        axis.computedValueRange[1] = y1 + span * ypad;\n      }\n    }\n\n\n    if (independentTicks) {\n      axis.independentTicks = independentTicks;\n      var opts = this.optionsViewForAxis_(\'y\' + (i ? \'2\' : \'\'));\n      var ticker = opts(\'ticker\');\n      axis.ticks = ticker(axis.computedValueRange[0],\n              axis.computedValueRange[1],\n              this.plotter_.area.h,\n              opts,\n              this);\n      // Define the first independent axis as primary axis.\n      if (!p_axis) p_axis = axis;\n    }\n  }\n  if (p_axis === undefined) {\n    throw ("Configuration Error: At least one axis has to have the \\"independentTicks\\" option activated.");\n  }\n  // Add ticks. By default, all axes inherit the tick positions of the\n  // primary axis. However, if an axis is specifically marked as having\n  // independent ticks, then that is permissible as well.\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n\n    if (!axis.independentTicks) {\n      var opts = this.optionsViewForAxis_(\'y\' + (i ? \'2\' : \'\'));\n      var ticker = opts(\'ticker\');\n      var p_ticks = p_axis.ticks;\n      var p_scale = p_axis.computedValueRange[1] - p_axis.computedValueRange[0];\n      var scale = axis.computedValueRange[1] - axis.computedValueRange[0];\n      var tick_values = [];\n      for (var k = 0; k < p_ticks.length; k++) {\n        var y_frac = (p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;\n        var y_val = axis.computedValueRange[0] + y_frac * scale;\n        tick_values.push(y_val);\n      }\n\n      axis.ticks = ticker(axis.computedValueRange[0],\n                          axis.computedValueRange[1],\n                          this.plotter_.area.h,\n                          opts,\n                          this,\n                          tick_values);\n    }\n  }\n};\n\n/**\n * Detects the type of the str (date or numeric) and sets the various\n * formatting attributes in this.attrs_ based on this type.\n * @param {string} str An x value.\n * @private\n */\nDygraph.prototype.detectTypeFromString_ = function(str) {\n  var isDate = false;\n  var dashPos = str.indexOf(\'-\');  // could be 2006-01-01 _or_ 1.0e-2\n  if ((dashPos > 0 && (str[dashPos-1] != \'e\' && str[dashPos-1] != \'E\')) ||\n      str.indexOf(\'/\') >= 0 ||\n      isNaN(parseFloat(str))) {\n    isDate = true;\n  } else if (str.length == 8 && str > \'19700101\' && str < \'20371231\') {\n    // TODO(danvk): remove support for this format.\n    isDate = true;\n  }\n\n  this.setXAxisOptions_(isDate);\n};\n\nDygraph.prototype.setXAxisOptions_ = function(isDate) {\n  if (isDate) {\n    this.attrs_.xValueParser = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateParser */ "p"];\n    this.attrs_.axes.x.valueFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateValueFormatter */ "r"];\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* dateTicker */ "b"];\n    this.attrs_.axes.x.axisLabelFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateAxisLabelFormatter */ "o"];\n  } else {\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.xValueParser = function(x) { return parseFloat(x); };\n    // TODO(danvk): use Dygraph.numberValueFormatter here?\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function(x) { return x; };\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* numericTicks */ "e"];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  }\n};\n\n/**\n * @private\n * Parses a string in a special csv format.  We expect a csv file where each\n * line is a date point, and the first field in each line is the date string.\n * We also expect that all remaining fields represent series.\n * if the errorBars attribute is set, then interpret the fields as:\n * date, series1, stddev1, series2, stddev2, ...\n * @param {[Object]} data See above.\n *\n * @return [Object] An array with one entry for each row. These entries\n * are an array of cells in that row. The first entry is the parsed x-value for\n * the row. The second, third, etc. are the y-values. These can take on one of\n * three forms, depending on the CSV and constructor parameters:\n * 1. numeric value\n * 2. [ value, stddev ]\n * 3. [ low value, center value, high value ]\n */\nDygraph.prototype.parseCSV_ = function(data) {\n  var ret = [];\n  var line_delimiter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* detectLineDelimiter */ "s"](data);\n  var lines = data.split(line_delimiter || "\\n");\n  var vals, j;\n\n  // Use the default delimiter or fall back to a tab if that makes sense.\n  var delim = this.getStringOption(\'delimiter\');\n  if (lines[0].indexOf(delim) == -1 && lines[0].indexOf(\'\\t\') >= 0) {\n    delim = \'\\t\';\n  }\n\n  var start = 0;\n  if (!(\'labels\' in this.user_attrs_)) {\n    // User hasn\'t explicitly set labels, so they\'re (presumably) in the CSV.\n    start = 1;\n    this.attrs_.labels = lines[0].split(delim);  // NOTE: _not_ user_attrs_.\n    this.attributes_.reparseSeries();\n  }\n  var line_no = 0;\n\n  var xParser;\n  var defaultParserSet = false;  // attempt to auto-detect x value type\n  var expectedCols = this.attr_("labels").length;\n  var outOfOrder = false;\n  for (var i = start; i < lines.length; i++) {\n    var line = lines[i];\n    line_no = i;\n    if (line.length === 0) continue;  // skip blank lines\n    if (line[0] == \'#\') continue;    // skip comment lines\n    var inFields = line.split(delim);\n    if (inFields.length < 2) continue;\n\n    var fields = [];\n    if (!defaultParserSet) {\n      this.detectTypeFromString_(inFields[0]);\n      xParser = this.getFunctionOption("xValueParser");\n      defaultParserSet = true;\n    }\n    fields[0] = xParser(inFields[0], this);\n\n    // If fractions are expected, parse the numbers as "A/B"\n    if (this.fractions_) {\n      for (j = 1; j < inFields.length; j++) {\n        // TODO(danvk): figure out an appropriate way to flag parse errors.\n        vals = inFields[j].split("/");\n        if (vals.length != 2) {\n          console.error(\'Expected fractional "num/den" values in CSV data \' +\n                        "but found a value \'" + inFields[j] + "\' on line " +\n                        (1 + i) + " (\'" + line + "\') which is not of this form.");\n          fields[j] = [0, 0];\n        } else {\n          fields[j] = [_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](vals[0], i, line),\n                       _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](vals[1], i, line)];\n        }\n      }\n    } else if (this.getBooleanOption("errorBars")) {\n      // If there are error bars, values are (value, stddev) pairs\n      if (inFields.length % 2 != 1) {\n        console.error(\'Expected alternating (value, stdev.) pairs in CSV data \' +\n                      \'but line \' + (1 + i) + \' has an odd number of values (\' +\n                      (inFields.length - 1) + "): \'" + line + "\'");\n      }\n      for (j = 1; j < inFields.length; j += 2) {\n        fields[(j + 1) / 2] = [_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](inFields[j], i, line),\n                               _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](inFields[j + 1], i, line)];\n      }\n    } else if (this.getBooleanOption("customBars")) {\n      // Bars are a low;center;high tuple\n      for (j = 1; j < inFields.length; j++) {\n        var val = inFields[j];\n        if (/^ *$/.test(val)) {\n          fields[j] = [null, null, null];\n        } else {\n          vals = val.split(";");\n          if (vals.length == 3) {\n            fields[j] = [ _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](vals[0], i, line),\n                          _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](vals[1], i, line),\n                          _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](vals[2], i, line) ];\n          } else {\n            console.warn(\'When using customBars, values must be either blank \' +\n                         \'or "low;center;high" tuples (got "\' + val +\n                         \'" on line \' + (1+i));\n          }\n        }\n      }\n    } else {\n      // Values are just numbers\n      for (j = 1; j < inFields.length; j++) {\n        fields[j] = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* parseFloat_ */ "N"](inFields[j], i, line);\n      }\n    }\n    if (ret.length > 0 && fields[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n\n    if (fields.length != expectedCols) {\n      console.error("Number of columns in line " + i + " (" + fields.length +\n                    ") does not agree with number of labels (" + expectedCols +\n                    ") " + line);\n    }\n\n    // If the user specified the \'labels\' option and none of the cells of the\n    // first row parsed correctly, then they probably double-specified the\n    // labels. We go with the values set in the option, discard this row and\n    // log a warning to the JS console.\n    if (i === 0 && this.attr_(\'labels\')) {\n      var all_null = true;\n      for (j = 0; all_null && j < fields.length; j++) {\n        if (fields[j]) all_null = false;\n      }\n      if (all_null) {\n        console.warn("The dygraphs \'labels\' option is set, but the first row " +\n                     "of CSV data (\'" + line + "\') appears to also contain " +\n                     "labels. Will drop the CSV labels and use the option " +\n                     "labels.");\n        continue;\n      }\n    }\n    ret.push(fields);\n  }\n\n  if (outOfOrder) {\n    console.warn("CSV is out of order; order it correctly to speed loading.");\n    ret.sort(function(a,b) { return a[0] - b[0]; });\n  }\n\n  return ret;\n};\n\n// In native format, all values must be dates or numbers.\n// This check isn\'t perfect but will catch most mistaken uses of strings.\nfunction validateNativeFormat(data) {\n  const firstRow = data[0];\n  const firstX = firstRow[0];\n  if (typeof firstX !== \'number\' && !_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isDateLike */ "C"](firstX)) {\n    throw new Error(`Expected number or date but got ${typeof firstX}: ${firstX}.`);\n  }\n  for (let i = 1; i < firstRow.length; i++) {\n    const val = firstRow[i];\n    if (val === null || val === undefined) continue;\n    if (typeof val === \'number\') continue;\n    if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isArrayLike */ "A"](val)) continue;  // e.g. error bars or custom bars.\n    throw new Error(`Expected number or array but got ${typeof val}: ${val}.`);\n  }\n}\n\n/**\n * The user has provided their data as a pre-packaged JS array. If the x values\n * are numeric, this is the same as dygraphs\' internal format. If the x values\n * are dates, we need to convert them from Date objects to ms since epoch.\n * @param {!Array} data\n * @return {Object} data with numeric x values.\n * @private\n */\nDygraph.prototype.parseArray_ = function(data) {\n  // Peek at the first x value to see if it\'s numeric.\n  if (data.length === 0) {\n    console.error("Can\'t plot empty data set");\n    return null;\n  }\n  if (data[0].length === 0) {\n    console.error("Data set cannot contain an empty row");\n    return null;\n  }\n\n  validateNativeFormat(data);\n\n  var i;\n  if (this.attr_("labels") === null) {\n    console.warn("Using default labels. Set labels explicitly via \'labels\' " +\n                 "in the options parameter");\n    this.attrs_.labels = [ "X" ];\n    for (i = 1; i < data[0].length; i++) {\n      this.attrs_.labels.push("Y" + i); // Not user_attrs_.\n    }\n    this.attributes_.reparseSeries();\n  } else {\n    var num_labels = this.attr_("labels");\n    if (num_labels.length != data[0].length) {\n      console.error("Mismatch between number of labels (" + num_labels + ")" +\n                    " and number of columns in array (" + data[0].length + ")");\n      return null;\n    }\n  }\n\n  if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isDateLike */ "C"](data[0][0])) {\n    // Some intelligent defaults for a date x-axis.\n    this.attrs_.axes.x.valueFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateValueFormatter */ "r"];\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* dateTicker */ "b"];\n    this.attrs_.axes.x.axisLabelFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateAxisLabelFormatter */ "o"];\n\n    // Assume they\'re all dates.\n    var parsedData = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* clone */ "l"](data);\n    for (i = 0; i < data.length; i++) {\n      if (parsedData[i].length === 0) {\n        console.error("Row " + (1 + i) + " of data is empty");\n        return null;\n      }\n      if (parsedData[i][0] === null ||\n          typeof(parsedData[i][0].getTime) != \'function\' ||\n          isNaN(parsedData[i][0].getTime())) {\n        console.error("x value in row " + (1 + i) + " is not a Date");\n        return null;\n      }\n      parsedData[i][0] = parsedData[i][0].getTime();\n    }\n    return parsedData;\n  } else {\n    // Some intelligent defaults for a numeric x-axis.\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function(x) { return x; };\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* numericTicks */ "e"];\n    this.attrs_.axes.x.axisLabelFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* numberAxisLabelFormatter */ "J"];\n    return data;\n  }\n};\n\n/**\n * Parses a DataTable object from gviz.\n * The data is expected to have a first column that is either a date or a\n * number. All subsequent columns must be numbers. If there is a clear mismatch\n * between this.xValueParser_ and the type of the first column, it will be\n * fixed. Fills out rawData_.\n * @param {!google.visualization.DataTable} data See above.\n * @private\n */\nDygraph.prototype.parseDataTable_ = function(data) {\n  var shortTextForAnnotationNum = function(num) {\n    // converts [0-9]+ [A-Z][a-z]*\n    // example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab\n    // and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz\n    var shortText = String.fromCharCode(65 /* A */ + num % 26);\n    num = Math.floor(num / 26);\n    while ( num > 0 ) {\n      shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26 ) + shortText.toLowerCase();\n      num = Math.floor((num - 1) / 26);\n    }\n    return shortText;\n  };\n\n  var cols = data.getNumberOfColumns();\n  var rows = data.getNumberOfRows();\n\n  var indepType = data.getColumnType(0);\n  if (indepType == \'date\' || indepType == \'datetime\') {\n    this.attrs_.xValueParser = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateParser */ "p"];\n    this.attrs_.axes.x.valueFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateValueFormatter */ "r"];\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* dateTicker */ "b"];\n    this.attrs_.axes.x.axisLabelFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateAxisLabelFormatter */ "o"];\n  } else if (indepType == \'number\') {\n    this.attrs_.xValueParser = function(x) { return parseFloat(x); };\n    this.attrs_.axes.x.valueFormatter = function(x) { return x; };\n    this.attrs_.axes.x.ticker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* numericTicks */ "e"];\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  } else {\n    throw new Error(\n          "only \'date\', \'datetime\' and \'number\' types are supported " +\n          "for column 1 of DataTable input (Got \'" + indepType + "\')");\n  }\n\n  // Array of the column indices which contain data (and not annotations).\n  var colIdx = [];\n  var annotationCols = {};  // data index -> [annotation cols]\n  var hasAnnotations = false;\n  var i, j;\n  for (i = 1; i < cols; i++) {\n    var type = data.getColumnType(i);\n    if (type == \'number\') {\n      colIdx.push(i);\n    } else if (type == \'string\' && this.getBooleanOption(\'displayAnnotations\')) {\n      // This is OK -- it\'s an annotation column.\n      var dataIdx = colIdx[colIdx.length - 1];\n      if (!annotationCols.hasOwnProperty(dataIdx)) {\n        annotationCols[dataIdx] = [i];\n      } else {\n        annotationCols[dataIdx].push(i);\n      }\n      hasAnnotations = true;\n    } else {\n      throw new Error(\n          "Only \'number\' is supported as a dependent type with Gviz." +\n          " \'string\' is only supported if displayAnnotations is true");\n    }\n  }\n\n  // Read column labels\n  // TODO(danvk): add support back for errorBars\n  var labels = [data.getColumnLabel(0)];\n  for (i = 0; i < colIdx.length; i++) {\n    labels.push(data.getColumnLabel(colIdx[i]));\n    if (this.getBooleanOption("errorBars")) i += 1;\n  }\n  this.attrs_.labels = labels;\n  cols = labels.length;\n\n  var ret = [];\n  var outOfOrder = false;\n  var annotations = [];\n  for (i = 0; i < rows; i++) {\n    var row = [];\n    if (typeof(data.getValue(i, 0)) === \'undefined\' ||\n        data.getValue(i, 0) === null) {\n      console.warn("Ignoring row " + i +\n                   " of DataTable because of undefined or null first column.");\n      continue;\n    }\n\n    if (indepType == \'date\' || indepType == \'datetime\') {\n      row.push(data.getValue(i, 0).getTime());\n    } else {\n      row.push(data.getValue(i, 0));\n    }\n    if (!this.getBooleanOption("errorBars")) {\n      for (j = 0; j < colIdx.length; j++) {\n        var col = colIdx[j];\n        row.push(data.getValue(i, col));\n        if (hasAnnotations &&\n            annotationCols.hasOwnProperty(col) &&\n            data.getValue(i, annotationCols[col][0]) !== null) {\n          var ann = {};\n          ann.series = data.getColumnLabel(col);\n          ann.xval = row[0];\n          ann.shortText = shortTextForAnnotationNum(annotations.length);\n          ann.text = \'\';\n          for (var k = 0; k < annotationCols[col].length; k++) {\n            if (k) ann.text += "\\n";\n            ann.text += data.getValue(i, annotationCols[col][k]);\n          }\n          annotations.push(ann);\n        }\n      }\n\n      // Strip out infinities, which give dygraphs problems later on.\n      for (j = 0; j < row.length; j++) {\n        if (!isFinite(row[j])) row[j] = null;\n      }\n    } else {\n      for (j = 0; j < cols - 1; j++) {\n        row.push([ data.getValue(i, 1 + 2 * j), data.getValue(i, 2 + 2 * j) ]);\n      }\n    }\n    if (ret.length > 0 && row[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n    ret.push(row);\n  }\n\n  if (outOfOrder) {\n    console.warn("DataTable is out of order; order it correctly to speed loading.");\n    ret.sort(function(a,b) { return a[0] - b[0]; });\n  }\n  this.rawData_ = ret;\n\n  if (annotations.length > 0) {\n    this.setAnnotations(annotations, true);\n  }\n  this.attributes_.reparseSeries();\n};\n\n/**\n * Signals to plugins that the chart data has updated.\n * This happens after the data has updated but before the chart has redrawn.\n * @private\n */\nDygraph.prototype.cascadeDataDidUpdateEvent_ = function() {\n  // TODO(danvk): there are some issues checking xAxisRange() and using\n  // toDomCoords from handlers of this event. The visible range should be set\n  // when the chart is drawn, not derived from the data.\n  this.cascadeEvents_(\'dataDidUpdate\', {});\n};\n\n/**\n * Get the CSV data. If it\'s in a function, call that function. If it\'s in a\n * file, do an XMLHttpRequest to get it.\n * @private\n */\nDygraph.prototype.start_ = function() {\n  var data = this.file_;\n\n  // Functions can return references of all other types.\n  if (typeof data == \'function\') {\n    data = data();\n  }\n\n  if (_dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isArrayLike */ "A"](data)) {\n    this.rawData_ = this.parseArray_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == \'object\' &&\n             typeof data.getColumnRange == \'function\') {\n    // must be a DataTable from gviz.\n    this.parseDataTable_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == \'string\') {\n    // Heuristic: a newline means it\'s CSV data. Otherwise it\'s an URL.\n    var line_delimiter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* detectLineDelimiter */ "s"](data);\n    if (line_delimiter) {\n      this.loadedEvent_(data);\n    } else {\n      // REMOVE_FOR_IE\n      var req;\n      if (window.XMLHttpRequest) {\n        // Firefox, Opera, IE7, and other browsers will use the native object\n        req = new XMLHttpRequest();\n      } else {\n        // IE 5 and 6 will use the ActiveX control\n        req = new ActiveXObject("Microsoft.XMLHTTP");\n      }\n\n      var caller = this;\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status === 200 ||  // Normal http\n              req.status === 0) {    // Chrome w/ --allow-file-access-from-files\n            caller.loadedEvent_(req.responseText);\n          }\n        }\n      };\n\n      req.open("GET", data, true);\n      req.send(null);\n    }\n  } else {\n    console.error("Unknown data format: " + (typeof data));\n  }\n};\n\n/**\n * Changes various properties of the graph. These can include:\n * <ul>\n * <li>file: changes the source data for the graph</li>\n * <li>errorBars: changes whether the data contains stddev</li>\n * </ul>\n *\n * There\'s a huge variety of options that can be passed to this method. For a\n * full list, see http://dygraphs.com/options.html.\n *\n * @param {Object} input_attrs The new properties and values\n * @param {boolean} block_redraw Usually the chart is redrawn after every\n *     call to updateOptions(). If you know better, you can pass true to\n *     explicitly block the redraw. This can be useful for chaining\n *     updateOptions() calls, avoiding the occasional infinite loop and\n *     preventing redraws when it\'s not necessary (e.g. when updating a\n *     callback).\n */\nDygraph.prototype.updateOptions = function(input_attrs, block_redraw) {\n  if (typeof(block_redraw) == \'undefined\') block_redraw = false;\n\n  // copyUserAttrs_ drops the "file" parameter as a convenience to us.\n  var file = input_attrs.file;\n  var attrs = Dygraph.copyUserAttrs_(input_attrs);\n\n  // TODO(danvk): this is a mess. Move these options into attr_.\n  if (\'rollPeriod\' in attrs) {\n    this.rollPeriod_ = attrs.rollPeriod;\n  }\n  if (\'dateWindow\' in attrs) {\n    this.dateWindow_ = attrs.dateWindow;\n  }\n\n  // TODO(danvk): validate per-series options.\n  // Supported:\n  // strokeWidth\n  // pointSize\n  // drawPoints\n  // highlightCircleSize\n\n  // Check if this set options will require new points.\n  var requiresNewPoints = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* isPixelChangingOptionList */ "F"](this.attr_("labels"), attrs);\n\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* updateDeep */ "S"](this.user_attrs_, attrs);\n\n  this.attributes_.reparseSeries();\n\n  if (file) {\n    // This event indicates that the data is about to change, but hasn\'t yet.\n    // TODO(danvk): support cancellation of the update via this event.\n    this.cascadeEvents_(\'dataWillUpdate\', {});\n\n    this.file_ = file;\n    if (!block_redraw) this.start_();\n  } else {\n    if (!block_redraw) {\n      if (requiresNewPoints) {\n        this.predraw_();\n      } else {\n        this.renderGraph_(false);\n      }\n    }\n  }\n};\n\n/**\n * Make a copy of input attributes, removing file as a convenience.\n * @private\n */\nDygraph.copyUserAttrs_ = function(attrs) {\n  var my_attrs = {};\n  for (var k in attrs) {\n    if (!attrs.hasOwnProperty(k)) continue;\n    if (k == \'file\') continue;\n    if (attrs.hasOwnProperty(k)) my_attrs[k] = attrs[k];\n  }\n  return my_attrs;\n};\n\n/**\n * Resizes the dygraph. If no parameters are specified, resizes to fill the\n * containing div (which has presumably changed size since the dygraph was\n * instantiated. If the width/height are specified, the div will be resized.\n *\n * This is far more efficient than destroying and re-instantiating a\n * Dygraph, since it doesn\'t have to reparse the underlying data.\n *\n * @param {number} width Width (in pixels)\n * @param {number} height Height (in pixels)\n */\nDygraph.prototype.resize = function(width, height) {\n  if (this.resize_lock) {\n    return;\n  }\n  this.resize_lock = true;\n\n  if ((width === null) != (height === null)) {\n    console.warn("Dygraph.resize() should be called with zero parameters or " +\n                 "two non-NULL parameters. Pretending it was zero.");\n    width = height = null;\n  }\n\n  var old_width = this.width_;\n  var old_height = this.height_;\n\n  if (width) {\n    this.maindiv_.style.width = width + "px";\n    this.maindiv_.style.height = height + "px";\n    this.width_ = width;\n    this.height_ = height;\n  } else {\n    this.width_ = this.maindiv_.clientWidth;\n    this.height_ = this.maindiv_.clientHeight;\n  }\n\n  if (old_width != this.width_ || old_height != this.height_) {\n    // Resizing a canvas erases it, even when the size doesn\'t change, so\n    // any resize needs to be followed by a redraw.\n    this.resizeElements_();\n    this.predraw_();\n  }\n\n  this.resize_lock = false;\n};\n\n/**\n * Adjusts the number of points in the rolling average. Updates the graph to\n * reflect the new averaging period.\n * @param {number} length Number of points over which to average the data.\n */\nDygraph.prototype.adjustRoll = function(length) {\n  this.rollPeriod_ = length;\n  this.predraw_();\n};\n\n/**\n * Returns a boolean array of visibility statuses.\n */\nDygraph.prototype.visibility = function() {\n  // Do lazy-initialization, so that this happens after we know the number of\n  // data series.\n  if (!this.getOption("visibility")) {\n    this.attrs_.visibility = [];\n  }\n  // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.\n  while (this.getOption("visibility").length < this.numColumns() - 1) {\n    this.attrs_.visibility.push(true);\n  }\n  return this.getOption("visibility");\n};\n\n/**\n * Changes the visibility of one or more series.\n *\n * @param {number|number[]|object} num the series index or an array of series indices\n *                                     or a boolean array of visibility states by index\n *                                     or an object mapping series numbers, as keys, to\n *                                     visibility state (boolean values)\n * @param {boolean} value the visibility state expressed as a boolean\n */\nDygraph.prototype.setVisibility = function(num, value) {\n  var x = this.visibility();\n  var numIsObject = false;\n\n  if (!Array.isArray(num)) {\n    if (num !== null && typeof num === \'object\') {\n      numIsObject = true;\n    } else {\n      num = [num];\n    }\n  }\n\n  if (numIsObject) {\n    for (var i in num) {\n      if (num.hasOwnProperty(i)) {\n        if (i < 0 || i >= x.length) {\n          console.warn("Invalid series number in setVisibility: " + i);\n        } else {\n          x[i] = num[i];\n        }\n      }\n    }\n  } else {\n    for (var i = 0; i < num.length; i++) {\n      if (typeof num[i] === \'boolean\') {\n        if (i >= x.length) {\n          console.warn("Invalid series number in setVisibility: " + i);\n        } else {\n          x[i] = num[i];\n        }\n      } else {\n        if (num[i] < 0 || num[i] >= x.length) {\n          console.warn("Invalid series number in setVisibility: " + num[i]);\n        } else {\n          x[num[i]] = value;\n        }\n      }\n    }\n  }\n\n  this.predraw_();\n};\n\n/**\n * How large of an area will the dygraph render itself in?\n * This is used for testing.\n * @return A {width: w, height: h} object.\n * @private\n */\nDygraph.prototype.size = function() {\n  return { width: this.width_, height: this.height_ };\n};\n\n/**\n * Update the list of annotations and redraw the chart.\n * See dygraphs.com/annotations.html for more info on how to use annotations.\n * @param ann {Array} An array of annotation objects.\n * @param suppressDraw {Boolean} Set to "true" to block chart redraw (optional).\n */\nDygraph.prototype.setAnnotations = function(ann, suppressDraw) {\n  // Only add the annotation CSS rule once we know it will be used.\n  this.annotations_ = ann;\n  if (!this.layout_) {\n    console.warn("Tried to setAnnotations before dygraph was ready. " +\n                 "Try setting them in a ready() block. See " +\n                 "dygraphs.com/tests/annotation.html");\n    return;\n  }\n\n  this.layout_.setAnnotations(this.annotations_);\n  if (!suppressDraw) {\n    this.predraw_();\n  }\n};\n\n/**\n * Return the list of annotations.\n */\nDygraph.prototype.annotations = function() {\n  return this.annotations_;\n};\n\n/**\n * Get the list of label names for this graph. The first column is the\n * x-axis, so the data series names start at index 1.\n *\n * Returns null when labels have not yet been defined.\n */\nDygraph.prototype.getLabels = function() {\n  var labels = this.attr_("labels");\n  return labels ? labels.slice() : null;\n};\n\n/**\n * Get the index of a series (column) given its name. The first column is the\n * x-axis, so the data series start with index 1.\n */\nDygraph.prototype.indexFromSetName = function(name) {\n  return this.setIndexByName_[name];\n};\n\n/**\n * Find the row number corresponding to the given x-value.\n * Returns null if there is no such x-value in the data.\n * If there are multiple rows with the same x-value, this will return the\n * first one.\n * @param {number} xVal The x-value to look for (e.g. millis since epoch).\n * @return {?number} The row number, which you can pass to getValue(), or null.\n */\nDygraph.prototype.getRowForX = function(xVal) {\n  var low = 0,\n      high = this.numRows() - 1;\n\n  while (low <= high) {\n    var idx = (high + low) >> 1;\n    var x = this.getValue(idx, 0);\n    if (x < xVal) {\n      low = idx + 1;\n    } else if (x > xVal) {\n      high = idx - 1;\n    } else if (low != idx) {  // equal, but there may be an earlier match.\n      high = idx;\n    } else {\n      return idx;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Trigger a callback when the dygraph has drawn itself and is ready to be\n * manipulated. This is primarily useful when dygraphs has to do an XHR for the\n * data (i.e. a URL is passed as the data source) and the chart is drawn\n * asynchronously. If the chart has already drawn, the callback will fire\n * immediately.\n *\n * This is a good place to call setAnnotation().\n *\n * @param {function(!Dygraph)} callback The callback to trigger when the chart\n *     is ready.\n */\nDygraph.prototype.ready = function(callback) {\n  if (this.is_initial_draw_) {\n    this.readyFns_.push(callback);\n  } else {\n    callback.call(this, this);\n  }\n};\n\n/**\n * Add an event handler. This event handler is kept until the graph is\n * destroyed with a call to graph.destroy().\n *\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. \'click\' or \'mousemove\'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\nDygraph.prototype.addAndTrackEvent = function(elem, type, fn) {\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* addEvent */ "i"](elem, type, fn);\n  this.registeredEvents_.push({elem, type, fn});\n};\n\nDygraph.prototype.removeTrackedEvents_ = function() {\n  if (this.registeredEvents_) {\n    for (var idx = 0; idx < this.registeredEvents_.length; idx++) {\n      var reg = this.registeredEvents_[idx];\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* removeEvent */ "O"](reg.elem, reg.type, reg.fn);\n    }\n  }\n\n  this.registeredEvents_ = [];\n};\n\n\n// Installed plugins, in order of precedence (most-general to most-specific).\nDygraph.PLUGINS = [\n  _plugins_legend__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"],\n  _plugins_axes__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"],\n  _plugins_range_selector__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"], // Has to be before ChartLabels so that its callbacks are called after ChartLabels\' callbacks.\n  _plugins_chart_labels__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"],\n  _plugins_annotations__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"],\n  _plugins_grid__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"]\n];\n\n// There are many symbols which have historically been available through the\n// Dygraph class. These are exported here for backwards compatibility.\nDygraph.GVizChart = _dygraph_gviz__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"];\nDygraph.DASHED_LINE = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* DASHED_LINE */ "b"];\nDygraph.DOT_DASH_LINE = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* DOT_DASH_LINE */ "c"];\nDygraph.dateAxisLabelFormatter = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateAxisLabelFormatter */ "o"];\nDygraph.toRGB_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* toRGB_ */ "Q"];\nDygraph.findPos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* findPos */ "v"];\nDygraph.pageX = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* pageX */ "L"];\nDygraph.pageY = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* pageY */ "M"];\nDygraph.dateString_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* dateString_ */ "q"];\nDygraph.defaultInteractionModel = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultModel;\nDygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].nonInteractiveModel_;\nDygraph.Circles = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* Circles */ "a"];\n\nDygraph.Plugins = {\n  Legend: _plugins_legend__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"],\n  Axes: _plugins_axes__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"],\n  Annotations: _plugins_annotations__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"],\n  ChartLabels: _plugins_chart_labels__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"],\n  Grid: _plugins_grid__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"],\n  RangeSelector: _plugins_range_selector__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]\n};\n\nDygraph.DataHandlers = {\n  DefaultHandler: _datahandler_default__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"],\n  BarsHandler: _datahandler_bars__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"],\n  CustomBarsHandler: _datahandler_bars_custom__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"],\n  DefaultFractionHandler: _datahandler_default_fractions__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"],\n  ErrorBarsHandler: _datahandler_bars_error__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"],\n  FractionsBarsHandler: _datahandler_bars_fractions__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"]\n};\n\nDygraph.startPan = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].startPan;\nDygraph.startZoom = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].startZoom;\nDygraph.movePan = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].movePan;\nDygraph.moveZoom = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].moveZoom;\nDygraph.endPan = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].endPan;\nDygraph.endZoom = _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].endZoom;\n\nDygraph.numericLinearTicks = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* numericLinearTicks */ "d"];\nDygraph.numericTicks = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* numericTicks */ "e"];\nDygraph.dateTicker = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* dateTicker */ "b"];\nDygraph.Granularity = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* Granularity */ "a"];\nDygraph.getDateAxis = _dygraph_tickers__WEBPACK_IMPORTED_MODULE_4__[/* getDateAxis */ "c"];\nDygraph.floatFormat = _dygraph_utils__WEBPACK_IMPORTED_MODULE_5__[/* floatFormat */ "w"];\n\n/* harmony default export */ __webpack_exports__["a"] = (Dygraph);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC5qcz8wYTc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDA2IERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENyZWF0ZXMgYW4gaW50ZXJhY3RpdmUsIHpvb21hYmxlIGdyYXBoIGJhc2VkIG9uIGEgQ1NWIGZpbGUgb3JcbiAqIHN0cmluZy4gRHlncmFwaCBjYW4gaGFuZGxlIG11bHRpcGxlIHNlcmllcyB3aXRoIG9yIHdpdGhvdXQgZXJyb3IgYmFycy4gVGhlXG4gKiBkYXRlL3ZhbHVlIHJhbmdlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0LiBEeWdyYXBoIHVzZXMgdGhlXG4gKiAmbHQ7Y2FudmFzJmd0OyB0YWcsIHNvIGl0IG9ubHkgd29ya3MgaW4gRkYxLjUrLlxuICogQGF1dGhvciBkYW52ZGtAZ21haWwuY29tIChEYW4gVmFuZGVya2FtKVxuXG4gIFVzYWdlOlxuICAgPGRpdiBpZD1cImdyYXBoZGl2XCIgc3R5bGU9XCJ3aWR0aDo4MDBweDsgaGVpZ2h0OjUwMHB4O1wiPjwvZGl2PlxuICAgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+XG4gICAgIG5ldyBEeWdyYXBoKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ3JhcGhkaXZcIiksXG4gICAgICAgICAgICAgICAgIFwiZGF0YWZpbGUuY3N2XCIsICAvLyBDU1YgZmlsZSB3aXRoIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgeyB9KTsgLy8gb3B0aW9uc1xuICAgPC9zY3JpcHQ+XG5cbiBUaGUgQ1NWIGZpbGUgaXMgb2YgdGhlIGZvcm1cblxuICAgRGF0ZSxTZXJpZXNBLFNlcmllc0IsU2VyaWVzQ1xuICAgWVlZWU1NREQsQTEsQjEsQzFcbiAgIFlZWVlNTURELEEyLEIyLEMyXG5cbiBJZiB0aGUgJ2Vycm9yQmFycycgb3B0aW9uIGlzIHNldCBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSBpbnB1dCBzaG91bGQgYmUgb2ZcbiB0aGUgZm9ybVxuICAgRGF0ZSxTZXJpZXNBLFNlcmllc0IsLi4uXG4gICBZWVlZTU1ERCxBMSxzaWdtYUExLEIxLHNpZ21hQjEsLi4uXG4gICBZWVlZTU1ERCxBMixzaWdtYUEyLEIyLHNpZ21hQjIsLi4uXG5cbiBJZiB0aGUgJ2ZyYWN0aW9ucycgb3B0aW9uIGlzIHNldCwgdGhlIGlucHV0IHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcblxuICAgRGF0ZSxTZXJpZXNBLFNlcmllc0IsLi4uXG4gICBZWVlZTU1ERCxBMS9CMSxBMi9CMiwuLi5cbiAgIFlZWVlNTURELEExL0IxLEEyL0IyLC4uLlxuXG4gQW5kIGVycm9yIGJhcnMgd2lsbCBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgYSBiaW5vbWlhbCBkaXN0cmlidXRpb24uXG5cbiBGb3IgZnVydGhlciBkb2N1bWVudGF0aW9uIGFuZCBleGFtcGxlcywgc2VlIGh0dHA6Ly9keWdyYXBocy5jb20vXG4gKi9cblxuaW1wb3J0IER5Z3JhcGhMYXlvdXQgZnJvbSAnLi9keWdyYXBoLWxheW91dCc7XG5pbXBvcnQgRHlncmFwaENhbnZhc1JlbmRlcmVyIGZyb20gJy4vZHlncmFwaC1jYW52YXMnO1xuaW1wb3J0IER5Z3JhcGhPcHRpb25zIGZyb20gJy4vZHlncmFwaC1vcHRpb25zJztcbmltcG9ydCBEeWdyYXBoSW50ZXJhY3Rpb24gZnJvbSAnLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCAqIGFzIER5Z3JhcGhUaWNrZXJzIGZyb20gJy4vZHlncmFwaC10aWNrZXJzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgREVGQVVMVF9BVFRSUyBmcm9tICcuL2R5Z3JhcGgtZGVmYXVsdC1hdHRycyc7XG5pbXBvcnQgT1BUSU9OU19SRUZFUkVOQ0UgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4vaWZyYW1lLXRhcnAnO1xuXG5pbXBvcnQgRGVmYXVsdEhhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9kZWZhdWx0JztcbmltcG9ydCBFcnJvckJhcnNIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvYmFycy1lcnJvcic7XG5pbXBvcnQgQ3VzdG9tQmFyc0hhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9iYXJzLWN1c3RvbSc7XG5pbXBvcnQgRGVmYXVsdEZyYWN0aW9uSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2RlZmF1bHQtZnJhY3Rpb25zJztcbmltcG9ydCBGcmFjdGlvbnNCYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMtZnJhY3Rpb25zJztcbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMnO1xuXG5pbXBvcnQgQW5ub3RhdGlvbnNQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2Fubm90YXRpb25zJztcbmltcG9ydCBBeGVzUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9heGVzJztcbmltcG9ydCBDaGFydExhYmVsc1BsdWdpbiBmcm9tICcuL3BsdWdpbnMvY2hhcnQtbGFiZWxzJztcbmltcG9ydCBHcmlkUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9ncmlkJztcbmltcG9ydCBMZWdlbmRQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2xlZ2VuZCc7XG5pbXBvcnQgUmFuZ2VTZWxlY3RvclBsdWdpbiBmcm9tICcuL3BsdWdpbnMvcmFuZ2Utc2VsZWN0b3InO1xuXG5pbXBvcnQgR1ZpekNoYXJ0IGZyb20gJy4vZHlncmFwaC1ndml6JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnRlcmFjdGl2ZSwgem9vbWFibGUgY2hhcnQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2RpdiB8IFN0cmluZ30gZGl2IEEgZGl2IG9yIHRoZSBpZCBvZiBhIGRpdiBpbnRvIHdoaWNoIHRvIGNvbnN0cnVjdFxuICogdGhlIGNoYXJ0LlxuICogQHBhcmFtIHtTdHJpbmcgfCBGdW5jdGlvbn0gZmlsZSBBIGZpbGUgY29udGFpbmluZyBDU1YgZGF0YSBvciBhIGZ1bmN0aW9uXG4gKiB0aGF0IHJldHVybnMgdGhpcyBkYXRhLiBUaGUgbW9zdCBiYXNpYyBleHBlY3RlZCBmb3JtYXQgZm9yIGVhY2ggbGluZSBpc1xuICogXCJZWVlZL01NL0RELHZhbDEsdmFsMiwuLi5cIi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuICogaHR0cDovL2R5Z3JhcGhzLmNvbS9kYXRhLmh0bWwuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVmFyaW91cyBvdGhlciBhdHRyaWJ1dGVzLCBlLmcuIGVycm9yQmFycyBkZXRlcm1pbmVzXG4gKiB3aGV0aGVyIHRoZSBpbnB1dCBkYXRhIGNvbnRhaW5zIGVycm9yIHJhbmdlcy4gRm9yIGEgY29tcGxldGUgbGlzdCBvZlxuICogb3B0aW9ucywgc2VlIGh0dHA6Ly9keWdyYXBocy5jb20vb3B0aW9ucy5odG1sLlxuICovXG52YXIgRHlncmFwaCA9IGZ1bmN0aW9uKGRpdiwgZGF0YSwgb3B0cykge1xuICB0aGlzLl9faW5pdF9fKGRpdiwgZGF0YSwgb3B0cyk7XG59O1xuXG5EeWdyYXBoLk5BTUUgPSBcIkR5Z3JhcGhcIjtcbkR5Z3JhcGguVkVSU0lPTiA9IFwiMi4wLjBcIjtcblxuLy8gVmFyaW91cyBkZWZhdWx0IHZhbHVlc1xuRHlncmFwaC5ERUZBVUxUX1JPTExfUEVSSU9EID0gMTtcbkR5Z3JhcGguREVGQVVMVF9XSURUSCA9IDQ4MDtcbkR5Z3JhcGguREVGQVVMVF9IRUlHSFQgPSAzMjA7XG5cbi8vIEZvciBtYXggNjAgSHouIGFuaW1hdGlvbjpcbkR5Z3JhcGguQU5JTUFUSU9OX1NURVBTID0gMTI7XG5EeWdyYXBoLkFOSU1BVElPTl9EVVJBVElPTiA9IDIwMDtcblxuLyoqXG4gKiBTdGFuZGFyZCBwbG90dGVycy4gVGhlc2UgbWF5IGJlIHVzZWQgYnkgY2xpZW50cy5cbiAqIEF2YWlsYWJsZSBwbG90dGVycyBhcmU6XG4gKiAtIER5Z3JhcGguUGxvdHRlcnMubGluZVBsb3R0ZXI6IGRyYXdzIGNlbnRyYWwgbGluZXMgKG1vc3QgY29tbW9uKVxuICogLSBEeWdyYXBoLlBsb3R0ZXJzLmVycm9yUGxvdHRlcjogZHJhd3MgZXJyb3IgYmFyc1xuICogLSBEeWdyYXBoLlBsb3R0ZXJzLmZpbGxQbG90dGVyOiBkcmF3cyBmaWxscyB1bmRlciBsaW5lcyAodXNlZCB3aXRoIGZpbGxHcmFwaClcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgcGxvdHRlciBpcyBbZmlsbFBsb3R0ZXIsIGVycm9yUGxvdHRlciwgbGluZVBsb3R0ZXJdLlxuICogVGhpcyBjYXVzZXMgYWxsIHRoZSBsaW5lcyB0byBiZSBkcmF3biBvdmVyIGFsbCB0aGUgZmlsbHMvZXJyb3IgYmFycy5cbiAqL1xuRHlncmFwaC5QbG90dGVycyA9IER5Z3JhcGhDYW52YXNSZW5kZXJlci5fUGxvdHRlcnM7XG5cblxuLy8gVXNlZCBmb3IgaW5pdGlhbGl6aW5nIGFubm90YXRpb24gQ1NTIHJ1bGVzIG9ubHkgb25jZS5cbkR5Z3JhcGguYWRkZWRBbm5vdGF0aW9uQ1NTID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIER5Z3JhcGguIFRoaXMgY3JlYXRlcyBhIG5ldyBESVYgYW5kIGNvbnN0cnVjdHMgdGhlIFBsb3RLaXRcbiAqIGFuZCBjb250ZXh0ICZsdDtjYW52YXMmZ3Q7IGluc2lkZSBvZiBpdC4gU2VlIHRoZSBjb25zdHJ1Y3RvciBmb3IgZGV0YWlscy5cbiAqIG9uIHRoZSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtFbGVtZW50fSBkaXYgdGhlIEVsZW1lbnQgdG8gcmVuZGVyIHRoZSBncmFwaCBpbnRvLlxuICogQHBhcmFtIHtzdHJpbmcgfCBGdW5jdGlvbn0gZmlsZSBTb3VyY2UgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIE1pc2NlbGxhbmVvdXMgb3RoZXIgb3B0aW9uc1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuX19pbml0X18gPSBmdW5jdGlvbihkaXYsIGZpbGUsIGF0dHJzKSB7XG4gIHRoaXMuaXNfaW5pdGlhbF9kcmF3XyA9IHRydWU7XG4gIHRoaXMucmVhZHlGbnNfID0gW107XG5cbiAgLy8gU3VwcG9ydCB0d28tYXJndW1lbnQgY29uc3RydWN0b3JcbiAgaWYgKGF0dHJzID09PSBudWxsIHx8IGF0dHJzID09PSB1bmRlZmluZWQpIHsgYXR0cnMgPSB7fTsgfVxuXG4gIGF0dHJzID0gRHlncmFwaC5jb3B5VXNlckF0dHJzXyhhdHRycyk7XG5cbiAgaWYgKHR5cGVvZihkaXYpID09ICdzdHJpbmcnKSB7XG4gICAgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2KTtcbiAgfVxuXG4gIGlmICghZGl2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RpbmcgZHlncmFwaCB3aXRoIGEgbm9uLWV4aXN0ZW50IGRpdiEnKTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIGltcG9ydGFudCBiaXRzIGludG8gdGhlIG9iamVjdFxuICAvLyBUT0RPKGRhbnZrKTogbW9zdCBvZiB0aGVzZSBzaG91bGQganVzdCBzdGF5IGluIHRoZSBhdHRyc18gZGljdGlvbmFyeS5cbiAgdGhpcy5tYWluZGl2XyA9IGRpdjtcbiAgdGhpcy5maWxlXyA9IGZpbGU7XG4gIHRoaXMucm9sbFBlcmlvZF8gPSBhdHRycy5yb2xsUGVyaW9kIHx8IER5Z3JhcGguREVGQVVMVF9ST0xMX1BFUklPRDtcbiAgdGhpcy5wcmV2aW91c1ZlcnRpY2FsWF8gPSAtMTtcbiAgdGhpcy5mcmFjdGlvbnNfID0gYXR0cnMuZnJhY3Rpb25zIHx8IGZhbHNlO1xuICB0aGlzLmRhdGVXaW5kb3dfID0gYXR0cnMuZGF0ZVdpbmRvdyB8fCBudWxsO1xuXG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG5cbiAgLy8gQ2xlYXIgdGhlIGRpdi4gVGhpcyBlbnN1cmUgdGhhdCwgaWYgbXVsdGlwbGUgZHlncmFwaHMgYXJlIHBhc3NlZCB0aGUgc2FtZVxuICAvLyBkaXYsIHRoZW4gb25seSBvbmUgd2lsbCBiZSBkcmF3bi5cbiAgZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cbiAgLy8gRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlICd3aWR0aCcgYW5kICdoZWlnaHQnIG9wdGlvbnMgdHJ1bXAgYWxsIENTU1xuICAvLyBydWxlcyBfZXhjZXB0XyBmb3IgYW4gZXhwbGljaXQgJ3dpZHRoJyBvciAnaGVpZ2h0JyBvbiB0aGUgZGl2LlxuICAvLyBBcyBhbiBhZGRlZCBjb252ZW5pZW5jZSwgaWYgdGhlIGRpdiBoYXMgemVybyBoZWlnaHQgKGxpa2UgPGRpdj48L2Rpdj4gZG9lc1xuICAvLyB3aXRob3V0IGFueSBzdHlsZXMpLCB0aGVuIHdlIHVzZSBhIGRlZmF1bHQgaGVpZ2h0L3dpZHRoLlxuICBpZiAoZGl2LnN0eWxlLndpZHRoID09PSAnJyAmJiBhdHRycy53aWR0aCkge1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGF0dHJzLndpZHRoICsgXCJweFwiO1xuICB9XG4gIGlmIChkaXYuc3R5bGUuaGVpZ2h0ID09PSAnJyAmJiBhdHRycy5oZWlnaHQpIHtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0ICsgXCJweFwiO1xuICB9XG4gIGlmIChkaXYuc3R5bGUuaGVpZ2h0ID09PSAnJyAmJiBkaXYuY2xpZW50SGVpZ2h0ID09PSAwKSB7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IER5Z3JhcGguREVGQVVMVF9IRUlHSFQgKyBcInB4XCI7XG4gICAgaWYgKGRpdi5zdHlsZS53aWR0aCA9PT0gJycpIHtcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IER5Z3JhcGguREVGQVVMVF9XSURUSCArIFwicHhcIjtcbiAgICB9XG4gIH1cbiAgLy8gVGhlc2Ugd2lsbCBiZSB6ZXJvIGlmIHRoZSBkeWdyYXBoJ3MgZGl2IGlzIGhpZGRlbi4gSW4gdGhhdCBjYXNlLFxuICAvLyB1c2UgdGhlIHVzZXItc3BlY2lmaWVkIGF0dHJpYnV0ZXMgaWYgcHJlc2VudC4gSWYgbm90LCB1c2UgemVyb1xuICAvLyBhbmQgYXNzdW1lIHRoZSB1c2VyIHdpbGwgY2FsbCByZXNpemUgdG8gZml4IHRoaW5ncyBsYXRlci5cbiAgdGhpcy53aWR0aF8gPSBkaXYuY2xpZW50V2lkdGggfHwgYXR0cnMud2lkdGggfHwgMDtcbiAgdGhpcy5oZWlnaHRfID0gZGl2LmNsaWVudEhlaWdodCB8fCBhdHRycy5oZWlnaHQgfHwgMDtcblxuICAvLyBUT0RPKGRhbnZrKTogc2V0IGZpbGxHcmFwaCB0byBiZSBwYXJ0IG9mIGF0dHJzXyBoZXJlLCBub3QgdXNlcl9hdHRyc18uXG4gIGlmIChhdHRycy5zdGFja2VkR3JhcGgpIHtcbiAgICBhdHRycy5maWxsR3JhcGggPSB0cnVlO1xuICAgIC8vIFRPRE8obmlraGlsayk6IEFkZCBhbnkgb3RoZXIgc3RhY2tlZEdyYXBoIGNoZWNrcyBoZXJlLlxuICB9XG5cbiAgLy8gREVQUkVDQVRJT04gV0FSTklORzogQWxsIG9wdGlvbiBwcm9jZXNzaW5nIHNob3VsZCBiZSBtb3ZlZCBmcm9tXG4gIC8vIGF0dHJzXyBhbmQgdXNlcl9hdHRyc18gdG8gb3B0aW9uc18sIHdoaWNoIGhvbGRzIGFsbCB0aGlzIGluZm9ybWF0aW9uLlxuICAvL1xuICAvLyBEeWdyYXBocyBoYXMgbWFueSBvcHRpb25zLCBzb21lIG9mIHdoaWNoIGludGVyYWN0IHdpdGggb25lIGFub3RoZXIuXG4gIC8vIFRvIGtlZXAgdHJhY2sgb2YgZXZlcnl0aGluZywgd2UgbWFpbnRhaW4gdHdvIHNldHMgb2Ygb3B0aW9uczpcbiAgLy9cbiAgLy8gIHRoaXMudXNlcl9hdHRyc18gICBvbmx5IG9wdGlvbnMgZXhwbGljaXRseSBzZXQgYnkgdGhlIHVzZXIuXG4gIC8vICB0aGlzLmF0dHJzXyAgICAgICAgZGVmYXVsdHMsIG9wdGlvbnMgZGVyaXZlZCBmcm9tIHVzZXJfYXR0cnNfLCBkYXRhLlxuICAvL1xuICAvLyBPcHRpb25zIGFyZSB0aGVuIGFjY2Vzc2VkIHRoaXMuYXR0cl8oJ2F0dHInKSwgd2hpY2ggZmlyc3QgbG9va3MgYXRcbiAgLy8gdXNlcl9hdHRyc18gYW5kIHRoZW4gY29tcHV0ZWQgYXR0cnNfLiBUaGlzIHdheSBEeWdyYXBocyBjYW4gc2V0IGludGVsbGlnZW50XG4gIC8vIGRlZmF1bHRzIHdpdGhvdXQgb3ZlcnJpZGluZyBiZWhhdmlvciB0aGF0IHRoZSB1c2VyIHNwZWNpZmljYWxseSBhc2tzIGZvci5cbiAgdGhpcy51c2VyX2F0dHJzXyA9IHt9O1xuICB1dGlscy51cGRhdGUodGhpcy51c2VyX2F0dHJzXywgYXR0cnMpO1xuXG4gIC8vIFRoaXMgc2VxdWVuY2UgZW5zdXJlcyB0aGF0IER5Z3JhcGguREVGQVVMVF9BVFRSUyBpcyBuZXZlciBtb2RpZmllZC5cbiAgdGhpcy5hdHRyc18gPSB7fTtcbiAgdXRpbHMudXBkYXRlRGVlcCh0aGlzLmF0dHJzXywgREVGQVVMVF9BVFRSUyk7XG5cbiAgdGhpcy5ib3VuZGFyeUlkc18gPSBbXTtcbiAgdGhpcy5zZXRJbmRleEJ5TmFtZV8gPSB7fTtcbiAgdGhpcy5kYXRhc2V0SW5kZXhfID0gW107XG5cbiAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzXyA9IFtdO1xuICB0aGlzLmV2ZW50TGlzdGVuZXJzXyA9IHt9O1xuXG4gIHRoaXMuYXR0cmlidXRlc18gPSBuZXcgRHlncmFwaE9wdGlvbnModGhpcyk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb250YWluaW5nIERJViBhbmQgb3RoZXIgaW50ZXJhY3RpdmUgZWxlbWVudHNcbiAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG5cbiAgLy8gQWN0aXZhdGUgcGx1Z2lucy5cbiAgdGhpcy5wbHVnaW5zXyA9IFtdO1xuICB2YXIgcGx1Z2lucyA9IER5Z3JhcGguUExVR0lOUy5jb25jYXQodGhpcy5nZXRPcHRpb24oJ3BsdWdpbnMnKSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHRoZSBwbHVnaW5zIG9wdGlvbiBtYXkgY29udGFpbiBlaXRoZXIgcGx1Z2luIGNsYXNzZXMgb3IgaW5zdGFuY2VzLlxuICAgIC8vIFBsdWdpbiBpbnN0YW5jZXMgY29udGFpbiBhbiBhY3RpdmF0ZSBtZXRob2QuXG4gICAgdmFyIFBsdWdpbiA9IHBsdWdpbnNbaV07ICAvLyBlaXRoZXIgYSBjb25zdHJ1Y3RvciBvciBhbiBpbnN0YW5jZS5cbiAgICB2YXIgcGx1Z2luSW5zdGFuY2U7XG4gICAgaWYgKHR5cGVvZihQbHVnaW4uYWN0aXZhdGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGx1Z2luSW5zdGFuY2UgPSBQbHVnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdWdpbkluc3RhbmNlID0gbmV3IFBsdWdpbigpO1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5EaWN0ID0ge1xuICAgICAgcGx1Z2luOiBwbHVnaW5JbnN0YW5jZSxcbiAgICAgIGV2ZW50czoge30sXG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIHBsdWdpbk9wdGlvbnM6IHt9XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVycyA9IHBsdWdpbkluc3RhbmNlLmFjdGl2YXRlKHRoaXMpO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKCFoYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcbiAgICAgIC8vIFRPRE8oZGFudmspOiB2YWxpZGF0ZSBldmVudE5hbWUuXG4gICAgICBwbHVnaW5EaWN0LmV2ZW50c1tldmVudE5hbWVdID0gaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbnNfLnB1c2gocGx1Z2luRGljdCk7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50LCBwbHVnaW5zIGNhbiBubyBsb25nZXIgcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMuXG4gIC8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGV2ZW50IC0+IG9yZGVyZWQgbGlzdCBvZiBbY2FsbGJhY2ssIHBsdWdpbl0uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zXy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbHVnaW5fZGljdCA9IHRoaXMucGx1Z2luc19baV07XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHBsdWdpbl9kaWN0LmV2ZW50cykge1xuICAgICAgaWYgKCFwbHVnaW5fZGljdC5ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkgY29udGludWU7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBwbHVnaW5fZGljdC5ldmVudHNbZXZlbnROYW1lXTtcblxuICAgICAgdmFyIHBhaXIgPSBbcGx1Z2luX2RpY3QucGx1Z2luLCBjYWxsYmFja107XG4gICAgICBpZiAoIShldmVudE5hbWUgaW4gdGhpcy5ldmVudExpc3RlbmVyc18pKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNfW2V2ZW50TmFtZV0gPSBbcGFpcl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzX1tldmVudE5hbWVdLnB1c2gocGFpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5jcmVhdGVEcmFnSW50ZXJmYWNlXygpO1xuXG4gIHRoaXMuc3RhcnRfKCk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXJzIGEgY2FzY2FkZSBvZiBldmVudHMgdG8gdGhlIHZhcmlvdXMgcGx1Z2lucyB3aGljaCBhcmUgaW50ZXJlc3RlZCBpbiB0aGVtLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBcImRlZmF1bHQgYmVoYXZpb3JcIiBzaG91bGQgYmUgcHJldmVudGVkLCBpLmUuIGlmIG9uZVxuICogb2YgdGhlIGV2ZW50IGxpc3RlbmVycyBjYWxsZWQgZXZlbnQucHJldmVudERlZmF1bHQoKS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNhc2NhZGVFdmVudHNfID0gZnVuY3Rpb24obmFtZSwgZXh0cmFfcHJvcHMpIHtcbiAgaWYgKCEobmFtZSBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzXykpIHJldHVybiBmYWxzZTtcblxuICAvLyBRVUVTVElPTjogY2FuIHdlIHVzZSBvYmplY3RzICYgcHJvdG90eXBlcyB0byBzcGVlZCB0aGlzIHVwP1xuICB2YXIgZSA9IHtcbiAgICBkeWdyYXBoOiB0aGlzLFxuICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZS5jYW5jZWxhYmxlKSB0aHJvdyBcIkNhbm5vdCBjYWxsIHByZXZlbnREZWZhdWx0IG9uIG5vbi1jYW5jZWxhYmxlIGV2ZW50LlwiO1xuICAgICAgZS5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3BhZ2F0aW9uU3RvcHBlZDogZmFsc2UsXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGUucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHV0aWxzLnVwZGF0ZShlLCBleHRyYV9wcm9wcyk7XG5cbiAgdmFyIGNhbGxiYWNrX3BsdWdpbl9wYWlycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNfW25hbWVdO1xuICBpZiAoY2FsbGJhY2tfcGx1Z2luX3BhaXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IGNhbGxiYWNrX3BsdWdpbl9wYWlycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHBsdWdpbiA9IGNhbGxiYWNrX3BsdWdpbl9wYWlyc1tpXVswXTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrX3BsdWdpbl9wYWlyc1tpXVsxXTtcbiAgICAgIGNhbGxiYWNrLmNhbGwocGx1Z2luLCBlKTtcbiAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCkgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlLmRlZmF1bHRQcmV2ZW50ZWQ7XG59O1xuXG4vKipcbiAqIEZldGNoIGEgcGx1Z2luIGluc3RhbmNlIG9mIGEgcGFydGljdWxhciBjbGFzcy4gT25seSBmb3IgdGVzdGluZy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFDbGFzc30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgcGx1Z2luLlxuICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiB0aGUgcGx1Z2luLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFBsdWdpbkluc3RhbmNlXyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBsdWdpbnNfW2ldO1xuICAgIGlmIChwLnBsdWdpbiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgIHJldHVybiBwLnBsdWdpbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHpvb21lZCBzdGF0dXMgb2YgdGhlIGNoYXJ0IGZvciBvbmUgb3IgYm90aCBheGVzLlxuICpcbiAqIEF4aXMgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLiBDYW4gYmUgc2V0IHRvICd4JyBvciAneScuXG4gKlxuICogVGhlIHpvb21lZCBzdGF0dXMgZm9yIGFuIGF4aXMgaXMgc2V0IHdoZW5ldmVyIGEgdXNlciB6b29tcyB1c2luZyB0aGUgbW91c2VcbiAqIG9yIHdoZW4gdGhlIGRhdGVXaW5kb3cgb3IgdmFsdWVSYW5nZSBhcmUgdXBkYXRlZC4gRG91YmxlLWNsaWNraW5nIG9yIGNhbGxpbmdcbiAqIHJlc2V0Wm9vbSgpIHJlc2V0cyB0aGUgem9vbSBzdGF0dXMgZm9yIHRoZSBjaGFydC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuaXNab29tZWQgPSBmdW5jdGlvbihheGlzKSB7XG4gIGNvbnN0IGlzWm9vbWVkWCA9ICEhdGhpcy5kYXRlV2luZG93XztcbiAgaWYgKGF4aXMgPT09ICd4JykgcmV0dXJuIGlzWm9vbWVkWDtcblxuICBjb25zdCBpc1pvb21lZFkgPSB0aGlzLmF4ZXNfLm1hcChheGlzID0+ICEhYXhpcy52YWx1ZVJhbmdlKS5pbmRleE9mKHRydWUpID49IDA7XG4gIGlmIChheGlzID09PSBudWxsIHx8IGF4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpc1pvb21lZFggfHwgaXNab29tZWRZO1xuICB9XG4gIGlmIChheGlzID09PSAneScpIHJldHVybiBpc1pvb21lZFk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBheGlzIHBhcmFtZXRlciBpcyBbJHtheGlzfV0gbXVzdCBiZSBudWxsLCAneCcgb3IgJ3knLmApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBEeWdyYXBoIG9iamVjdCwgaW5jbHVkaW5nIGl0cyBjb250YWluaW5nIElELlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWFpbmRpdiA9IHRoaXMubWFpbmRpdl87XG4gIHZhciBpZCA9IChtYWluZGl2ICYmIG1haW5kaXYuaWQpID8gbWFpbmRpdi5pZCA6IG1haW5kaXY7XG4gIHJldHVybiBcIltEeWdyYXBoIFwiICsgaWQgKyBcIl1cIjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGFuIG9wdGlvbi4gVGhpcyBtYXkgYmUgc2V0IGJ5IHRoZSB1c2VyIChlaXRoZXIgaW4gdGhlXG4gKiBjb25zdHJ1Y3RvciBvciBieSBjYWxsaW5nIHVwZGF0ZU9wdGlvbnMpIG9yIGJ5IGR5Z3JhcGhzLCBhbmQgbWF5IGJlIHNldCB0byBhXG4gKiBwZXItc2VyaWVzIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiwgZS5nLiAncm9sbFBlcmlvZCcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Nlcmllc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gd2hpY2ggdGhlIG9wdGlvblxuICogd2lsbCBiZSBhcHBsaWVkLiBJZiBubyBwZXItc2VyaWVzIHZhbHVlIG9mIHRoaXMgb3B0aW9uIGlzIGF2YWlsYWJsZSwgdGhlblxuICogdGhlIGdsb2JhbCB2YWx1ZSBpcyByZXR1cm5lZC4gVGhpcyBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm4geyAuLi4gfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYXR0cl8gPSBmdW5jdGlvbihuYW1lLCBzZXJpZXNOYW1lKSB7XG4gIC8vIEZvciBcInByb2R1Y3Rpb25cIiBjb2RlLCB0aGlzIGdldHMgcmVtb3ZlZCBieSB1Z2xpZnlqcy5cbiAgaWYgKHR5cGVvZihwcm9jZXNzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mKE9QVElPTlNfUkVGRVJFTkNFKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTXVzdCBpbmNsdWRlIG9wdGlvbnMgcmVmZXJlbmNlIEpTIGZvciB0ZXN0aW5nJyk7XG4gICAgICB9IGVsc2UgaWYgKCFPUFRJT05TX1JFRkVSRU5DRS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEeWdyYXBocyBpcyB1c2luZyBwcm9wZXJ0eSAnICsgbmFtZSArICcsIHdoaWNoIGhhcyBubyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnZW50cnkgaW4gdGhlIER5Z3JhcGhzLk9QVElPTlNfUkVGRVJFTkNFIGxpc3RpbmcuJyk7XG4gICAgICAgIC8vIE9ubHkgbG9nIHRoaXMgZXJyb3Igb25jZS5cbiAgICAgICAgT1BUSU9OU19SRUZFUkVOQ0VbbmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWVzTmFtZSA/IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yU2VyaWVzKG5hbWUsIHNlcmllc05hbWUpIDogdGhpcy5hdHRyaWJ1dGVzXy5nZXQobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGFuIG9wdGlvbiwgYXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBvciB2aWFcbiAqIHVwZGF0ZU9wdGlvbnMuIFlvdSBtYXkgcGFzcyBpbiBhbiAob3B0aW9uYWwpIHNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzXG4gKiB2YWx1ZXMgZm9yIHRoZSBvcHRpb24uXG4gKlxuICogQWxsIHZhbHVlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbW11dGFibGUuIElmIHlvdVxuICogbW9kaWZ5IHRoZW0sIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBjaGFuZ2VzIHdpbGwgYmUgaG9ub3JlZCBvciB0aGF0XG4gKiBkeWdyYXBocyB3aWxsIHJlbWFpbiBpbiBhIGNvbnNpc3RlbnQgc3RhdGUuIElmIHlvdSB3YW50IHRvIG1vZGlmeSBhbiBvcHRpb24sXG4gKiB1c2UgdXBkYXRlT3B0aW9ucygpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cl8obmFtZSwgb3B0X3Nlcmllc05hbWUpO1xufTtcblxuLyoqXG4gKiBMaWtlIGdldE9wdGlvbigpLCBidXQgc3BlY2lmaWNhbGx5IHJldHVybnMgYSBudW1iZXIuXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldE51bWVyaWNPcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle251bWJlcn0gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRTdHJpbmdPcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle3N0cmluZ30gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgYm9vbGVhbi5cbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEJvb2xlYW5PcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle2Jvb2xlYW59ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG4vKipcbiAqIExpa2UgZ2V0T3B0aW9uKCksIGJ1dCBzcGVjaWZpY2FsbHkgcmV0dXJucyBhIGZ1bmN0aW9uLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLil9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0RnVuY3Rpb25PcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle2Z1bmN0aW9uKC4uLil9ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRPcHRpb25Gb3JBeGlzID0gZnVuY3Rpb24obmFtZSwgYXhpcykge1xuICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKG5hbWUsIGF4aXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgVGhlIG5hbWUgb2YgdGhlIGF4aXMgKGkuZS4gJ3gnLCAneScgb3IgJ3kyJylcbiAqIEByZXR1cm4geyAuLi4gfSBBIGZ1bmN0aW9uIG1hcHBpbmcgc3RyaW5nIC0+IG9wdGlvbiB2YWx1ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5vcHRpb25zVmlld0ZvckF4aXNfID0gZnVuY3Rpb24oYXhpcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihvcHQpIHtcbiAgICB2YXIgYXhpc19vcHRzID0gc2VsZi51c2VyX2F0dHJzXy5heGVzO1xuICAgIGlmIChheGlzX29wdHMgJiYgYXhpc19vcHRzW2F4aXNdICYmIGF4aXNfb3B0c1theGlzXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gYXhpc19vcHRzW2F4aXNdW29wdF07XG4gICAgfVxuXG4gICAgLy8gSSBkb24ndCBsaWtlIHRoYXQgdGhpcyBpcyBpbiBhIHNlY29uZCBzcG90LlxuICAgIGlmIChheGlzID09PSAneCcgJiYgb3B0ID09PSAnbG9nc2NhbGUnKSB7XG4gICAgICAvLyByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBwdWxsIHRoZSBkZWZhdWx0IGZyb20gYSBnbG9iYWwgZGVmYXVsdC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyB1c2VyLXNwZWNpZmllZCBhdHRyaWJ1dGVzIGFsd2F5cyB0cnVtcCBkZWZhdWx0cywgZXZlbiBpZiB0aGV5J3JlIGxlc3NcbiAgICAvLyBzcGVjaWZpYy5cbiAgICBpZiAodHlwZW9mKHNlbGYudXNlcl9hdHRyc19bb3B0XSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBzZWxmLnVzZXJfYXR0cnNfW29wdF07XG4gICAgfVxuXG4gICAgYXhpc19vcHRzID0gc2VsZi5hdHRyc18uYXhlcztcbiAgICBpZiAoYXhpc19vcHRzICYmIGF4aXNfb3B0c1theGlzXSAmJiBheGlzX29wdHNbYXhpc10uaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgcmV0dXJuIGF4aXNfb3B0c1theGlzXVtvcHRdO1xuICAgIH1cbiAgICAvLyBjaGVjayBvbGQtc3R5bGUgYXhpcyBvcHRpb25zXG4gICAgLy8gVE9ETyhkYW52ayk6IGFkZCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgaWYgZWl0aGVyIG9mIHRoZXNlIG1hdGNoLlxuICAgIGlmIChheGlzID09ICd5JyAmJiBzZWxmLmF4ZXNfWzBdLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgIHJldHVybiBzZWxmLmF4ZXNfWzBdW29wdF07XG4gICAgfSBlbHNlIGlmIChheGlzID09ICd5MicgJiYgc2VsZi5heGVzX1sxXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gc2VsZi5heGVzX1sxXVtvcHRdO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5hdHRyXyhvcHQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvbGxpbmcgcGVyaW9kLCBhcyBzZXQgYnkgdGhlIHVzZXIgb3IgYW4gb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgcm9sbGluZyB3aW5kb3dcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucm9sbFBlcmlvZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb2xsUGVyaW9kXztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeC1yYW5nZS4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnkgem9vbWluZyxcbiAqIHBhbm5pbmcgb3IgYSBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtsZWZ0LCByaWdodF0uXG4gKiBJZiB0aGUgRHlncmFwaCBoYXMgZGF0ZXMgb24gdGhlIHgtYXhpcywgdGhlc2Ugd2lsbCBiZSBtaWxsaXMgc2luY2UgZXBvY2guXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnhBeGlzUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0ZVdpbmRvd18gPyB0aGlzLmRhdGVXaW5kb3dfIDogdGhpcy54QXhpc0V4dHJlbWVzKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvd2VyLSBhbmQgdXBwZXItYm91bmQgeC1heGlzIHZhbHVlcyBvZiB0aGUgZGF0YSBzZXQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnhBeGlzRXh0cmVtZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhZCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbigneFJhbmdlUGFkJykgLyB0aGlzLnBsb3R0ZXJfLmFyZWEudztcbiAgaWYgKHRoaXMubnVtUm93cygpID09PSAwKSB7XG4gICAgcmV0dXJuIFswIC0gcGFkLCAxICsgcGFkXTtcbiAgfVxuICB2YXIgbGVmdCA9IHRoaXMucmF3RGF0YV9bMF1bMF07XG4gIHZhciByaWdodCA9IHRoaXMucmF3RGF0YV9bdGhpcy5yYXdEYXRhXy5sZW5ndGggLSAxXVswXTtcbiAgaWYgKHBhZCkge1xuICAgIC8vIE11c3Qga2VlcCB0aGlzIGluIHN5bmMgd2l0aCBkeWdyYXBoLWxheW91dCBfZXZhbHVhdGVMaW1pdHMoKVxuICAgIHZhciByYW5nZSA9IHJpZ2h0IC0gbGVmdDtcbiAgICBsZWZ0IC09IHJhbmdlICogcGFkO1xuICAgIHJpZ2h0ICs9IHJhbmdlICogcGFkO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb3dlci0gYW5kIHVwcGVyLWJvdW5kIHktYXhpcyB2YWx1ZXMgZm9yIGVhY2ggYXhpcy4gVGhlc2UgYXJlXG4gKiB0aGUgcmFuZ2VzIHlvdSdsbCBnZXQgaWYgeW91IGRvdWJsZS1jbGljayB0byB6b29tIG91dCBvciBjYWxsIHJlc2V0Wm9vbSgpLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBhcnJheSBvZiBbbG93LCBoaWdoXSB0dXBsZXMsIG9uZSBmb3IgZWFjaCB5LWF4aXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnlBeGlzRXh0cmVtZXMgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHRoaXMgaXMgcHJldHR5IGluZWZmaWNpZW50XG4gIGNvbnN0IHBhY2tlZCA9IHRoaXMuZ2F0aGVyRGF0YXNldHNfKHRoaXMucm9sbGVkU2VyaWVzXywgbnVsbCk7XG4gIGNvbnN0IHsgZXh0cmVtZXMgfSA9IHBhY2tlZDtcbiAgY29uc3Qgc2F2ZUF4ZXMgPSB0aGlzLmF4ZXNfO1xuICB0aGlzLmNvbXB1dGVZQXhpc1Jhbmdlc18oZXh0cmVtZXMpO1xuICBjb25zdCBuZXdBeGVzID0gdGhpcy5heGVzXztcbiAgdGhpcy5heGVzXyA9IHNhdmVBeGVzO1xuICByZXR1cm4gbmV3QXhlcy5tYXAoYXhpcyA9PiBheGlzLmV4dHJlbWVSYW5nZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeS1yYW5nZSBmb3IgYW4gYXhpcy4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnlcbiAqIHpvb21pbmcsIHBhbm5pbmcgb3IgYSBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMuIEF4aXMgaW5kaWNlcyBhcmUgemVyby1iYXNlZC4gSWZcbiAqIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGF4aXMuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtib3R0b20sIHRvcF0uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnlBeGlzUmFuZ2UgPSBmdW5jdGlvbihpZHgpIHtcbiAgaWYgKHR5cGVvZihpZHgpID09IFwidW5kZWZpbmVkXCIpIGlkeCA9IDA7XG4gIGlmIChpZHggPCAwIHx8IGlkeCA+PSB0aGlzLmF4ZXNfLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBheGlzID0gdGhpcy5heGVzX1tpZHhdO1xuICByZXR1cm4gWyBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSwgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeS1yYW5nZXMgZm9yIGVhY2ggYXhpcy4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnlcbiAqIHpvb21pbmcsIHBhbm5pbmcsIGNhbGxzIHRvIHVwZGF0ZU9wdGlvbnMsIGV0Yy5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2JvdHRvbSwgdG9wXSBwYWlycywgb25lIGZvciBlYWNoIHktYXhpcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueUF4aXNSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICByZXQucHVzaCh0aGlzLnlBeGlzUmFuZ2UoaSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBUT0RPKGRhbnZrKTogdXNlIHRoZXNlIGZ1bmN0aW9ucyB0aHJvdWdob3V0IGR5Z3JhcGhzLlxuLyoqXG4gKiBDb252ZXJ0IGZyb20gZGF0YSBjb29yZGluYXRlcyB0byBjYW52YXMvZGl2IFgvWSBjb29yZGluYXRlcy5cbiAqIElmIHNwZWNpZmllZCwgZG8gdGhpcyBjb252ZXJzaW9uIGZvciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBheGlzLiBVc2VzIHRoZSBmaXJzdCBheGlzIGJ5IGRlZmF1bHQuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXVxuICpcbiAqIE5vdGU6IHVzZSB0b0RvbVhDb29yZCBpbnN0ZWFkIG9mIHRvRG9tQ29vcmRzKHgsIG51bGwpIGFuZCB1c2UgdG9Eb21ZQ29vcmRcbiAqIGluc3RlYWQgb2YgdG9Eb21Db29yZHMobnVsbCwgeSwgYXhpcykuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tQ29vcmRzID0gZnVuY3Rpb24oeCwgeSwgYXhpcykge1xuICByZXR1cm4gWyB0aGlzLnRvRG9tWENvb3JkKHgpLCB0aGlzLnRvRG9tWUNvb3JkKHksIGF4aXMpIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBkYXRhIHggY29vcmRpbmF0ZXMgdG8gY2FudmFzL2RpdiBYIGNvb3JkaW5hdGUuXG4gKiBJZiBzcGVjaWZpZWQsIGRvIHRoaXMgY29udmVyc2lvbiBmb3IgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIGEgcGFydGljdWxhclxuICogYXhpcy5cbiAqIFJldHVybnMgYSBzaW5nbGUgdmFsdWUgb3IgbnVsbCBpZiB4IGlzIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tWENvb3JkID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFyZWEgPSB0aGlzLnBsb3R0ZXJfLmFyZWE7XG4gIHZhciB4UmFuZ2UgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgcmV0dXJuIGFyZWEueCArICh4IC0geFJhbmdlWzBdKSAvICh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pICogYXJlYS53O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gZGF0YSB4IGNvb3JkaW5hdGVzIHRvIGNhbnZhcy9kaXYgWSBjb29yZGluYXRlIGFuZCBvcHRpb25hbFxuICogYXhpcy4gVXNlcyB0aGUgZmlyc3QgYXhpcyBieSBkZWZhdWx0LlxuICpcbiAqIHJldHVybnMgYSBzaW5nbGUgdmFsdWUgb3IgbnVsbCBpZiB5IGlzIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tWUNvb3JkID0gZnVuY3Rpb24oeSwgYXhpcykge1xuICB2YXIgcGN0ID0gdGhpcy50b1BlcmNlbnRZQ29vcmQoeSwgYXhpcyk7XG5cbiAgaWYgKHBjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBhcmVhID0gdGhpcy5wbG90dGVyXy5hcmVhO1xuICByZXR1cm4gYXJlYS55ICsgcGN0ICogYXJlYS5oO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FudmFzL2RpdiBjb29yZHMgdG8gZGF0YSBjb29yZGluYXRlcy5cbiAqIElmIHNwZWNpZmllZCwgZG8gdGhpcyBjb252ZXJzaW9uIGZvciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBheGlzLiBVc2VzIHRoZSBmaXJzdCBheGlzIGJ5IGRlZmF1bHQuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXS5cbiAqXG4gKiBOb3RlOiB1c2UgdG9EYXRhWENvb3JkIGluc3RlYWQgb2YgdG9EYXRhQ29vcmRzKHgsIG51bGwpIGFuZCB1c2UgdG9EYXRhWUNvb3JkXG4gKiBpbnN0ZWFkIG9mIHRvRGF0YUNvb3JkcyhudWxsLCB5LCBheGlzKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9EYXRhQ29vcmRzID0gZnVuY3Rpb24oeCwgeSwgYXhpcykge1xuICByZXR1cm4gWyB0aGlzLnRvRGF0YVhDb29yZCh4KSwgdGhpcy50b0RhdGFZQ29vcmQoeSwgYXhpcykgXTtcbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGNhbnZhcy9kaXYgeCBjb29yZGluYXRlIHRvIGRhdGEgY29vcmRpbmF0ZS5cbiAqXG4gKiBJZiB4IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RhdGFYQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHhSYW5nZSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuXG4gIGlmICghdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHJldHVybiB4UmFuZ2VbMF0gKyAoeCAtIGFyZWEueCkgLyBhcmVhLncgKiAoeFJhbmdlWzFdIC0geFJhbmdlWzBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGN0ID0gKHggLSBhcmVhLngpIC8gYXJlYS53O1xuICAgIHJldHVybiB1dGlscy5sb2dSYW5nZUZyYWN0aW9uKHhSYW5nZVswXSwgeFJhbmdlWzFdLCBwY3QpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW52YXMvZGl2IHkgY29vcmQgdG8gdmFsdWUuXG4gKlxuICogSWYgeSBpcyBudWxsLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIGlmIGF4aXMgaXMgbnVsbCwgdGhpcyB1c2VzIHRoZSBmaXJzdCBheGlzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RhdGFZQ29vcmQgPSBmdW5jdGlvbih5LCBheGlzKSB7XG4gIGlmICh5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHlSYW5nZSA9IHRoaXMueUF4aXNSYW5nZShheGlzKTtcblxuICBpZiAodHlwZW9mKGF4aXMpID09IFwidW5kZWZpbmVkXCIpIGF4aXMgPSAwO1xuICBpZiAoIXRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGF4aXMpKSB7XG4gICAgcmV0dXJuIHlSYW5nZVswXSArIChhcmVhLnkgKyBhcmVhLmggLSB5KSAvIGFyZWEuaCAqICh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXB1dGluZyB0aGUgaW52ZXJzZSBvZiB0b0RvbUNvb3JkLlxuICAgIHZhciBwY3QgPSAoeSAtIGFyZWEueSkgLyBhcmVhLmg7XG4gICAgLy8gTm90ZSByZXZlcnNlZCB5UmFuZ2UsIHkxIGlzIG9uIHRvcCB3aXRoIHBjdD09MC5cbiAgICByZXR1cm4gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih5UmFuZ2VbMV0sIHlSYW5nZVswXSwgcGN0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHkgZm9yIGFuIGF4aXMgdG8gYSBwZXJjZW50YWdlIGZyb20gdGhlIHRvcCB0byB0aGVcbiAqIGJvdHRvbSBvZiB0aGUgZHJhd2luZyBhcmVhLlxuICpcbiAqIElmIHRoZSBjb29yZGluYXRlIHJlcHJlc2VudHMgYSB2YWx1ZSB2aXNpYmxlIG9uIHRoZSBjYW52YXMsIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgdG9wIG9mIHRoZSBjYW52YXMuXG4gKiBIb3dldmVyLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB2YWx1ZXMgb3V0c2lkZSB0aGUgcmFuZ2UsIGFzXG4gKiB2YWx1ZXMgY2FuIGZhbGwgb3V0c2lkZSB0aGUgY2FudmFzLlxuICpcbiAqIElmIHkgaXMgbnVsbCwgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBpZiBheGlzIGlzIG51bGwsIHRoaXMgdXNlcyB0aGUgZmlyc3QgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgZGF0YSB5LWNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2F4aXNdIFRoZSBheGlzIG51bWJlciBvbiB3aGljaCB0aGUgZGF0YSBjb29yZGluYXRlIGxpdmVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBIGZyYWN0aW9uIGluIFswLCAxXSB3aGVyZSAwID0gdGhlIHRvcCBlZGdlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b1BlcmNlbnRZQ29vcmQgPSBmdW5jdGlvbih5LCBheGlzKSB7XG4gIGlmICh5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZihheGlzKSA9PSBcInVuZGVmaW5lZFwiKSBheGlzID0gMDtcblxuICB2YXIgeVJhbmdlID0gdGhpcy55QXhpc1JhbmdlKGF4aXMpO1xuXG4gIHZhciBwY3Q7XG4gIHZhciBsb2dzY2FsZSA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGF4aXMpO1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICB2YXIgbG9ncjAgPSB1dGlscy5sb2cxMCh5UmFuZ2VbMF0pO1xuICAgIHZhciBsb2dyMSA9IHV0aWxzLmxvZzEwKHlSYW5nZVsxXSk7XG4gICAgcGN0ID0gKGxvZ3IxIC0gdXRpbHMubG9nMTAoeSkpIC8gKGxvZ3IxIC0gbG9ncjApO1xuICB9IGVsc2Uge1xuICAgIC8vIHlSYW5nZVsxXSAtIHkgaXMgdW5pdCBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b20uXG4gICAgLy8geVJhbmdlWzFdIC0geVJhbmdlWzBdIGlzIHRoZSBzY2FsZSBvZiB0aGUgcmFuZ2UuXG4gICAgLy8gKHlSYW5nZVsxXSAtIHkpIC8gKHlSYW5nZVsxXSAtIHlSYW5nZVswXSkgaXMgdGhlICUgZnJvbSB0aGUgYm90dG9tLlxuICAgIHBjdCA9ICh5UmFuZ2VbMV0gLSB5KSAvICh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pO1xuICB9XG4gIHJldHVybiBwY3Q7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIHggdmFsdWUgdG8gYSBwZXJjZW50YWdlIGZyb20gdGhlIGxlZnQgdG8gdGhlIHJpZ2h0IG9mXG4gKiB0aGUgZHJhd2luZyBhcmVhLlxuICpcbiAqIElmIHRoZSBjb29yZGluYXRlIHJlcHJlc2VudHMgYSB2YWx1ZSB2aXNpYmxlIG9uIHRoZSBjYW52YXMsIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgbGVmdCBvZiB0aGUgY2FudmFzLlxuICogSG93ZXZlciwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdmFsdWVzIG91dHNpZGUgdGhlIHJhbmdlLCBhc1xuICogdmFsdWVzIGNhbiBmYWxsIG91dHNpZGUgdGhlIGNhbnZhcy5cbiAqXG4gKiBJZiB4IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGRhdGEgeC1jb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBIGZyYWN0aW9uIGluIFswLCAxXSB3aGVyZSAwID0gdGhlIGxlZnQgZWRnZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9QZXJjZW50WENvb3JkID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHhSYW5nZSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICB2YXIgcGN0O1xuICB2YXIgbG9nc2NhbGUgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCAneCcpIDtcbiAgaWYgKGxvZ3NjYWxlID09PSB0cnVlKSB7ICAvLyBsb2dzY2FsZSBjYW4gYmUgbnVsbCBzbyB3ZSB0ZXN0IGZvciB0cnVlIGV4cGxpY2l0bHkuXG4gICAgdmFyIGxvZ3IwID0gdXRpbHMubG9nMTAoeFJhbmdlWzBdKTtcbiAgICB2YXIgbG9ncjEgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMV0pO1xuICAgIHBjdCA9ICh1dGlscy5sb2cxMCh4KSAtIGxvZ3IwKSAvIChsb2dyMSAtIGxvZ3IwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB4IC0geFJhbmdlWzBdIGlzIHVuaXQgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdC5cbiAgICAvLyB4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0gaXMgdGhlIHNjYWxlIG9mIHRoZSByYW5nZS5cbiAgICAvLyBUaGUgZnVsbCBleHByZXNzaW9uIGJlbG93IGlzIHRoZSAlIGZyb20gdGhlIGxlZnQuXG4gICAgcGN0ID0gKHggLSB4UmFuZ2VbMF0pIC8gKHhSYW5nZVsxXSAtIHhSYW5nZVswXSk7XG4gIH1cbiAgcmV0dXJuIHBjdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKGluY2x1ZGluZyB0aGUgaW5kZXBlbmRlbnQgdmFyaWFibGUpLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm51bUNvbHVtbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnJhd0RhdGFfKSByZXR1cm4gMDtcbiAgcmV0dXJuIHRoaXMucmF3RGF0YV9bMF0gPyB0aGlzLnJhd0RhdGFfWzBdLmxlbmd0aCA6IHRoaXMuYXR0cl8oXCJsYWJlbHNcIikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyAoZXhjbHVkaW5nIGFueSBoZWFkZXIvbGFiZWwgcm93KS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzLCBsZXNzIGFueSBoZWFkZXIuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm51bVJvd3MgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnJhd0RhdGFfKSByZXR1cm4gMDtcbiAgcmV0dXJuIHRoaXMucmF3RGF0YV8ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW4uIElmIHRoZSByb3cgYW5kIGNvbHVtbiBleGNlZWRcbiAqIHRoZSBib3VuZHMgb24gdGhlIGRhdGEsIHJldHVybnMgbnVsbC4gQWxzbyByZXR1cm5zIG51bGwgaWYgdGhlIHZhbHVlIGlzXG4gKiBtaXNzaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdyBUaGUgcm93IG51bWJlciBvZiB0aGUgZGF0YSAoMC1iYXNlZCkuIFJvdyAwIGlzIHRoZVxuICogICAgIGZpcnN0IHJvdyBvZiBkYXRhLCBub3QgYSBoZWFkZXIgcm93LlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIG51bWJlciBvZiB0aGUgZGF0YSAoMC1iYXNlZClcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGluIHRoZSBzcGVjaWZpZWQgY2VsbCBvciBudWxsIGlmIHRoZSByb3cvY29sXG4gKiAgICAgd2VyZSBvdXQgb2YgcmFuZ2UuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgaWYgKHJvdyA8IDAgfHwgcm93ID4gdGhpcy5yYXdEYXRhXy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBpZiAoY29sIDwgMCB8fCBjb2wgPiB0aGlzLnJhd0RhdGFfW3Jvd10ubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gdGhpcy5yYXdEYXRhX1tyb3ddW2NvbF07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIHRoZSBEeWdyYXBoOiBhIGNvbnRhaW5pbmcgZGl2LCBhIGRpdiB0b1xuICogZGlzcGxheSB0aGUgY3VycmVudCBwb2ludCwgYW5kIGEgdGV4dGJveCB0byBhZGp1c3QgdGhlIHJvbGxpbmcgYXZlcmFnZVxuICogcGVyaW9kLiBBbHNvIGNyZWF0ZXMgdGhlIFJlbmRlcmVyL0xheW91dCBlbGVtZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZUludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgLy8gQ3JlYXRlIHRoZSBhbGwtZW5jbG9zaW5nIGdyYXBoIGRpdlxuICB2YXIgZW5jbG9zaW5nID0gdGhpcy5tYWluZGl2XztcblxuICB0aGlzLmdyYXBoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAvLyBUT0RPKGRhbnZrKTogYW55IG90aGVyIHN0eWxlcyB0aGF0IGFyZSB1c2VmdWwgdG8gc2V0IGhlcmU/XG4gIHRoaXMuZ3JhcGhEaXYuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnOyAgLy8gVGhpcyBpcyBhIENTUyBcInJlc2V0XCJcbiAgdGhpcy5ncmFwaERpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGVuY2xvc2luZy5hcHBlbmRDaGlsZCh0aGlzLmdyYXBoRGl2KTtcblxuICAvLyBDcmVhdGUgdGhlIGNhbnZhcyBmb3IgaW50ZXJhY3RpdmUgcGFydHMgb2YgdGhlIGNoYXJ0LlxuICB0aGlzLmNhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5jYW52YXNfLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gIC8vIC4uLiBhbmQgZm9yIHN0YXRpYyBwYXJ0cyBvZiB0aGUgY2hhcnQuXG4gIHRoaXMuaGlkZGVuXyA9IHRoaXMuY3JlYXRlUGxvdEtpdENhbnZhc18odGhpcy5jYW52YXNfKTtcblxuICB0aGlzLmNhbnZhc19jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmNhbnZhc18pO1xuICB0aGlzLmhpZGRlbl9jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmhpZGRlbl8pO1xuXG4gIHRoaXMucmVzaXplRWxlbWVudHNfKCk7XG5cbiAgLy8gVGhlIGludGVyYWN0aXZlIHBhcnRzIG9mIHRoZSBncmFwaCBhcmUgZHJhd24gb24gdG9wIG9mIHRoZSBjaGFydC5cbiAgdGhpcy5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbl8pO1xuICB0aGlzLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzXyk7XG4gIHRoaXMubW91c2VFdmVudEVsZW1lbnRfID0gdGhpcy5jcmVhdGVNb3VzZUV2ZW50RWxlbWVudF8oKTtcblxuICAvLyBDcmVhdGUgdGhlIGdyYXBoZXJcbiAgdGhpcy5sYXlvdXRfID0gbmV3IER5Z3JhcGhMYXlvdXQodGhpcyk7XG5cbiAgdmFyIGR5Z3JhcGggPSB0aGlzO1xuXG4gIHRoaXMubW91c2VNb3ZlSGFuZGxlcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgZHlncmFwaC5tb3VzZU1vdmVfKGUpO1xuICB9O1xuXG4gIHRoaXMubW91c2VPdXRIYW5kbGVyXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBUaGUgbW91c2UgaGFzIGxlZnQgdGhlIGNoYXJ0IGlmOlxuICAgIC8vIDEuIGUudGFyZ2V0IGlzIGluc2lkZSB0aGUgY2hhcnRcbiAgICAvLyAyLiBlLnJlbGF0ZWRUYXJnZXQgaXMgb3V0c2lkZSB0aGUgY2hhcnRcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5mcm9tRWxlbWVudDtcbiAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudDtcbiAgICBpZiAodXRpbHMuaXNOb2RlQ29udGFpbmVkQnkodGFyZ2V0LCBkeWdyYXBoLmdyYXBoRGl2KSAmJlxuICAgICAgICAhdXRpbHMuaXNOb2RlQ29udGFpbmVkQnkocmVsYXRlZFRhcmdldCwgZHlncmFwaC5ncmFwaERpdikpIHtcbiAgICAgIGR5Z3JhcGgubW91c2VPdXRfKGUpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQod2luZG93LCAnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcl8pO1xuICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5tb3VzZUV2ZW50RWxlbWVudF8sICdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXJfKTtcblxuICAvLyBEb24ndCByZWNyZWF0ZSBhbmQgcmVnaXN0ZXIgdGhlIHJlc2l6ZSBoYW5kbGVyIG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBncmFwaCBpcyByZXNpemVkLlxuICBpZiAoIXRoaXMucmVzaXplSGFuZGxlcl8pIHtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gZnVuY3Rpb24oZSkge1xuICAgICAgZHlncmFwaC5yZXNpemUoKTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemVkLlxuICAgIC8vIFRPRE8oZGFudmspOiBkcm9wIGZyYW1lcyBkZXBlbmRpbmcgb24gY29tcGxleGl0eSBvZiB0aGUgY2hhcnQuXG4gICAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5yZXNpemVFbGVtZW50c18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaERpdi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiO1xuICB0aGlzLmdyYXBoRGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyArIFwicHhcIjtcblxuICB2YXIgcGl4ZWxSYXRpb09wdGlvbiA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbigncGl4ZWxSYXRpbycpXG5cbiAgdmFyIGNhbnZhc1NjYWxlID0gcGl4ZWxSYXRpb09wdGlvbiB8fCB1dGlscy5nZXRDb250ZXh0UGl4ZWxSYXRpbyh0aGlzLmNhbnZhc19jdHhfKTtcbiAgdGhpcy5jYW52YXNfLndpZHRoID0gdGhpcy53aWR0aF8gKiBjYW52YXNTY2FsZTtcbiAgdGhpcy5jYW52YXNfLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyAqIGNhbnZhc1NjYWxlO1xuICB0aGlzLmNhbnZhc18uc3R5bGUud2lkdGggPSB0aGlzLndpZHRoXyArIFwicHhcIjsgICAgLy8gZm9yIElFXG4gIHRoaXMuY2FudmFzXy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7ICAvLyBmb3IgSUVcbiAgaWYgKGNhbnZhc1NjYWxlICE9PSAxKSB7XG4gICAgdGhpcy5jYW52YXNfY3R4Xy5zY2FsZShjYW52YXNTY2FsZSwgY2FudmFzU2NhbGUpO1xuICB9XG5cbiAgdmFyIGhpZGRlblNjYWxlID0gcGl4ZWxSYXRpb09wdGlvbiB8fCB1dGlscy5nZXRDb250ZXh0UGl4ZWxSYXRpbyh0aGlzLmhpZGRlbl9jdHhfKTtcbiAgdGhpcy5oaWRkZW5fLndpZHRoID0gdGhpcy53aWR0aF8gKiBoaWRkZW5TY2FsZTtcbiAgdGhpcy5oaWRkZW5fLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyAqIGhpZGRlblNjYWxlO1xuICB0aGlzLmhpZGRlbl8uc3R5bGUud2lkdGggPSB0aGlzLndpZHRoXyArIFwicHhcIjsgICAgLy8gZm9yIElFXG4gIHRoaXMuaGlkZGVuXy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7ICAvLyBmb3IgSUVcbiAgaWYgKGhpZGRlblNjYWxlICE9PSAxKSB7XG4gICAgdGhpcy5oaWRkZW5fY3R4Xy5zY2FsZShoaWRkZW5TY2FsZSwgaGlkZGVuU2NhbGUpO1xuICB9XG59O1xuXG4vKipcbiAqIERldGFjaCBET00gZWxlbWVudHMgaW4gdGhlIGR5Z3JhcGggYW5kIG51bGwgb3V0IGFsbCBkYXRhIHJlZmVyZW5jZXMuXG4gKiBDYWxsaW5nIHRoaXMgd2hlbiB5b3UncmUgZG9uZSB3aXRoIGEgZHlncmFwaCBjYW4gZHJhbWF0aWNhbGx5IHJlZHVjZSBtZW1vcnlcbiAqIHVzYWdlLiBTZWUsIGUuZy4sIHRoZSB0ZXN0cy9wZXJmLmh0bWwgZXhhbXBsZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhbnZhc19jdHhfLnJlc3RvcmUoKTtcbiAgdGhpcy5oaWRkZW5fY3R4Xy5yZXN0b3JlKCk7XG5cbiAgLy8gRGVzdHJveSBhbnkgcGx1Z2lucywgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdGhhdCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cbiAgZm9yICh2YXIgaSA9IHRoaXMucGx1Z2luc18ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcCA9IHRoaXMucGx1Z2luc18ucG9wKCk7XG4gICAgaWYgKHAucGx1Z2luLmRlc3Ryb3kpIHAucGx1Z2luLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHZhciByZW1vdmVSZWN1cnNpdmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICByZW1vdmVSZWN1cnNpdmUobm9kZS5maXJzdENoaWxkKTtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5yZW1vdmVUcmFja2VkRXZlbnRzXygpO1xuXG4gIC8vIHJlbW92ZSBtb3VzZSBldmVudCBoYW5kbGVycyAoVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSBhbnltb3JlKVxuICB1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRIYW5kbGVyXyk7XG4gIHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMubW91c2VFdmVudEVsZW1lbnRfLCAnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyXyk7XG5cbiAgLy8gcmVtb3ZlIHdpbmRvdyBoYW5kbGVyc1xuICB1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gbnVsbDtcblxuICByZW1vdmVSZWN1cnNpdmUodGhpcy5tYWluZGl2Xyk7XG5cbiAgdmFyIG51bGxPdXQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBmb3IgKHZhciBuIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZihvYmpbbl0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvYmpbbl0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlc2UgbWF5IG5vdCBhbGwgYmUgbmVjZXNzYXJ5LCBidXQgaXQgY2FuJ3QgaHVydC4uLlxuICBudWxsT3V0KHRoaXMubGF5b3V0Xyk7XG4gIG51bGxPdXQodGhpcy5wbG90dGVyXyk7XG4gIG51bGxPdXQodGhpcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGNhbnZhcyBvbiB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBkcmF3bi4gT25seSB0aGUgUmVuZGVyZXIgZXZlclxuICogZHJhd3Mgb24gdGhpcyBwYXJ0aWN1bGFyIGNhbnZhcy4gQWxsIER5Z3JhcGggd29yayAoaS5lLiBkcmF3aW5nIGhvdmVyIGRvdHNcbiAqIG9yIHRoZSB6b29tIHJlY3RhbmdsZXMpIGlzIGRvbmUgb24gdGhpcy5jYW52YXNfLlxuICogQHBhcmFtIHtPYmplY3R9IGNhbnZhcyBUaGUgRHlncmFwaCBjYW52YXMgb3ZlciB3aGljaCB0byBvdmVybGF5IHRoZSBwbG90XG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXdseS1jcmVhdGVkIGNhbnZhc1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlUGxvdEtpdENhbnZhc18gPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgdmFyIGggPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgaC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgLy8gVE9ETyhkYW52ayk6IGggc2hvdWxkIGJlIG9mZnNldCBmcm9tIGNhbnZhcy4gY2FudmFzIG5lZWRzIHRvIGluY2x1ZGVcbiAgLy8gc29tZSBleHRyYSBhcmVhIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHpvb20gaW4gb24gdGhlIGZhciBsZWZ0IGFuZCBmYXJcbiAgLy8gcmlnaHQuIGggbmVlZHMgdG8gYmUgcHJlY2lzZWx5IHRoZSBwbG90IGFyZWEsIHNvIHRoYXQgY2xpcHBpbmcgb2NjdXJzLlxuICBoLnN0eWxlLnRvcCA9IGNhbnZhcy5zdHlsZS50b3A7XG4gIGguc3R5bGUubGVmdCA9IGNhbnZhcy5zdHlsZS5sZWZ0O1xuICBoLndpZHRoID0gdGhpcy53aWR0aF87XG4gIGguaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuICBoLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aF8gKyBcInB4XCI7ICAgIC8vIGZvciBJRVxuICBoLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyArIFwicHhcIjsgIC8vIGZvciBJRVxuICByZXR1cm4gaDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvdmVybGF5IGVsZW1lbnQgdXNlZCB0byBoYW5kbGUgbW91c2UgZXZlbnRzLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbW91c2UgZXZlbnQgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZU1vdXNlRXZlbnRFbGVtZW50XyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXNfO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBkaXN0aW5jdCBjb2xvcnMgZm9yIHRoZSBkYXRhIHNlcmllcy4gVGhpcyBpcyBkb25lIHdpdGggYVxuICogY29sb3Igd2hlZWwuIFNhdHVyYXRpb24vVmFsdWUgYXJlIGN1c3RvbWl6YWJsZSwgYW5kIHRoZSBodWUgaXNcbiAqIGVxdWFsbHktc3BhY2VkIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuIElmIGEgY3VzdG9tIHNldCBvZiBjb2xvcnMgaXNcbiAqIHNwZWNpZmllZCwgdGhhdCBpcyB1c2VkIGluc3RlYWQuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRDb2xvcnNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICB2YXIgbnVtID0gbGFiZWxzLmxlbmd0aCAtIDE7XG4gIHRoaXMuY29sb3JzXyA9IFtdO1xuICB0aGlzLmNvbG9yc01hcF8gPSB7fTtcblxuICAvLyBUaGVzZSBhcmUgdXNlZCBmb3Igd2hlbiBubyBjdXN0b20gY29sb3JzIGFyZSBzcGVjaWZpZWQuXG4gIHZhciBzYXQgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2NvbG9yU2F0dXJhdGlvbicpIHx8IDEuMDtcbiAgdmFyIHZhbCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignY29sb3JWYWx1ZScpIHx8IDAuNTtcbiAgdmFyIGhhbGYgPSBNYXRoLmNlaWwobnVtIC8gMik7XG5cbiAgdmFyIGNvbG9ycyA9IHRoaXMuZ2V0T3B0aW9uKCdjb2xvcnMnKTtcbiAgdmFyIHZpc2liaWxpdHkgPSB0aGlzLnZpc2liaWxpdHkoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGlmICghdmlzaWJpbGl0eVtpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpICsgMV07XG4gICAgdmFyIGNvbG9yU3RyID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMoJ2NvbG9yJywgbGFiZWwpO1xuICAgIGlmICghY29sb3JTdHIpIHtcbiAgICAgIGlmIChjb2xvcnMpIHtcbiAgICAgICAgY29sb3JTdHIgPSBjb2xvcnNbaSAlIGNvbG9ycy5sZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWx0ZXJuYXRlIGNvbG9ycyBmb3IgaGlnaCBjb250cmFzdC5cbiAgICAgICAgdmFyIGlkeCA9IGkgJSAyID8gKGhhbGYgKyAoaSArIDEpLyAyKSA6IE1hdGguY2VpbCgoaSArIDEpIC8gMik7XG4gICAgICAgIHZhciBodWUgPSAoMS4wICogaWR4IC8gKDEgKyBudW0pKTtcbiAgICAgICAgY29sb3JTdHIgPSB1dGlscy5oc3ZUb1JHQihodWUsIHNhdCwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb2xvcnNfLnB1c2goY29sb3JTdHIpO1xuICAgIHRoaXMuY29sb3JzTWFwX1tsYWJlbF0gPSBjb2xvclN0cjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3Qgb2YgY29sb3JzLiBUaGlzIGlzIGVpdGhlciB0aGUgbGlzdCBvZiBjb2xvcnMgcGFzc2VkIGluIHRoZVxuICogYXR0cmlidXRlcyBvciB0aGUgYXV0b2dlbmVyYXRlZCBsaXN0IG9mIHJnYihyLGcsYikgc3RyaW5ncy5cbiAqIFRoaXMgZG9lcyBub3QgcmV0dXJuIGNvbG9ycyBmb3IgaW52aXNpYmxlIHNlcmllcy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBUaGUgbGlzdCBvZiBjb2xvcnMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldENvbG9ycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb2xvcnNfO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZmV3IGF0dHJpYnV0ZXMgb2YgYSBzZXJpZXMsIGkuZS4gaXRzIGNvbG9yLCBpdHMgdmlzaWJpbGl0eSwgd2hpY2hcbiAqIGF4aXMgaXQncyBhc3NpZ25lZCB0bywgYW5kIGl0cyBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIGRhdGEuXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHNlcmllcyBkb2VzIG5vdCBleGlzdC5cbiAqIE90aGVyd2lzZSwgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb2x1bW4sIHZpc2liaWxpdHksIGNvbG9yIGFuZCBheGlzIHByb3BlcnRpZXMuXG4gKiBUaGUgXCJheGlzXCIgcHJvcGVydHkgd2lsbCBiZSBzZXQgdG8gMSBmb3IgeTEgYW5kIDIgZm9yIHkyLlxuICogVGhlIFwiY29sdW1uXCIgcHJvcGVydHkgY2FuIGJlIGZlZCBiYWNrIGludG8gZ2V0VmFsdWUocm93LCBjb2x1bW4pIHRvIGdldFxuICogdmFsdWVzIGZvciB0aGlzIHNlcmllcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0UHJvcGVydGllc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllc19uYW1lKSB7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxhYmVsc1tpXSA9PSBzZXJpZXNfbmFtZSkge1xuICAgICAgaWR4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaWR4ID09IC0xKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IHNlcmllc19uYW1lLFxuICAgIGNvbHVtbjogaWR4LFxuICAgIHZpc2libGU6IHRoaXMudmlzaWJpbGl0eSgpW2lkeCAtIDFdLFxuICAgIGNvbG9yOiB0aGlzLmNvbG9yc01hcF9bc2VyaWVzX25hbWVdLFxuICAgIGF4aXM6IDEgKyB0aGlzLmF0dHJpYnV0ZXNfLmF4aXNGb3JTZXJpZXMoc2VyaWVzX25hbWUpXG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgdGV4dCBib3ggdG8gYWRqdXN0IHRoZSBhdmVyYWdpbmcgcGVyaW9kXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVSb2xsSW50ZXJmYWNlXyA9IGZ1bmN0aW9uKCkge1xuICAvLyBDcmVhdGUgYSByb2xsZXIgaWYgb25lIGRvZXNuJ3QgZXhpc3QgYWxyZWFkeS5cbiAgdmFyIHJvbGxlciA9IHRoaXMucm9sbGVyXztcbiAgaWYgKCFyb2xsZXIpIHtcbiAgICB0aGlzLnJvbGxlcl8gPSByb2xsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgcm9sbGVyLnR5cGUgPSBcInRleHRcIjtcbiAgICByb2xsZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHJvbGxlci5jbGFzc05hbWUgPSAnZHlncmFwaC1yb2xsZXInO1xuICAgIHRoaXMuZ3JhcGhEaXYuYXBwZW5kQ2hpbGQocm9sbGVyKTtcbiAgfVxuXG4gIHZhciBkaXNwbGF5ID0gdGhpcy5nZXRCb29sZWFuT3B0aW9uKCdzaG93Um9sbGVyJykgPyAnYmxvY2snIDogJ25vbmUnO1xuXG4gIHZhciBhcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gIHZhciB0ZXh0QXR0ciA9IHtcbiAgICAgICAgICAgICAgICAgICBcInRvcFwiOiAoYXJlYS55ICsgYXJlYS5oIC0gMjUpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiAoYXJlYS54ICsgMSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgfTtcbiAgcm9sbGVyLnNpemUgPSBcIjJcIjtcbiAgcm9sbGVyLnZhbHVlID0gdGhpcy5yb2xsUGVyaW9kXztcbiAgdXRpbHMudXBkYXRlKHJvbGxlci5zdHlsZSwgdGV4dEF0dHIpO1xuXG4gIHJvbGxlci5vbmNoYW5nZSA9ICgpID0+IHRoaXMuYWRqdXN0Um9sbChyb2xsZXIudmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXQgdXAgYWxsIHRoZSBtb3VzZSBoYW5kbGVycyBuZWVkZWQgdG8gY2FwdHVyZSBkcmFnZ2luZyBiZWhhdmlvciBmb3Igem9vbVxuICogZXZlbnRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlRHJhZ0ludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGRvd24gcmlnaHQgbm93XG4gICAgaXNab29taW5nOiBmYWxzZSxcbiAgICBpc1Bhbm5pbmc6IGZhbHNlLCAgLy8gaXMgdGhpcyBkcmFnIHBhcnQgb2YgYSBwYW4/XG4gICAgaXMyRFBhbjogZmFsc2UsICAgIC8vIGlmIHNvLCBpcyB0aGF0IHBhbiAxLSBvciAyLWRpbWVuc2lvbmFsP1xuICAgIGRyYWdTdGFydFg6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgZHJhZ1N0YXJ0WTogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRW5kWDogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRW5kWTogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRGlyZWN0aW9uOiBudWxsLFxuICAgIHByZXZFbmRYOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIHByZXZFbmRZOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIHByZXZEcmFnRGlyZWN0aW9uOiBudWxsLFxuICAgIGNhbmNlbE5leHREYmxjbGljazogZmFsc2UsICAvLyBzZWUgY29tbWVudCBpbiBkeWdyYXBoLWludGVyYWN0aW9uLW1vZGVsLmpzXG5cbiAgICAvLyBUaGUgdmFsdWUgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZ3JhcGggd2hlbiBhIHBhbiBvcGVyYXRpb24gc3RhcnRzLlxuICAgIGluaXRpYWxMZWZ0bW9zdERhdGU6IG51bGwsXG5cbiAgICAvLyBUaGUgbnVtYmVyIG9mIHVuaXRzIGVhY2ggcGl4ZWwgc3BhbnMuIChUaGlzIHdvbid0IGJlIHZhbGlkIGZvciBsb2dcbiAgICAvLyBzY2FsZXMpXG4gICAgeFVuaXRzUGVyUGl4ZWw6IG51bGwsXG5cbiAgICAvLyBUT0RPKGRhbnZrKTogdXBkYXRlIHRoaXMgY29tbWVudFxuICAgIC8vIFRoZSByYW5nZSBpbiBzZWNvbmQvdmFsdWUgdW5pdHMgdGhhdCB0aGUgdmlld3BvcnQgZW5jb21wYXNzZXMgZHVyaW5nIGFcbiAgICAvLyBwYW5uaW5nIG9wZXJhdGlvbi5cbiAgICBkYXRlUmFuZ2U6IG51bGwsXG5cbiAgICAvLyBUb3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcywgaW4gRE9NIGNvb3Jkc1xuICAgIC8vIFRPRE8oa29uaWdzYmVyZyk6IFJlbmFtZSB0b3BMZWZ0Q2FudmFzWCwgdG9wTGVmdENhbnZhc1kuXG4gICAgcHg6IDAsXG4gICAgcHk6IDAsXG5cbiAgICAvLyBWYWx1ZXMgZm9yIHVzZSB3aXRoIHBhbkVkZ2VGcmFjdGlvbiwgd2hpY2ggbGltaXQgaG93IGZhciBvdXRzaWRlIHRoZVxuICAgIC8vIGdyYXBoJ3MgZGF0YSBib3VuZGFyaWVzIGl0IGNhbiBiZSBwYW5uZWQuXG4gICAgYm91bmRlZERhdGVzOiBudWxsLCAvLyBbbWluRGF0ZSwgbWF4RGF0ZV1cbiAgICBib3VuZGVkVmFsdWVzOiBudWxsLCAvLyBbW21pblZhbHVlLCBtYXhWYWx1ZV0gLi4uXVxuXG4gICAgLy8gV2UgY292ZXIgaWZyYW1lcyBkdXJpbmcgbW91c2UgaW50ZXJhY3Rpb25zLiBTZWUgY29tbWVudHMgaW5cbiAgICAvLyBkeWdyYXBoLXV0aWxzLmpzIGZvciBtb3JlIGluZm8gb24gd2h5IHRoaXMgaXMgYSBnb29kIGlkZWEuXG4gICAgdGFycDogbmV3IElGcmFtZVRhcnAoKSxcblxuICAgIC8vIGNvbnRleHRCIGlzIHRoZSBzYW1lIHRoaW5nIGFzIHRoaXMgY29udGV4dCBvYmplY3QgYnV0IHJlbmFtZWQuXG4gICAgaW5pdGlhbGl6ZU1vdXNlRG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHRCKSB7XG4gICAgICAvLyBwcmV2ZW50cyBtb3VzZSBkcmFncyBmcm9tIHNlbGVjdGluZyBwYWdlIHRleHQuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIEZpcmVmb3gsIENocm9tZSwgZXRjLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTsgIC8vIElFXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXNQb3MgPSB1dGlscy5maW5kUG9zKGcuY2FudmFzXyk7XG4gICAgICBjb250ZXh0Qi5weCA9IGNhbnZhc1Bvcy54O1xuICAgICAgY29udGV4dEIucHkgPSBjYW52YXNQb3MueTtcbiAgICAgIGNvbnRleHRCLmRyYWdTdGFydFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHRCKTtcbiAgICAgIGNvbnRleHRCLmRyYWdTdGFydFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHRCKTtcbiAgICAgIGNvbnRleHRCLmNhbmNlbE5leHREYmxjbGljayA9IGZhbHNlO1xuICAgICAgY29udGV4dEIudGFycC5jb3ZlcigpO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcgfHwgY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgICAgY29udGV4dC5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dC5kcmFnU3RhcnRYID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5kcmFnU3RhcnRZID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICAgIGNvbnRleHQuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRleHQuZHJhZ2dpbmdEYXRlID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5kYXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZWxldGUgc2VsZi5heGVzX1tpXS5kcmFnZ2luZ1ZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmF4ZXNfW2ldLmRyYWdWYWx1ZVJhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQudGFycC51bmNvdmVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbnRlcmFjdGlvbk1vZGVsID0gdGhpcy5nZXRPcHRpb24oXCJpbnRlcmFjdGlvbk1vZGVsXCIpO1xuXG4gIC8vIFNlbGYgaXMgdGhlIGdyYXBoLlxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gRnVuY3Rpb24gdGhhdCBiaW5kcyB0aGUgZ3JhcGggYW5kIGNvbnRleHQgdG8gdGhlIGhhbmRsZXIuXG4gIHZhciBiaW5kSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIoZXZlbnQsIHNlbGYsIGNvbnRleHQpO1xuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgZXZlbnROYW1lIGluIGludGVyYWN0aW9uTW9kZWwpIHtcbiAgICBpZiAoIWludGVyYWN0aW9uTW9kZWwuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkgY29udGludWU7XG4gICAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubW91c2VFdmVudEVsZW1lbnRfLCBldmVudE5hbWUsXG4gICAgICAgIGJpbmRIYW5kbGVyKGludGVyYWN0aW9uTW9kZWxbZXZlbnROYW1lXSkpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBkdXJpbmcgYSBkcmFnLCBidXQgbm90IG92ZXIgdGhlXG4gIC8vIGNhbnZhcywgdGhlbiBpdCBkb2Vzbid0IGNvdW50IGFzIGEgem9vbWluZyBhY3Rpb24uXG4gIGlmICghaW50ZXJhY3Rpb25Nb2RlbC53aWxsRGVzdHJveUNvbnRleHRNeXNlbGYpIHtcbiAgICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29udGV4dC5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkQW5kVHJhY2tFdmVudChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gIH1cbn07XG5cbi8qKlxuICogRHJhdyBhIGdyYXkgem9vbSByZWN0YW5nbGUgb3ZlciB0aGUgZGVzaXJlZCBhcmVhIG9mIHRoZSBjYW52YXMuIEFsc28gY2xlYXJzXG4gKiB1cCBhbnkgcHJldmlvdXMgem9vbSByZWN0YW5nbGVzIHRoYXQgd2VyZSBkcmF3bi4gVGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgdG9cbiAqIGF2b2lkIGV4dHJhIHJlZHJhd2luZywgYnV0IGl0J3MgdHJpY2t5IHRvIGF2b2lkIGludGVyYWN0aW9ucyB3aXRoIHRoZSBzdGF0dXNcbiAqIGRvdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSB6b29tIHJlY3RhbmdsZS4gQWNjZXB0YWJsZVxuICogICAgIHZhbHVlcyBhcmUgdXRpbHMuSE9SSVpPTlRBTCBhbmQgdXRpbHMuVkVSVElDQUwuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRYIFRoZSBYIHBvc2l0aW9uIHdoZXJlIHRoZSBkcmFnIHN0YXJ0ZWQsIGluIGNhbnZhc1xuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFggVGhlIGN1cnJlbnQgWCBwb3NpdGlvbiBvZiB0aGUgZHJhZywgaW4gY2FudmFzIGNvb3Jkcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFkgVGhlIFkgcG9zaXRpb24gd2hlcmUgdGhlIGRyYWcgc3RhcnRlZCwgaW4gY2FudmFzXG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWSBUaGUgY3VycmVudCBZIHBvc2l0aW9uIG9mIHRoZSBkcmFnLCBpbiBjYW52YXMgY29vcmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHByZXZEaXJlY3Rpb24gdGhlIHZhbHVlIG9mIGRpcmVjdGlvbiBvbiB0aGUgcHJldmlvdXMgY2FsbCB0b1xuICogICAgIHRoaXMgZnVuY3Rpb24uIFVzZWQgdG8gYXZvaWQgZXhjZXNzIHJlZHJhd2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHByZXZFbmRYIFRoZSB2YWx1ZSBvZiBlbmRYIG9uIHRoZSBwcmV2aW91cyBjYWxsIHRvIHRoaXNcbiAqICAgICBmdW5jdGlvbi4gVXNlZCB0byBhdm9pZCBleGNlc3MgcmVkcmF3aW5nXG4gKiBAcGFyYW0ge251bWJlcn0gcHJldkVuZFkgVGhlIHZhbHVlIG9mIGVuZFkgb24gdGhlIHByZXZpb3VzIGNhbGwgdG8gdGhpc1xuICogICAgIGZ1bmN0aW9uLiBVc2VkIHRvIGF2b2lkIGV4Y2VzcyByZWRyYXdpbmdcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRyYXdab29tUmVjdF8gPSBmdW5jdGlvbihkaXJlY3Rpb24sIHN0YXJ0WCwgZW5kWCwgc3RhcnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFksIHByZXZEaXJlY3Rpb24sIHByZXZFbmRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZFbmRZKSB7XG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc19jdHhfO1xuXG4gIC8vIENsZWFuIHVwIGZyb20gdGhlIHByZXZpb3VzIHJlY3QgaWYgbmVjZXNzYXJ5XG4gIGlmIChwcmV2RGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICBjdHguY2xlYXJSZWN0KE1hdGgubWluKHN0YXJ0WCwgcHJldkVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS55LFxuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoc3RhcnRYIC0gcHJldkVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS5oKTtcbiAgfSBlbHNlIGlmIChwcmV2RGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgY3R4LmNsZWFyUmVjdCh0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS54LCBNYXRoLm1pbihzdGFydFksIHByZXZFbmRZKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLncsIE1hdGguYWJzKHN0YXJ0WSAtIHByZXZFbmRZKSk7XG4gIH1cblxuICAvLyBEcmF3IGEgbGlnaHQtZ3JleSByZWN0YW5nbGUgdG8gc2hvdyB0aGUgbmV3IHZpZXdpbmcgYXJlYVxuICBpZiAoZGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICBpZiAoZW5kWCAmJiBzdGFydFgpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTI4LDEyOCwxMjgsMC4zMylcIjtcbiAgICAgIGN0eC5maWxsUmVjdChNYXRoLm1pbihzdGFydFgsIGVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS55LFxuICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGVuZFggLSBzdGFydFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS5oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgaWYgKGVuZFkgJiYgc3RhcnRZKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDEyOCwxMjgsMTI4LDAuMzMpXCI7XG4gICAgICBjdHguZmlsbFJlY3QodGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkueCwgTWF0aC5taW4oc3RhcnRZLCBlbmRZKSxcbiAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS53LCBNYXRoLmFicyhlbmRZIC0gc3RhcnRZKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB6b29tIHJlY3RhbmdsZSAoYW5kIHBlcmZvcm0gbm8gem9vbSkuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jbGVhclpvb21SZWN0XyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRab29tUmVjdEFyZ3NfID0gbnVsbDtcbiAgdGhpcy5jYW52YXNfY3R4Xy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG59O1xuXG4vKipcbiAqIFpvb20gdG8gc29tZXRoaW5nIGNvbnRhaW5pbmcgW2xvd1gsIGhpZ2hYXS4gVGhlc2UgYXJlIHBpeGVsIGNvb3JkaW5hdGVzIGluXG4gKiB0aGUgY2FudmFzLiBUaGUgZXhhY3Qgem9vbSB3aW5kb3cgbWF5IGJlIHNsaWdodGx5IGxhcmdlciBpZiB0aGVyZSBhcmUgbm8gZGF0YVxuICogcG9pbnRzIG5lYXIgbG93WCBvciBoaWdoWC4gRG9uJ3QgY29uZnVzZSB0aGlzIGZ1bmN0aW9uIHdpdGggZG9ab29tWERhdGVzLFxuICogd2hpY2ggYWNjZXB0cyBkYXRlcyB0aGF0IG1hdGNoIHRoZSByYXcgZGF0YS4gVGhpcyBmdW5jdGlvbiByZWRyYXdzIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93WCBUaGUgbGVmdG1vc3QgcGl4ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoWCBUaGUgcmlnaHRtb3N0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb1pvb21YXyA9IGZ1bmN0aW9uKGxvd1gsIGhpZ2hYKSB7XG4gIHRoaXMuY3VycmVudFpvb21SZWN0QXJnc18gPSBudWxsO1xuICAvLyBGaW5kIHRoZSBlYXJsaWVzdCBhbmQgbGF0ZXN0IGRhdGVzIGNvbnRhaW5lZCBpbiB0aGlzIGNhbnZhc3ggcmFuZ2UuXG4gIC8vIENvbnZlcnQgdGhlIGNhbGwgdG8gZGF0ZSByYW5nZXMgb2YgdGhlIHJhdyBkYXRhLlxuICB2YXIgbWluRGF0ZSA9IHRoaXMudG9EYXRhWENvb3JkKGxvd1gpO1xuICB2YXIgbWF4RGF0ZSA9IHRoaXMudG9EYXRhWENvb3JkKGhpZ2hYKTtcbiAgdGhpcy5kb1pvb21YRGF0ZXNfKG1pbkRhdGUsIG1heERhdGUpO1xufTtcblxuLyoqXG4gKiBab29tIHRvIHNvbWV0aGluZyBjb250YWluaW5nIFttaW5EYXRlLCBtYXhEYXRlXSB2YWx1ZXMuIERvbid0IGNvbmZ1c2UgdGhpc1xuICogbWV0aG9kIHdpdGggZG9ab29tWCB3aGljaCBhY2NlcHRzIHBpeGVsIGNvb3JkaW5hdGVzLiBUaGlzIGZ1bmN0aW9uIHJlZHJhd3NcbiAqIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluRGF0ZSBUaGUgbWluaW11bSBkYXRlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGF0ZSBUaGUgbWF4aW11bSBkYXRlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb1pvb21YRGF0ZXNfID0gZnVuY3Rpb24obWluRGF0ZSwgbWF4RGF0ZSkge1xuICAvLyBUT0RPKGRhbnZrKTogd2hlbiB4QXhpc1JhbmdlIGlzIG51bGwgKGkuZS4gXCJmaXQgdG8gZGF0YVwiLCB0aGUgYW5pbWF0aW9uXG4gIC8vIGNhbiBwcm9kdWNlIHN0cmFuZ2UgZWZmZWN0cy4gUmF0aGVyIHRoYW4gdGhlIHgtYXhpcyB0cmFuc2l0aW9uaW5nIHNsb3dseVxuICAvLyBiZXR3ZWVuIHZhbHVlcywgaXQgY2FuIGplcmsgYXJvdW5kLilcbiAgdmFyIG9sZF93aW5kb3cgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIG5ld193aW5kb3cgPSBbbWluRGF0ZSwgbWF4RGF0ZV07XG4gIGNvbnN0IHpvb21DYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oJ3pvb21DYWxsYmFjaycpO1xuICB0aGlzLmRvQW5pbWF0ZWRab29tKG9sZF93aW5kb3csIG5ld193aW5kb3csIG51bGwsIG51bGwsICgpID0+IHtcbiAgICBpZiAoem9vbUNhbGxiYWNrKSB7XG4gICAgICB6b29tQ2FsbGJhY2suY2FsbCh0aGlzLCBtaW5EYXRlLCBtYXhEYXRlLCB0aGlzLnlBeGlzUmFuZ2VzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFpvb20gdG8gc29tZXRoaW5nIGNvbnRhaW5pbmcgW2xvd1ksIGhpZ2hZXS4gVGhlc2UgYXJlIHBpeGVsIGNvb3JkaW5hdGVzIGluXG4gKiB0aGUgY2FudmFzLiBUaGlzIGZ1bmN0aW9uIHJlZHJhd3MgdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dZIFRoZSB0b3Btb3N0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFkgVGhlIGxvd2VzdCBwaXhlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZG9ab29tWV8gPSBmdW5jdGlvbihsb3dZLCBoaWdoWSkge1xuICB0aGlzLmN1cnJlbnRab29tUmVjdEFyZ3NfID0gbnVsbDtcbiAgLy8gRmluZCB0aGUgaGlnaGVzdCBhbmQgbG93ZXN0IHZhbHVlcyBpbiBwaXhlbCByYW5nZSBmb3IgZWFjaCBheGlzLlxuICAvLyBOb3RlIHRoYXQgbG93WSAoaW4gcGl4ZWxzKSBjb3JyZXNwb25kcyB0byB0aGUgbWF4IFZhbHVlIChpbiBkYXRhIGNvb3JkcykuXG4gIC8vIFRoaXMgaXMgYmVjYXVzZSBwaXhlbHMgaW5jcmVhc2UgYXMgeW91IGdvIGRvd24gb24gdGhlIHNjcmVlbiwgd2hlcmVhcyBkYXRhXG4gIC8vIGNvb3JkaW5hdGVzIGluY3JlYXNlIGFzIHlvdSBnbyB1cCB0aGUgc2NyZWVuLlxuICB2YXIgb2xkVmFsdWVSYW5nZXMgPSB0aGlzLnlBeGlzUmFuZ2VzKCk7XG4gIHZhciBuZXdWYWx1ZVJhbmdlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaGkgPSB0aGlzLnRvRGF0YVlDb29yZChsb3dZLCBpKTtcbiAgICB2YXIgbG93ID0gdGhpcy50b0RhdGFZQ29vcmQoaGlnaFksIGkpO1xuICAgIG5ld1ZhbHVlUmFuZ2VzLnB1c2goW2xvdywgaGldKTtcbiAgfVxuXG4gIGNvbnN0IHpvb21DYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oJ3pvb21DYWxsYmFjaycpO1xuICB0aGlzLmRvQW5pbWF0ZWRab29tKG51bGwsIG51bGwsIG9sZFZhbHVlUmFuZ2VzLCBuZXdWYWx1ZVJhbmdlcywgKCkgPT4ge1xuICAgIGlmICh6b29tQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IFttaW5YLCBtYXhYXSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICAgICAgem9vbUNhbGxiYWNrLmNhbGwodGhpcywgbWluWCwgbWF4WCwgdGhpcy55QXhpc1JhbmdlcygpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uIGZ1bmN0aW9uIHRvIHVzZSBpbiBhbmltYXRpb25zLiBSZXR1cm5zIHZhbHVlcyBiZXR3ZWVuIDAuMFxuICogKHRvdGFsbHkgb2xkIHZhbHVlcykgYW5kIDEuMCAodG90YWxseSBuZXcgdmFsdWVzKSBmb3IgZWFjaCBmcmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGguem9vbUFuaW1hdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24oZnJhbWUsIG51bUZyYW1lcykge1xuICB2YXIgayA9IDEuNTtcbiAgcmV0dXJuICgxLjAgLSBNYXRoLnBvdyhrLCAtZnJhbWUpKSAvICgxLjAgLSBNYXRoLnBvdyhrLCAtbnVtRnJhbWVzKSk7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSB6b29tIHRvIHRoZSBvcmlnaW5hbCB2aWV3IGNvb3JkaW5hdGVzLiBUaGlzIGlzIHRoZSBzYW1lIGFzXG4gKiBkb3VibGUtY2xpY2tpbmcgb24gdGhlIGdyYXBoLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5yZXNldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZGlydHlYID0gdGhpcy5pc1pvb21lZCgneCcpO1xuICBjb25zdCBkaXJ0eVkgPSB0aGlzLmlzWm9vbWVkKCd5Jyk7XG4gIGNvbnN0IGRpcnR5ID0gZGlydHlYIHx8IGRpcnR5WTtcblxuICAvLyBDbGVhciBhbnkgc2VsZWN0aW9uLCBzaW5jZSBpdCdzIGxpa2VseSB0byBiZSBkcmF3biBpbiB0aGUgd3JvbmcgcGxhY2UuXG4gIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICBpZiAoIWRpcnR5KSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIGV4dHJlbWVzIHRvIGF2b2lkIGxhY2sgb2YgcGFkZGluZyBvbiByZXNldC5cbiAgY29uc3QgW21pbkRhdGUsIG1heERhdGVdID0gdGhpcy54QXhpc0V4dHJlbWVzKCk7XG5cbiAgY29uc3QgYW5pbWF0ZWRab29tcyA9IHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignYW5pbWF0ZWRab29tcycpO1xuICBjb25zdCB6b29tQ2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKCd6b29tQ2FsbGJhY2snKTtcblxuICAvLyBUT0RPKGRhbnZrKTogbWVyZ2UgdGhpcyBibG9jayB3LyB0aGUgY29kZSBiZWxvdy5cbiAgLy8gVE9ETyhkYW52ayk6IGZhY3RvciBvdXQgYSBnZW5lcmljLCBwdWJsaWMgem9vbVRvIG1ldGhvZC5cbiAgaWYgKCFhbmltYXRlZFpvb21zKSB7XG4gICAgdGhpcy5kYXRlV2luZG93XyA9IG51bGw7XG4gICAgdGhpcy5heGVzXy5mb3JFYWNoKGF4aXMgPT4ge1xuICAgICAgaWYgKGF4aXMudmFsdWVSYW5nZSkgZGVsZXRlIGF4aXMudmFsdWVSYW5nZTtcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhd0dyYXBoXygpO1xuICAgIGlmICh6b29tQ2FsbGJhY2spIHtcbiAgICAgIHpvb21DYWxsYmFjay5jYWxsKHRoaXMsIG1pbkRhdGUsIG1heERhdGUsIHRoaXMueUF4aXNSYW5nZXMoKSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvbGRXaW5kb3c9bnVsbCwgbmV3V2luZG93PW51bGwsIG9sZFZhbHVlUmFuZ2VzPW51bGwsIG5ld1ZhbHVlUmFuZ2VzPW51bGw7XG4gIGlmIChkaXJ0eVgpIHtcbiAgICBvbGRXaW5kb3cgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgICBuZXdXaW5kb3cgPSBbbWluRGF0ZSwgbWF4RGF0ZV07XG4gIH1cblxuICBpZiAoZGlydHlZKSB7XG4gICAgb2xkVmFsdWVSYW5nZXMgPSB0aGlzLnlBeGlzUmFuZ2VzKCk7XG4gICAgbmV3VmFsdWVSYW5nZXMgPSB0aGlzLnlBeGlzRXh0cmVtZXMoKTtcbiAgfVxuXG4gIHRoaXMuZG9BbmltYXRlZFpvb20ob2xkV2luZG93LCBuZXdXaW5kb3csIG9sZFZhbHVlUmFuZ2VzLCBuZXdWYWx1ZVJhbmdlcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5kYXRlV2luZG93XyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXhlc18uZm9yRWFjaChheGlzID0+IHtcbiAgICAgICAgICBpZiAoYXhpcy52YWx1ZVJhbmdlKSBkZWxldGUgYXhpcy52YWx1ZVJhbmdlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHpvb21DYWxsYmFjaykge1xuICAgICAgICAgIHpvb21DYWxsYmFjay5jYWxsKHRoaXMsIG1pbkRhdGUsIG1heERhdGUsIHRoaXMueUF4aXNSYW5nZXMoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBDb21iaW5lZCBhbmltYXRpb24gbG9naWMgZm9yIGFsbCB6b29tIGZ1bmN0aW9ucy5cbiAqIGVpdGhlciB0aGUgeCBwYXJhbWV0ZXJzIG9yIHkgcGFyYW1ldGVycyBtYXkgYmUgbnVsbC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRvQW5pbWF0ZWRab29tID0gZnVuY3Rpb24ob2xkWFJhbmdlLCBuZXdYUmFuZ2UsIG9sZFlSYW5nZXMsIG5ld1lSYW5nZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGVwcyA9IHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImFuaW1hdGVkWm9vbXNcIikgP1xuICAgICAgRHlncmFwaC5BTklNQVRJT05fU1RFUFMgOiAxO1xuXG4gIHZhciB3aW5kb3dzID0gW107XG4gIHZhciB2YWx1ZVJhbmdlcyA9IFtdO1xuICB2YXIgc3RlcCwgZnJhYztcblxuICBpZiAob2xkWFJhbmdlICE9PSBudWxsICYmIG5ld1hSYW5nZSAhPT0gbnVsbCkge1xuICAgIGZvciAoc3RlcCA9IDE7IHN0ZXAgPD0gc3RlcHM7IHN0ZXArKykge1xuICAgICAgZnJhYyA9IER5Z3JhcGguem9vbUFuaW1hdGlvbkZ1bmN0aW9uKHN0ZXAsIHN0ZXBzKTtcbiAgICAgIHdpbmRvd3Nbc3RlcC0xXSA9IFtvbGRYUmFuZ2VbMF0qKDEtZnJhYykgKyBmcmFjKm5ld1hSYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbGRYUmFuZ2VbMV0qKDEtZnJhYykgKyBmcmFjKm5ld1hSYW5nZVsxXV07XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZFlSYW5nZXMgIT09IG51bGwgJiYgbmV3WVJhbmdlcyAhPT0gbnVsbCkge1xuICAgIGZvciAoc3RlcCA9IDE7IHN0ZXAgPD0gc3RlcHM7IHN0ZXArKykge1xuICAgICAgZnJhYyA9IER5Z3JhcGguem9vbUFuaW1hdGlvbkZ1bmN0aW9uKHN0ZXAsIHN0ZXBzKTtcbiAgICAgIHZhciB0aGlzUmFuZ2UgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5heGVzXy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzUmFuZ2UucHVzaChbb2xkWVJhbmdlc1tqXVswXSooMS1mcmFjKSArIGZyYWMqbmV3WVJhbmdlc1tqXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFlSYW5nZXNbal1bMV0qKDEtZnJhYykgKyBmcmFjKm5ld1lSYW5nZXNbal1bMV1dKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlUmFuZ2VzW3N0ZXAtMV0gPSB0aGlzUmFuZ2U7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMucmVwZWF0QW5kQ2xlYW51cChzdGVwID0+IHtcbiAgICBpZiAodmFsdWVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB2YWx1ZVJhbmdlc1tzdGVwXVtpXTtcbiAgICAgICAgdGhpcy5heGVzX1tpXS52YWx1ZVJhbmdlID0gW3dbMF0sIHdbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2luZG93cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZGF0ZVdpbmRvd18gPSB3aW5kb3dzW3N0ZXBdO1xuICAgIH1cbiAgICB0aGlzLmRyYXdHcmFwaF8oKTtcbiAgfSwgc3RlcHMsIER5Z3JhcGguQU5JTUFUSU9OX0RVUkFUSU9OIC8gc3RlcHMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGdyYXBoJ3MgYXJlYSBvYmplY3QuXG4gKlxuICogUmV0dXJuczoge3gsIHksIHcsIGh9XG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGxvdHRlcl8uYXJlYTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIG1vdXNlIGV2ZW50IHRvIERPTSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgZ3JhcGggb3JpZ2luLlxuICpcbiAqIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheTogW1gsIFldLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5ldmVudFRvRG9tQ29vcmRzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKGV2ZW50Lm9mZnNldFggJiYgZXZlbnQub2Zmc2V0WSkge1xuICAgIHJldHVybiBbIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkgXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXZlbnRFbGVtZW50UG9zID0gdXRpbHMuZmluZFBvcyh0aGlzLm1vdXNlRXZlbnRFbGVtZW50Xyk7XG4gICAgdmFyIGNhbnZhc3ggPSB1dGlscy5wYWdlWChldmVudCkgLSBldmVudEVsZW1lbnRQb3MueDtcbiAgICB2YXIgY2FudmFzeSA9IHV0aWxzLnBhZ2VZKGV2ZW50KSAtIGV2ZW50RWxlbWVudFBvcy55O1xuICAgIHJldHVybiBbY2FudmFzeCwgY2FudmFzeV07XG4gIH1cbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjYW52YXMgWCBjb29yZGluYXRlLCBmaW5kIHRoZSBjbG9zZXN0IHJvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21YIGdyYXBoLXJlbGF0aXZlIERPTSBYIGNvb3JkaW5hdGVcbiAqIFJldHVybnMge251bWJlcn0gcm93IG51bWJlci5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmZpbmRDbG9zZXN0Um93ID0gZnVuY3Rpb24oZG9tWCkge1xuICB2YXIgbWluRGlzdFggPSBJbmZpbml0eTtcbiAgdmFyIGNsb3Nlc3RSb3cgPSAtMTtcbiAgdmFyIHNldHMgPSB0aGlzLmxheW91dF8ucG9pbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcG9pbnRzID0gc2V0c1tpXTtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG4gICAgICBpZiAoIXV0aWxzLmlzVmFsaWRQb2ludChwb2ludCwgdHJ1ZSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhwb2ludC5jYW52YXN4IC0gZG9tWCk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3RYKSB7XG4gICAgICAgIG1pbkRpc3RYID0gZGlzdDtcbiAgICAgICAgY2xvc2VzdFJvdyA9IHBvaW50LmlkeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFJvdztcbn07XG5cbi8qKlxuICogR2l2ZW4gY2FudmFzIFgsWSBjb29yZGluYXRlcywgZmluZCB0aGUgY2xvc2VzdCBwb2ludC5cbiAqXG4gKiBUaGlzIGZpbmRzIHRoZSBpbmRpdmlkdWFsIGRhdGEgcG9pbnQgYWNyb3NzIGFsbCB2aXNpYmxlIHNlcmllc1xuICogdGhhdCdzIGNsb3Nlc3QgdG8gdGhlIHN1cHBsaWVkIERPTSBjb29yZGluYXRlcyB1c2luZyB0aGUgc3RhbmRhcmRcbiAqIEV1Y2xpZGVhbiBYLFkgZGlzdGFuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRvbVggZ3JhcGgtcmVsYXRpdmUgRE9NIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRvbVkgZ3JhcGgtcmVsYXRpdmUgRE9NIFkgY29vcmRpbmF0ZVxuICogUmV0dXJuczoge3Jvdywgc2VyaWVzTmFtZSwgcG9pbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5maW5kQ2xvc2VzdFBvaW50ID0gZnVuY3Rpb24oZG9tWCwgZG9tWSkge1xuICB2YXIgbWluRGlzdCA9IEluZmluaXR5O1xuICB2YXIgZGlzdCwgZHgsIGR5LCBwb2ludCwgY2xvc2VzdFBvaW50LCBjbG9zZXN0U2VyaWVzLCBjbG9zZXN0Um93O1xuICBmb3IgKCB2YXIgc2V0SWR4ID0gdGhpcy5sYXlvdXRfLnBvaW50cy5sZW5ndGggLSAxIDsgc2V0SWR4ID49IDAgOyAtLXNldElkeCApIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50c1tzZXRJZHhdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGlmICghdXRpbHMuaXNWYWxpZFBvaW50KHBvaW50KSkgY29udGludWU7XG4gICAgICBkeCA9IHBvaW50LmNhbnZhc3ggLSBkb21YO1xuICAgICAgZHkgPSBwb2ludC5jYW52YXN5IC0gZG9tWTtcbiAgICAgIGRpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgY2xvc2VzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsb3Nlc3RTZXJpZXMgPSBzZXRJZHg7XG4gICAgICAgIGNsb3Nlc3RSb3cgPSBwb2ludC5pZHg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBuYW1lID0gdGhpcy5sYXlvdXRfLnNldE5hbWVzW2Nsb3Nlc3RTZXJpZXNdO1xuICByZXR1cm4ge1xuICAgIHJvdzogY2xvc2VzdFJvdyxcbiAgICBzZXJpZXNOYW1lOiBuYW1lLFxuICAgIHBvaW50OiBjbG9zZXN0UG9pbnRcbiAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gY2FudmFzIFgsWSBjb29yZGluYXRlcywgZmluZCB0aGUgdG91Y2hlZCBhcmVhIGluIGEgc3RhY2tlZCBncmFwaC5cbiAqXG4gKiBUaGlzIGZpcnN0IGZpbmRzIHRoZSBYIGRhdGEgcG9pbnQgY2xvc2VzdCB0byB0aGUgc3VwcGxpZWQgRE9NIFggY29vcmRpbmF0ZSxcbiAqIHRoZW4gZmluZHMgdGhlIHNlcmllcyB3aGljaCBwdXRzIHRoZSBZIGNvb3JkaW5hdGUgb24gdG9wIG9mIGl0cyBmaWxsZWQgYXJlYSxcbiAqIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYWRqYWNlbnQgcG9pbnQgcGFpcnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRvbVggZ3JhcGgtcmVsYXRpdmUgRE9NIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRvbVkgZ3JhcGgtcmVsYXRpdmUgRE9NIFkgY29vcmRpbmF0ZVxuICogUmV0dXJuczoge3Jvdywgc2VyaWVzTmFtZSwgcG9pbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5maW5kU3RhY2tlZFBvaW50ID0gZnVuY3Rpb24oZG9tWCwgZG9tWSkge1xuICB2YXIgcm93ID0gdGhpcy5maW5kQ2xvc2VzdFJvdyhkb21YKTtcbiAgdmFyIGNsb3Nlc3RQb2ludCwgY2xvc2VzdFNlcmllcztcbiAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgdGhpcy5sYXlvdXRfLnBvaW50cy5sZW5ndGg7ICsrc2V0SWR4KSB7XG4gICAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRMZWZ0Qm91bmRhcnlfKHNldElkeCk7XG4gICAgdmFyIHJvd0lkeCA9IHJvdyAtIGJvdW5kYXJ5O1xuICAgIHZhciBwb2ludHMgPSB0aGlzLmxheW91dF8ucG9pbnRzW3NldElkeF07XG4gICAgaWYgKHJvd0lkeCA+PSBwb2ludHMubGVuZ3RoKSBjb250aW51ZTtcbiAgICB2YXIgcDEgPSBwb2ludHNbcm93SWR4XTtcbiAgICBpZiAoIXV0aWxzLmlzVmFsaWRQb2ludChwMSkpIGNvbnRpbnVlO1xuICAgIHZhciBweSA9IHAxLmNhbnZhc3k7XG4gICAgaWYgKGRvbVggPiBwMS5jYW52YXN4ICYmIHJvd0lkeCArIDEgPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAvLyBpbnRlcnBvbGF0ZSBzZXJpZXMgWSB2YWx1ZSB1c2luZyBuZXh0IHBvaW50XG4gICAgICB2YXIgcDIgPSBwb2ludHNbcm93SWR4ICsgMV07XG4gICAgICBpZiAodXRpbHMuaXNWYWxpZFBvaW50KHAyKSkge1xuICAgICAgICB2YXIgZHggPSBwMi5jYW52YXN4IC0gcDEuY2FudmFzeDtcbiAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgIHZhciByID0gKGRvbVggLSBwMS5jYW52YXN4KSAvIGR4O1xuICAgICAgICAgIHB5ICs9IHIgKiAocDIuY2FudmFzeSAtIHAxLmNhbnZhc3kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb21YIDwgcDEuY2FudmFzeCAmJiByb3dJZHggPiAwKSB7XG4gICAgICAvLyBpbnRlcnBvbGF0ZSBzZXJpZXMgWSB2YWx1ZSB1c2luZyBwcmV2aW91cyBwb2ludFxuICAgICAgdmFyIHAwID0gcG9pbnRzW3Jvd0lkeCAtIDFdO1xuICAgICAgaWYgKHV0aWxzLmlzVmFsaWRQb2ludChwMCkpIHtcbiAgICAgICAgdmFyIGR4ID0gcDEuY2FudmFzeCAtIHAwLmNhbnZhc3g7XG4gICAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgICB2YXIgciA9IChwMS5jYW52YXN4IC0gZG9tWCkgLyBkeDtcbiAgICAgICAgICBweSArPSByICogKHAwLmNhbnZhc3kgLSBwMS5jYW52YXN5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdG9wIGlmIHRoZSBwb2ludCAoZG9tWCwgcHkpIGlzIGFib3ZlIHRoaXMgc2VyaWVzJyB1cHBlciBlZGdlXG4gICAgaWYgKHNldElkeCA9PT0gMCB8fCBweSA8IGRvbVkpIHtcbiAgICAgIGNsb3Nlc3RQb2ludCA9IHAxO1xuICAgICAgY2xvc2VzdFNlcmllcyA9IHNldElkeDtcbiAgICB9XG4gIH1cbiAgdmFyIG5hbWUgPSB0aGlzLmxheW91dF8uc2V0TmFtZXNbY2xvc2VzdFNlcmllc107XG4gIHJldHVybiB7XG4gICAgcm93OiByb3csXG4gICAgc2VyaWVzTmFtZTogbmFtZSxcbiAgICBwb2ludDogY2xvc2VzdFBvaW50XG4gIH07XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIG1vdXNlIG1vdmVzIGluIHRoZSBjYW52YXMsIGRpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgYSBuZWFyYnkgZGF0YVxuICogcG9pbnQgYW5kIGRyYXcgZG90cyBvdmVyIHRob3NlIHBvaW50cyBpbiB0aGUgZGF0YSBzZXJpZXMuIFRoaXMgZnVuY3Rpb25cbiAqIHRha2VzIGNhcmUgb2YgY2xlYW51cCBvZiBwcmV2aW91c2x5LWRyYXduIGRvdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIG1vdXNlbW92ZSBldmVudCBmcm9tIHRoZSBicm93c2VyLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubW91c2VNb3ZlXyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIC8vIFRoaXMgcHJldmVudHMgSlMgZXJyb3JzIHdoZW4gbW91c2luZyBvdmVyIHRoZSBjYW52YXMgYmVmb3JlIGRhdGEgbG9hZHMuXG4gIHZhciBwb2ludHMgPSB0aGlzLmxheW91dF8ucG9pbnRzO1xuICBpZiAocG9pbnRzID09PSB1bmRlZmluZWQgfHwgcG9pbnRzID09PSBudWxsKSByZXR1cm47XG5cbiAgdmFyIGNhbnZhc0Nvb3JkcyA9IHRoaXMuZXZlbnRUb0RvbUNvb3JkcyhldmVudCk7XG4gIHZhciBjYW52YXN4ID0gY2FudmFzQ29vcmRzWzBdO1xuICB2YXIgY2FudmFzeSA9IGNhbnZhc0Nvb3Jkc1sxXTtcblxuICB2YXIgaGlnaGxpZ2h0U2VyaWVzT3B0cyA9IHRoaXMuZ2V0T3B0aW9uKFwiaGlnaGxpZ2h0U2VyaWVzT3B0c1wiKTtcbiAgdmFyIHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKGhpZ2hsaWdodFNlcmllc09wdHMgJiYgIXRoaXMuaXNTZXJpZXNMb2NrZWQoKSkge1xuICAgIHZhciBjbG9zZXN0O1xuICAgIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJzdGFja2VkR3JhcGhcIikpIHtcbiAgICAgIGNsb3Nlc3QgPSB0aGlzLmZpbmRTdGFja2VkUG9pbnQoY2FudmFzeCwgY2FudmFzeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3Nlc3QgPSB0aGlzLmZpbmRDbG9zZXN0UG9pbnQoY2FudmFzeCwgY2FudmFzeSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0aGlzLnNldFNlbGVjdGlvbihjbG9zZXN0LnJvdywgY2xvc2VzdC5zZXJpZXNOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5maW5kQ2xvc2VzdFJvdyhjYW52YXN4KTtcbiAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdGhpcy5zZXRTZWxlY3Rpb24oaWR4KTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJoaWdobGlnaHRDYWxsYmFja1wiKTtcbiAgaWYgKGNhbGxiYWNrICYmIHNlbGVjdGlvbkNoYW5nZWQpIHtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50LFxuICAgICAgICB0aGlzLmxhc3R4XyxcbiAgICAgICAgdGhpcy5zZWxQb2ludHNfLFxuICAgICAgICB0aGlzLmxhc3RSb3dfLFxuICAgICAgICB0aGlzLmhpZ2hsaWdodFNldF8pO1xuICB9XG59O1xuXG4vKipcbiAqIEZldGNoIGxlZnQgb2Zmc2V0IGZyb20gdGhlIHNwZWNpZmllZCBzZXQgaW5kZXggb3IgaWYgbm90IHBhc3NlZCwgdGhlXG4gKiBmaXJzdCBkZWZpbmVkIGJvdW5kYXJ5SWRzIHJlY29yZCAoc2VlIGJ1ZyAjMjM2KS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldExlZnRCb3VuZGFyeV8gPSBmdW5jdGlvbihzZXRJZHgpIHtcbiAgaWYgKHRoaXMuYm91bmRhcnlJZHNfW3NldElkeF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5SWRzX1tzZXRJZHhdWzBdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3VuZGFyeUlkc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kYXJ5SWRzX1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5SWRzX1tpXVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLmFuaW1hdGVTZWxlY3Rpb25fID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHZhciB0b3RhbFN0ZXBzID0gMTA7XG4gIHZhciBtaWxsaXMgPSAzMDtcbiAgaWYgKHRoaXMuZmFkZUxldmVsID09PSB1bmRlZmluZWQpIHRoaXMuZmFkZUxldmVsID0gMDtcbiAgaWYgKHRoaXMuYW5pbWF0ZUlkID09PSB1bmRlZmluZWQpIHRoaXMuYW5pbWF0ZUlkID0gMDtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5mYWRlTGV2ZWw7XG4gIHZhciBzdGVwcyA9IGRpcmVjdGlvbiA8IDAgPyBzdGFydCA6IHRvdGFsU3RlcHMgLSBzdGFydDtcbiAgaWYgKHN0ZXBzIDw9IDApIHtcbiAgICBpZiAodGhpcy5mYWRlTGV2ZWwpIHtcbiAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uXygxLjApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGhpc0lkID0gKyt0aGlzLmFuaW1hdGVJZDtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgY2xlYW51cElmQ2xlYXJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpZiB3ZSBoYXZlbid0IHJlYWNoZWQgZmFkZUxldmVsIDAgaW4gdGhlIG1heCBmcmFtZSB0aW1lLFxuICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBjbGVhciBoYXBwZW5zIGFuZCBqdXN0IGdvIHRvIDBcbiAgICBpZiAodGhhdC5mYWRlTGV2ZWwgIT09IDAgJiYgZGlyZWN0aW9uIDwgMCkge1xuICAgICAgdGhhdC5mYWRlTGV2ZWwgPSAwO1xuICAgICAgdGhhdC5jbGVhclNlbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgdXRpbHMucmVwZWF0QW5kQ2xlYW51cChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBpZ25vcmUgc2ltdWx0YW5lb3VzIGFuaW1hdGlvbnNcbiAgICAgIGlmICh0aGF0LmFuaW1hdGVJZCAhPSB0aGlzSWQpIHJldHVybjtcblxuICAgICAgdGhhdC5mYWRlTGV2ZWwgKz0gZGlyZWN0aW9uO1xuICAgICAgaWYgKHRoYXQuZmFkZUxldmVsID09PSAwKSB7XG4gICAgICAgIHRoYXQuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQudXBkYXRlU2VsZWN0aW9uXyh0aGF0LmZhZGVMZXZlbCAvIHRvdGFsU3RlcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RlcHMsIG1pbGxpcywgY2xlYW51cElmQ2xlYXJpbmcpO1xufTtcblxuLyoqXG4gKiBEcmF3IGRvdHMgb3ZlciB0aGUgc2VsZWN0aWVkIHBvaW50cyBpbiB0aGUgZGF0YSBzZXJpZXMuIFRoaXMgZnVuY3Rpb25cbiAqIHRha2VzIGNhcmUgb2YgY2xlYW51cCBvZiBwcmV2aW91c2x5LWRyYXduIGRvdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS51cGRhdGVTZWxlY3Rpb25fID0gZnVuY3Rpb24ob3B0X2FuaW1GcmFjdGlvbikge1xuICAvKnZhciBkZWZhdWx0UHJldmVudGVkID0gKi9cbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnc2VsZWN0Jywge1xuICAgIHNlbGVjdGVkUm93OiB0aGlzLmxhc3RSb3dfID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMubGFzdFJvd18sXG4gICAgc2VsZWN0ZWRYOiB0aGlzLmxhc3R4XyA9PT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLmxhc3R4XyxcbiAgICBzZWxlY3RlZFBvaW50czogdGhpcy5zZWxQb2ludHNfXG4gIH0pO1xuICAvLyBUT0RPKGRhbnZrKTogdXNlIGRlZmF1bHRQcmV2ZW50ZWQgaGVyZT9cblxuICAvLyBDbGVhciB0aGUgcHJldmlvdXNseSBkcmF3biB2ZXJ0aWNhbCwgaWYgdGhlcmUgaXMgb25lXG4gIHZhciBpO1xuICB2YXIgY3R4ID0gdGhpcy5jYW52YXNfY3R4XztcbiAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdoaWdobGlnaHRTZXJpZXNPcHRzJykpIHtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGhfLCB0aGlzLmhlaWdodF8pO1xuICAgIHZhciBhbHBoYSA9IDEuMCAtIHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZEFscGhhJyk7XG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHV0aWxzLnRvUkdCXyh0aGlzLmdldE9wdGlvbignaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZENvbG9yJykpO1xuXG4gICAgaWYgKGFscGhhKSB7XG4gICAgICAvLyBBY3RpdmF0aW5nIGJhY2tncm91bmQgZmFkZSBpbmNsdWRlcyBhbiBhbmltYXRpb24gZWZmZWN0IGZvciBhIGdyYWR1YWxcbiAgICAgIC8vIGZhZGUuIFRPRE8oa2xhdXN3KTogbWFrZSB0aGlzIGluZGVwZW5kZW50bHkgY29uZmlndXJhYmxlIGlmIGl0IGNhdXNlc1xuICAgICAgLy8gaXNzdWVzPyBVc2UgYSBzaGFyZWQgcHJlZmVyZW5jZSB0byBjb250cm9sIGFuaW1hdGlvbnM/XG4gICAgICB2YXIgYW5pbWF0ZUJhY2tncm91bmRGYWRlID0gdHJ1ZTtcbiAgICAgIGlmIChhbmltYXRlQmFja2dyb3VuZEZhZGUpIHtcbiAgICAgICAgaWYgKG9wdF9hbmltRnJhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IGFuaW1hdGlvblxuICAgICAgICAgIHRoaXMuYW5pbWF0ZVNlbGVjdGlvbl8oMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFscGhhICo9IG9wdF9hbmltRnJhY3Rpb247XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoJyArIGJhY2tncm91bmRDb2xvci5yICsgJywnICsgYmFja2dyb3VuZENvbG9yLmcgKyAnLCcgKyBiYWNrZ3JvdW5kQ29sb3IuYiArICcsJyArIGFscGhhICsgJyknO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGhfLCB0aGlzLmhlaWdodF8pO1xuICAgIH1cblxuICAgIC8vIFJlZHJhdyBvbmx5IHRoZSBoaWdobGlnaHRlZCBzZXJpZXMgaW4gdGhlIGludGVyYWN0aXZlIGNhbnZhcyAobm90IHRoZVxuICAgIC8vIHN0YXRpYyBwbG90IGNhbnZhcywgd2hpY2ggaXMgd2hlcmUgc2VyaWVzIGFyZSB1c3VhbGx5IGRyYXduKS5cbiAgICB0aGlzLnBsb3R0ZXJfLl9yZW5kZXJMaW5lQ2hhcnQodGhpcy5oaWdobGlnaHRTZXRfLCBjdHgpO1xuICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXNWZXJ0aWNhbFhfID49IDApIHtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIG1heGltdW0gaGlnaGxpZ2h0IGNpcmNsZSBzaXplLlxuICAgIHZhciBtYXhDaXJjbGVTaXplID0gMDtcbiAgICB2YXIgbGFiZWxzID0gdGhpcy5hdHRyXygnbGFiZWxzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHIgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2hpZ2hsaWdodENpcmNsZVNpemUnLCBsYWJlbHNbaV0pO1xuICAgICAgaWYgKHIgPiBtYXhDaXJjbGVTaXplKSBtYXhDaXJjbGVTaXplID0gcjtcbiAgICB9XG4gICAgdmFyIHB4ID0gdGhpcy5wcmV2aW91c1ZlcnRpY2FsWF87XG4gICAgY3R4LmNsZWFyUmVjdChweCAtIG1heENpcmNsZVNpemUgLSAxLCAwLFxuICAgICAgICAgICAgICAgICAgMiAqIG1heENpcmNsZVNpemUgKyAyLCB0aGlzLmhlaWdodF8pO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VsUG9pbnRzXy5sZW5ndGggPiAwKSB7XG4gICAgLy8gRHJhdyBjb2xvcmVkIGNpcmNsZXMgb3ZlciB0aGUgY2VudGVyIG9mIGVhY2ggc2VsZWN0ZWQgcG9pbnRcbiAgICB2YXIgY2FudmFzeCA9IHRoaXMuc2VsUG9pbnRzX1swXS5jYW52YXN4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VsUG9pbnRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gdGhpcy5zZWxQb2ludHNfW2ldO1xuICAgICAgaWYgKGlzTmFOKHB0LmNhbnZhc3kpKSBjb250aW51ZTtcblxuICAgICAgdmFyIGNpcmNsZVNpemUgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2hpZ2hsaWdodENpcmNsZVNpemUnLCBwdC5uYW1lKTtcbiAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJkcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFja1wiLCBwdC5uYW1lKTtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMucGxvdHRlcl8uY29sb3JzW3B0Lm5hbWVdO1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IHV0aWxzLkNpcmNsZXMuREVGQVVMVDtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ3N0cm9rZVdpZHRoJywgcHQubmFtZSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcywgcHQubmFtZSwgY3R4LCBjYW52YXN4LCBwdC5jYW52YXN5LFxuICAgICAgICAgIGNvbG9yLCBjaXJjbGVTaXplLCBwdC5pZHgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgdGhpcy5wcmV2aW91c1ZlcnRpY2FsWF8gPSBjYW52YXN4O1xuICB9XG59O1xuXG4vKipcbiAqIE1hbnVhbGx5IHNldCB0aGUgc2VsZWN0ZWQgcG9pbnRzIGFuZCBkaXNwbGF5IGluZm9ybWF0aW9uIGFib3V0IHRoZW0gaW4gdGhlXG4gKiBsZWdlbmQuIFRoZSBzZWxlY3Rpb24gY2FuIGJlIGNsZWFyZWQgdXNpbmcgY2xlYXJTZWxlY3Rpb24oKSBhbmQgcXVlcmllZFxuICogdXNpbmcgZ2V0U2VsZWN0aW9uKCkuXG4gKlxuICogVG8gc2V0IGEgc2VsZWN0ZWQgc2VyaWVzIGJ1dCBub3QgYSBzZWxlY3RlZCBwb2ludCwgY2FsbCBzZXRTZWxlY3Rpb24gd2l0aFxuICogcm93PWZhbHNlIGFuZCB0aGUgc2VsZWN0ZWQgc2VyaWVzIG5hbWUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdyBSb3cgbnVtYmVyIHRoYXQgc2hvdWxkIGJlIGhpZ2hsaWdodGVkIChpLmUuIGFwcGVhciB3aXRoXG4gKiBob3ZlciBkb3RzIG9uIHRoZSBjaGFydCkuXG4gKiBAcGFyYW0ge3Nlcmllc05hbWV9IG9wdGlvbmFsIHNlcmllcyBuYW1lIHRvIGhpZ2hsaWdodCB0aGF0IHNlcmllcyB3aXRoIHRoZVxuICogdGhlIGhpZ2hsaWdodFNlcmllc09wdHMgc2V0dGluZy5cbiAqIEBwYXJhbSB7IGxvY2tlZCB9IG9wdGlvbmFsIElmIHRydWUsIGtlZXAgc2VyaWVzTmFtZSBzZWxlY3RlZCB3aGVuIG1vdXNpbmdcbiAqIG92ZXIgdGhlIGdyYXBoLCBkaXNhYmxpbmcgY2xvc2VzdC1zZXJpZXMgaGlnaGxpZ2h0aW5nLiBDYWxsIGNsZWFyU2VsZWN0aW9uKClcbiAqIHRvIHVubG9jayBpdC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24ocm93LCBvcHRfc2VyaWVzTmFtZSwgb3B0X2xvY2tlZCkge1xuICAvLyBFeHRyYWN0IHRoZSBwb2ludHMgd2UndmUgc2VsZWN0ZWRcbiAgdGhpcy5zZWxQb2ludHNfID0gW107XG5cbiAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKHJvdyAhPT0gZmFsc2UgJiYgcm93ID49IDApIHtcbiAgICBpZiAocm93ICE9IHRoaXMubGFzdFJvd18pIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubGFzdFJvd18gPSByb3c7XG4gICAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgdGhpcy5sYXlvdXRfLnBvaW50cy5sZW5ndGg7ICsrc2V0SWR4KSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50c1tzZXRJZHhdO1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGF0IHRoZSBhcHByb3ByaWF0ZSBpbmRleCBpcyB0aGUgcG9pbnQgd2UncmUgbG9va2luZ1xuICAgICAgLy8gZm9yLiAgSWYgaXQgaXMsIGp1c3QgdXNlIGl0LCBvdGhlcndpc2Ugc2VhcmNoIHRoZSBhcnJheSBmb3IgYSBwb2ludFxuICAgICAgLy8gaW4gdGhlIHByb3BlciBwbGFjZS5cbiAgICAgIHZhciBzZXRSb3cgPSByb3cgLSB0aGlzLmdldExlZnRCb3VuZGFyeV8oc2V0SWR4KTtcbiAgICAgIGlmIChzZXRSb3cgPj0gMCAmJiBzZXRSb3cgPCBwb2ludHMubGVuZ3RoICYmIHBvaW50c1tzZXRSb3ddLmlkeCA9PSByb3cpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW3NldFJvd107XG4gICAgICAgIGlmIChwb2ludC55dmFsICE9PSBudWxsKSB0aGlzLnNlbFBvaW50c18ucHVzaChwb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBwb2ludElkeCA9IDA7IHBvaW50SWR4IDwgcG9pbnRzLmxlbmd0aDsgKytwb2ludElkeCkge1xuICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1twb2ludElkeF07XG4gICAgICAgICAgaWYgKHBvaW50LmlkeCA9PSByb3cpIHtcbiAgICAgICAgICAgIGlmIChwb2ludC55dmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsUG9pbnRzXy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5sYXN0Um93XyA+PSAwKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RSb3dfID0gLTE7XG4gIH1cblxuICBpZiAodGhpcy5zZWxQb2ludHNfLmxlbmd0aCkge1xuICAgIHRoaXMubGFzdHhfID0gdGhpcy5zZWxQb2ludHNfWzBdLnh2YWw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0eF8gPSAtMTtcbiAgfVxuXG4gIGlmIChvcHRfc2VyaWVzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0U2V0XyAhPT0gb3B0X3Nlcmllc05hbWUpIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2V0XyA9IG9wdF9zZXJpZXNOYW1lO1xuICB9XG5cbiAgaWYgKG9wdF9sb2NrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubG9ja2VkU2V0XyA9IG9wdF9sb2NrZWQ7XG4gIH1cblxuICBpZiAoY2hhbmdlZCkge1xuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uXyh1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VkO1xufTtcblxuLyoqXG4gKiBUaGUgbW91c2UgaGFzIGxlZnQgdGhlIGNhbnZhcy4gQ2xlYXIgb3V0IHdoYXRldmVyIGFydGlmYWN0cyByZW1haW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgbW91c2VvdXQgZXZlbnQgZnJvbSB0aGUgYnJvd3Nlci5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm1vdXNlT3V0XyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmICh0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwidW5oaWdobGlnaHRDYWxsYmFja1wiKSkge1xuICAgIHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJ1bmhpZ2hsaWdodENhbGxiYWNrXCIpLmNhbGwodGhpcywgZXZlbnQpO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImhpZGVPdmVybGF5T25Nb3VzZU91dFwiKSAmJiAhdGhpcy5sb2NrZWRTZXRfKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGkuZS4gcG9pbnRzIHRoYXQgd2VyZSBoaWdobGlnaHRlZCBieSBtb3ZpbmdcbiAqIHRoZSBtb3VzZSBvdmVyIHRoZSBjaGFydCkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2Rlc2VsZWN0Jywge30pO1xuXG4gIHRoaXMubG9ja2VkU2V0XyA9IGZhbHNlO1xuICAvLyBHZXQgcmlkIG9mIHRoZSBvdmVybGF5IGRhdGFcbiAgaWYgKHRoaXMuZmFkZUxldmVsKSB7XG4gICAgdGhpcy5hbmltYXRlU2VsZWN0aW9uXygtMSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuY2FudmFzX2N0eF8uY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGhfLCB0aGlzLmhlaWdodF8pO1xuICB0aGlzLmZhZGVMZXZlbCA9IDA7XG4gIHRoaXMuc2VsUG9pbnRzXyA9IFtdO1xuICB0aGlzLmxhc3R4XyA9IC0xO1xuICB0aGlzLmxhc3RSb3dfID0gLTE7XG4gIHRoaXMuaGlnaGxpZ2h0U2V0XyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvdy4gVG8gZ2V0IGRhdGEgZm9yIHRoaXMgcm93LFxuICogeW91IGNhbiB1c2UgdGhlIGdldFZhbHVlIG1ldGhvZC5cbiAqIEByZXR1cm4ge251bWJlcn0gcm93IG51bWJlciwgb3IgLTEgaWYgbm90aGluZyBpcyBzZWxlY3RlZFxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnNlbFBvaW50c18gfHwgdGhpcy5zZWxQb2ludHNfLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLmxheW91dF8ucG9pbnRzLmxlbmd0aDsgc2V0SWR4KyspIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50c1tzZXRJZHhdO1xuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHBvaW50cy5sZW5ndGg7IHJvdysrKSB7XG4gICAgICBpZiAocG9pbnRzW3Jvd10ueCA9PSB0aGlzLnNlbFBvaW50c19bMF0ueCkge1xuICAgICAgICByZXR1cm4gcG9pbnRzW3Jvd10uaWR4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseS1oaWdobGlnaHRlZCBzZXJpZXMuXG4gKiBPbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBoaWdobGlnaHRTZXJpZXNPcHRzIG9wdGlvbiBpcyBpbiB1c2UuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEhpZ2hsaWdodFNlcmllcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5oaWdobGlnaHRTZXRfO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnRseS1oaWdobGlnaHRlZCBzZXJpZXMgd2FzIGxvY2tlZFxuICogdmlhIHNldFNlbGVjdGlvbiguLi4sIHNlcmllc05hbWUsIHRydWUpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5pc1Nlcmllc0xvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sb2NrZWRTZXRfO1xufTtcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZXJlJ3MgZGF0YSBhdmFpbGFibGUgdG8gYmUgZ3JhcGhlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFJhdyBDU1YgZGF0YSB0byBiZSBwbG90dGVkXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5sb2FkZWRFdmVudF8gPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMucmF3RGF0YV8gPSB0aGlzLnBhcnNlQ1NWXyhkYXRhKTtcbiAgdGhpcy5jYXNjYWRlRGF0YURpZFVwZGF0ZUV2ZW50XygpO1xuICB0aGlzLnByZWRyYXdfKCk7XG59O1xuXG4vKipcbiAqIEFkZCB0aWNrcyBvbiB0aGUgeC1heGlzIHJlcHJlc2VudGluZyB5ZWFycywgbW9udGhzLCBxdWFydGVycywgd2Vla3MsIG9yIGRheXNcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFkZFhUaWNrc18gPSBmdW5jdGlvbigpIHtcbiAgLy8gRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRpY2tzIHNjYWxlIG9uIHRoZSB4LWF4aXM6IHF1YXJ0ZXJseSwgbW9udGhseSwgLi4uXG4gIHZhciByYW5nZTtcbiAgaWYgKHRoaXMuZGF0ZVdpbmRvd18pIHtcbiAgICByYW5nZSA9IFt0aGlzLmRhdGVXaW5kb3dfWzBdLCB0aGlzLmRhdGVXaW5kb3dfWzFdXTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZSA9IHRoaXMueEF4aXNFeHRyZW1lcygpO1xuICB9XG5cbiAgdmFyIHhBeGlzT3B0aW9uc1ZpZXcgPSB0aGlzLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3gnKTtcbiAgdmFyIHhUaWNrcyA9IHhBeGlzT3B0aW9uc1ZpZXcoJ3RpY2tlcicpKFxuICAgICAgcmFuZ2VbMF0sXG4gICAgICByYW5nZVsxXSxcbiAgICAgIHRoaXMucGxvdHRlcl8uYXJlYS53LCAgLy8gVE9ETyhkYW52ayk6IHNob3VsZCBiZSBhcmVhLndpZHRoXG4gICAgICB4QXhpc09wdGlvbnNWaWV3LFxuICAgICAgdGhpcyk7XG4gIC8vIHZhciBtc2cgPSAndGlja2VyKCcgKyByYW5nZVswXSArICcsICcgKyByYW5nZVsxXSArICcsICcgKyB0aGlzLndpZHRoXyArICcsICcgKyB0aGlzLmF0dHJfKCdwaXhlbHNQZXJYTGFiZWwnKSArICcpIC0+ICcgKyBKU09OLnN0cmluZ2lmeSh4VGlja3MpO1xuICAvLyBjb25zb2xlLmxvZyhtc2cpO1xuICB0aGlzLmxheW91dF8uc2V0WFRpY2tzKHhUaWNrcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvcnJlY3QgaGFuZGxlciBjbGFzcyBmb3IgdGhlIGN1cnJlbnRseSBzZXQgb3B0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEhhbmRsZXJDbGFzc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhbmRsZXJDbGFzcztcbiAgaWYgKHRoaXMuYXR0cl8oJ2RhdGFIYW5kbGVyJykpIHtcbiAgICBoYW5kbGVyQ2xhc3MgPSAgdGhpcy5hdHRyXygnZGF0YUhhbmRsZXInKTtcbiAgfSBlbHNlIGlmICh0aGlzLmZyYWN0aW9uc18pIHtcbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKCdlcnJvckJhcnMnKSkge1xuICAgICAgaGFuZGxlckNsYXNzID0gRnJhY3Rpb25zQmFyc0hhbmRsZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJDbGFzcyA9IERlZmF1bHRGcmFjdGlvbkhhbmRsZXI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignY3VzdG9tQmFycycpKSB7XG4gICAgaGFuZGxlckNsYXNzID0gQ3VzdG9tQmFyc0hhbmRsZXI7XG4gIH0gZWxzZSBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKCdlcnJvckJhcnMnKSkge1xuICAgIGhhbmRsZXJDbGFzcyA9IEVycm9yQmFyc0hhbmRsZXI7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlckNsYXNzID0gRGVmYXVsdEhhbmRsZXI7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJDbGFzcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgY2hhcnQncyBkYXRhIGlzIGNoYW5nZWQgb3IgdGhlIG9wdGlvbnNcbiAqIGRpY3Rpb25hcnkgaXMgdXBkYXRlZC4gSXQgaXMgX25vdF8gY2FsbGVkIHdoZW4gdGhlIHVzZXIgcGFucyBvciB6b29tcy4gVGhlXG4gKiBpZGVhIGlzIHRoYXQgdmFsdWVzIGRlcml2ZWQgZnJvbSB0aGUgY2hhcnQncyBkYXRhIGNhbiBiZSBjb21wdXRlZCBoZXJlLFxuICogcmF0aGVyIHRoYW4gZXZlcnkgdGltZSB0aGUgY2hhcnQgaXMgZHJhd24uIFRoaXMgaW5jbHVkZXMgdGhpbmdzIGxpa2UgdGhlXG4gKiBudW1iZXIgb2YgYXhlcywgcm9sbGluZyBhdmVyYWdlcywgZXRjLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5wcmVkcmF3XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY29ycmVjdCBkYXRhSGFuZGxlclxuICB0aGlzLmRhdGFIYW5kbGVyXyA9IG5ldyAodGhpcy5nZXRIYW5kbGVyQ2xhc3NfKCkpKCk7XG5cbiAgdGhpcy5sYXlvdXRfLmNvbXB1dGVQbG90QXJlYSgpO1xuXG4gIC8vIFRPRE8oZGFudmspOiBtb3ZlIG1vcmUgY29tcHV0YXRpb25zIG91dCBvZiBkcmF3R3JhcGhfIGFuZCBpbnRvIGhlcmUuXG4gIHRoaXMuY29tcHV0ZVlBeGVzXygpO1xuXG4gIGlmICghdGhpcy5pc19pbml0aWFsX2RyYXdfKSB7XG4gICAgdGhpcy5jYW52YXNfY3R4Xy5yZXN0b3JlKCk7XG4gICAgdGhpcy5oaWRkZW5fY3R4Xy5yZXN0b3JlKCk7XG4gIH1cblxuICB0aGlzLmNhbnZhc19jdHhfLnNhdmUoKTtcbiAgdGhpcy5oaWRkZW5fY3R4Xy5zYXZlKCk7XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHBsb3R0ZXIuXG4gIHRoaXMucGxvdHRlcl8gPSBuZXcgRHlncmFwaENhbnZhc1JlbmRlcmVyKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5fY3R4XyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRfKTtcblxuICAvLyBUaGUgcm9sbGVyIHNpdHMgaW4gdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgY2hhcnQuIFdlIGRvbid0IGtub3cgd2hlcmVcbiAgLy8gdGhpcyB3aWxsIGJlIHVudGlsIHRoZSBvcHRpb25zIGFyZSBhdmFpbGFibGUsIHNvIGl0J3MgcG9zaXRpb25lZCBoZXJlLlxuICB0aGlzLmNyZWF0ZVJvbGxJbnRlcmZhY2VfKCk7XG5cbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygncHJlZHJhdycpO1xuXG4gIC8vIENvbnZlcnQgdGhlIHJhdyBkYXRhIChhIDJEIGFycmF5KSBpbnRvIHRoZSBpbnRlcm5hbCBmb3JtYXQgYW5kIGNvbXB1dGVcbiAgLy8gcm9sbGluZyBhdmVyYWdlcy5cbiAgdGhpcy5yb2xsZWRTZXJpZXNfID0gW251bGxdOyAgLy8geC1heGlzIGlzIHRoZSBmaXJzdCBzZXJpZXMgYW5kIGl0J3Mgc3BlY2lhbFxuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubnVtQ29sdW1ucygpOyBpKyspIHtcbiAgICAvLyB2YXIgbG9nU2NhbGUgPSB0aGlzLmF0dHJfKCdsb2dzY2FsZScsIGkpOyAvLyBUT0RPKGtsYXVzdyk6IHRoaXMgbG9va3Mgd3JvbmcgLy8ga29uaWdzYmVyZyB0aGlua3Mgc28gdG9vLlxuICAgIHZhciBzZXJpZXMgPSB0aGlzLmRhdGFIYW5kbGVyXy5leHRyYWN0U2VyaWVzKHRoaXMucmF3RGF0YV8sIGksIHRoaXMuYXR0cmlidXRlc18pO1xuICAgIGlmICh0aGlzLnJvbGxQZXJpb2RfID4gMSkge1xuICAgICAgc2VyaWVzID0gdGhpcy5kYXRhSGFuZGxlcl8ucm9sbGluZ0F2ZXJhZ2Uoc2VyaWVzLCB0aGlzLnJvbGxQZXJpb2RfLCB0aGlzLmF0dHJpYnV0ZXNfKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvbGxlZFNlcmllc18ucHVzaChzZXJpZXMpO1xuICB9XG5cbiAgLy8gSWYgdGhlIGRhdGEgb3Igb3B0aW9ucyBoYXZlIGNoYW5nZWQsIHRoZW4gd2UnZCBiZXR0ZXIgcmVkcmF3LlxuICB0aGlzLmRyYXdHcmFwaF8oKTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gZG8gdmFyaW91cyBhbmltYXRpb25zLlxuICB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgdGhpcy5kcmF3aW5nVGltZU1zXyA9IChlbmQgLSBzdGFydCk7XG59O1xuXG4vKipcbiAqIFBvaW50IHN0cnVjdHVyZS5cbiAqXG4gKiB4dmFsXyogYW5kIHl2YWxfKiBhcmUgdGhlIG9yaWdpbmFsIHVuc2NhbGVkIGRhdGEgdmFsdWVzLFxuICogd2hpbGUgeF8qIGFuZCB5XyogYXJlIHNjYWxlZCB0byB0aGUgcmFuZ2UgKDAuMC0xLjApIGZvciBwbG90dGluZy5cbiAqIHl2YWxfc3RhY2tlZCBpcyB0aGUgY3VtdWxhdGl2ZSBZIHZhbHVlIHVzZWQgZm9yIHN0YWNraW5nIGdyYXBocyxcbiAqIGFuZCBib3R0b20vdG9wL21pbnVzL3BsdXMgYXJlIHVzZWQgZm9yIGVycm9yIGJhciBncmFwaHMuXG4gKlxuICogQHR5cGVkZWYge3tcbiAqICAgICBpZHg6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmcsXG4gKiAgICAgeDogP251bWJlcixcbiAqICAgICB4dmFsOiA/bnVtYmVyLFxuICogICAgIHlfYm90dG9tOiA/bnVtYmVyLFxuICogICAgIHk6ID9udW1iZXIsXG4gKiAgICAgeV9zdGFja2VkOiA/bnVtYmVyLFxuICogICAgIHlfdG9wOiA/bnVtYmVyLFxuICogICAgIHl2YWxfbWludXM6ID9udW1iZXIsXG4gKiAgICAgeXZhbDogP251bWJlcixcbiAqICAgICB5dmFsX3BsdXM6ID9udW1iZXIsXG4gKiAgICAgeXZhbF9zdGFja2VkXG4gKiB9fVxuICovXG5EeWdyYXBoLlBvaW50VHlwZSA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHBvaW50IHN0YWNraW5nIGZvciBzdGFja2VkR3JhcGg9dHJ1ZS5cbiAqXG4gKiBGb3Igc3RhY2tpbmcgcHVycG9zZXMsIGludGVycG9sYXRlIG9yIGV4dGVuZCBuZWlnaGJvcmluZyBkYXRhIGFjcm9zc1xuICogTmFOIHZhbHVlcyBiYXNlZCBvbiBzdGFja2VkR3JhcGhOYU5GaWxsIHNldHRpbmdzLiBUaGlzIGlzIGZvciBkaXNwbGF5XG4gKiBvbmx5LCB0aGUgdW5kZXJseWluZyBkYXRhIHZhbHVlIGFzIHNob3duIGluIHRoZSBsZWdlbmQgcmVtYWlucyBOYU4uXG4gKlxuICogQHBhcmFtIHtBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBwb2ludHMgUG9pbnQgYXJyYXkgZm9yIGEgc2luZ2xlIHNlcmllcy5cbiAqICAgICBVcGRhdGVzIGVhY2ggUG9pbnQncyB5dmFsX3N0YWNrZWQgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjdW11bGF0aXZlWXZhbCBBY2N1bXVsYXRlZCB0b3Atb2YtZ3JhcGggc3RhY2tlZCBZXG4gKiAgICAgdmFsdWVzIGZvciB0aGUgc2VyaWVzIHNlZW4gc28gZmFyLiBJbmRleCBpcyB0aGUgcm93IG51bWJlci4gVXBkYXRlZFxuICogICAgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNlcmllcydzIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNlcmllc0V4dHJlbWVzIE1pbiBhbmQgbWF4IHZhbHVlcywgdXBkYXRlZFxuICogICAgIHRvIHJlZmxlY3QgdGhlIHN0YWNrZWQgdmFsdWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGxNZXRob2QgSW50ZXJwb2xhdGlvbiBtZXRob2QsIG9uZSBvZiAnYWxsJywgJ2luc2lkZScsIG9yXG4gKiAgICAgJ25vbmUnLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5zdGFja1BvaW50c18gPSBmdW5jdGlvbihcbiAgICBwb2ludHMsIGN1bXVsYXRpdmVZdmFsLCBzZXJpZXNFeHRyZW1lcywgZmlsbE1ldGhvZCkge1xuICB2YXIgbGFzdFh2YWwgPSBudWxsO1xuICB2YXIgcHJldlBvaW50ID0gbnVsbDtcbiAgdmFyIG5leHRQb2ludCA9IG51bGw7XG4gIHZhciBuZXh0UG9pbnRJZHggPSAtMTtcblxuICAvLyBGaW5kIHRoZSBuZXh0IHN0YWNrYWJsZSBwb2ludCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBpbmRleC5cbiAgdmFyIHVwZGF0ZU5leHRQb2ludCA9IGZ1bmN0aW9uKGlkeCkge1xuICAgIC8vIElmIHdlJ3ZlIHByZXZpb3VzbHkgZm91bmQgYSBub24tTmFOIHBvaW50IGFuZCBoYXZlbid0IGdvbmUgcGFzdCBpdCB5ZXQsXG4gICAgLy8ganVzdCB1c2UgdGhhdC5cbiAgICBpZiAobmV4dFBvaW50SWR4ID49IGlkeCkgcmV0dXJuO1xuXG4gICAgLy8gV2UgaGF2ZW4ndCBmb3VuZCBhIG5vbi1OYU4gcG9pbnQgeWV0IG9yIGhhdmUgbW92ZWQgcGFzdCBpdCxcbiAgICAvLyBsb29rIHRvd2FyZHMgdGhlIHJpZ2h0IHRvIGZpbmQgYSBub24tTmFOIHBvaW50LlxuICAgIGZvciAodmFyIGogPSBpZHg7IGogPCBwb2ludHMubGVuZ3RoOyArK2opIHtcbiAgICAgIC8vIENsZWFyIG91dCBhIHByZXZpb3VzbHktZm91bmQgcG9pbnQgKGlmIGFueSkgc2luY2UgaXQncyBubyBsb25nZXJcbiAgICAgIC8vIHZhbGlkLCB3ZSBzaG91bGRuJ3QgdXNlIGl0IGZvciBpbnRlcnBvbGF0aW9uIGFueW1vcmUuXG4gICAgICBuZXh0UG9pbnQgPSBudWxsO1xuICAgICAgaWYgKCFpc05hTihwb2ludHNbal0ueXZhbCkgJiYgcG9pbnRzW2pdLnl2YWwgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFBvaW50SWR4ID0gajtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2pdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgdmFyIHh2YWwgPSBwb2ludC54dmFsO1xuICAgIGlmIChjdW11bGF0aXZlWXZhbFt4dmFsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdW11bGF0aXZlWXZhbFt4dmFsXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbFl2YWwgPSBwb2ludC55dmFsO1xuICAgIGlmIChpc05hTihhY3R1YWxZdmFsKSB8fCBhY3R1YWxZdmFsID09PSBudWxsKSB7XG4gICAgICBpZihmaWxsTWV0aG9kID09ICdub25lJykge1xuICAgICAgICBhY3R1YWxZdmFsID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEludGVycG9sYXRlL2V4dGVuZCBmb3Igc3RhY2tpbmcgcHVycG9zZXMgaWYgcG9zc2libGUuXG4gICAgICAgIHVwZGF0ZU5leHRQb2ludChpKTtcbiAgICAgICAgaWYgKHByZXZQb2ludCAmJiBuZXh0UG9pbnQgJiYgZmlsbE1ldGhvZCAhPSAnbm9uZScpIHtcbiAgICAgICAgICAvLyBVc2UgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBwcmV2UG9pbnQgYW5kIG5leHRQb2ludC5cbiAgICAgICAgICBhY3R1YWxZdmFsID0gcHJldlBvaW50Lnl2YWwgKyAobmV4dFBvaW50Lnl2YWwgLSBwcmV2UG9pbnQueXZhbCkgKlxuICAgICAgICAgICAgICAoKHh2YWwgLSBwcmV2UG9pbnQueHZhbCkgLyAobmV4dFBvaW50Lnh2YWwgLSBwcmV2UG9pbnQueHZhbCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZQb2ludCAmJiBmaWxsTWV0aG9kID09ICdhbGwnKSB7XG4gICAgICAgICAgYWN0dWFsWXZhbCA9IHByZXZQb2ludC55dmFsO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRQb2ludCAmJiBmaWxsTWV0aG9kID09ICdhbGwnKSB7XG4gICAgICAgICAgYWN0dWFsWXZhbCA9IG5leHRQb2ludC55dmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdHVhbFl2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgIH1cblxuICAgIHZhciBzdGFja2VkWXZhbCA9IGN1bXVsYXRpdmVZdmFsW3h2YWxdO1xuICAgIGlmIChsYXN0WHZhbCAhPSB4dmFsKSB7XG4gICAgICAvLyBJZiBhbiB4LXZhbHVlIGlzIHJlcGVhdGVkLCB3ZSBpZ25vcmUgdGhlIGR1cGxpY2F0ZXMuXG4gICAgICBzdGFja2VkWXZhbCArPSBhY3R1YWxZdmFsO1xuICAgICAgY3VtdWxhdGl2ZVl2YWxbeHZhbF0gPSBzdGFja2VkWXZhbDtcbiAgICB9XG4gICAgbGFzdFh2YWwgPSB4dmFsO1xuXG4gICAgcG9pbnQueXZhbF9zdGFja2VkID0gc3RhY2tlZFl2YWw7XG5cbiAgICBpZiAoc3RhY2tlZFl2YWwgPiBzZXJpZXNFeHRyZW1lc1sxXSkge1xuICAgICAgc2VyaWVzRXh0cmVtZXNbMV0gPSBzdGFja2VkWXZhbDtcbiAgICB9XG4gICAgaWYgKHN0YWNrZWRZdmFsIDwgc2VyaWVzRXh0cmVtZXNbMF0pIHtcbiAgICAgIHNlcmllc0V4dHJlbWVzWzBdID0gc3RhY2tlZFl2YWw7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogTG9vcCBvdmVyIGFsbCBmaWVsZHMgYW5kIGNyZWF0ZSBkYXRhc2V0cywgY2FsY3VsYXRpbmcgZXh0cmVtZSB5LXZhbHVlcyBmb3JcbiAqIGVhY2ggc2VyaWVzIGFuZCBleHRyZW1lIHgtaW5kaWNlcyBhcyB3ZSBnby5cbiAqXG4gKiBkYXRlV2luZG93IGlzIHBhc3NlZCBpbiBhcyBhbiBleHBsaWNpdCBwYXJhbWV0ZXIgc28gdGhhdCB3ZSBjYW4gY29tcHV0ZVxuICogZXh0cmVtZSB2YWx1ZXMgXCJzcGVjdWxhdGl2ZWx5XCIsIGkuZS4gd2l0aG91dCBhY3R1YWxseSBzZXR0aW5nIHN0YXRlIG9uIHRoZVxuICogZHlncmFwaC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48QXJyYXkuPChudW1iZXJ8QXJyYXk8bnVtYmVyPik+Pn0gcm9sbGVkU2VyaWVzLCB3aGVyZVxuICogICAgIHJvbGxlZFNlcmllc1tzZXJpZXNJbmRleF1bcm93XSA9IHJhdyBwb2ludCwgd2hlcmVcbiAqICAgICBzZXJpZXNJbmRleCBpcyB0aGUgY29sdW1uIG51bWJlciBzdGFydGluZyB3aXRoIDEsIGFuZFxuICogICAgIHJhd1BvaW50IGlzIFt4LHldIG9yIFt4LCBbeSwgZXJyXV0gb3IgW3gsIFt5LCB5bWludXMsIHlwbHVzXV0uXG4gKiBAcGFyYW0gez9BcnJheS48bnVtYmVyPn0gZGF0ZVdpbmRvdyBbeG1pbiwgeG1heF0gcGFpciwgb3IgbnVsbC5cbiAqIEByZXR1cm4ge3tcbiAqICAgICBwb2ludHM6IEFycmF5LjxBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+PixcbiAqICAgICBzZXJpZXNFeHRyZW1lczogQXJyYXkuPEFycmF5LjxudW1iZXI+PixcbiAqICAgICBib3VuZGFyeUlkczogQXJyYXkuPG51bWJlcj59fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2F0aGVyRGF0YXNldHNfID0gZnVuY3Rpb24ocm9sbGVkU2VyaWVzLCBkYXRlV2luZG93KSB7XG4gIHZhciBib3VuZGFyeUlkcyA9IFtdO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBjdW11bGF0aXZlWXZhbCA9IFtdOyAgLy8gRm9yIHN0YWNrZWQgc2VyaWVzLlxuICB2YXIgZXh0cmVtZXMgPSB7fTsgIC8vIHNlcmllcyBuYW1lIC0+IFtsb3csIGhpZ2hdXG4gIHZhciBzZXJpZXNJZHgsIHNhbXBsZUlkeDtcbiAgdmFyIGZpcnN0SWR4LCBsYXN0SWR4O1xuICB2YXIgYXhpc0lkeDtcblxuICAvLyBMb29wIG92ZXIgdGhlIGZpZWxkcyAoc2VyaWVzKS4gIEdvIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LFxuICAvLyBiZWNhdXNlIGlmIHRoZXkncmUgc3RhY2tlZCB0aGF0J3MgaG93IHdlIGFjY3VtdWxhdGUgdGhlIHZhbHVlcy5cbiAgdmFyIG51bV9zZXJpZXMgPSByb2xsZWRTZXJpZXMubGVuZ3RoIC0gMTtcbiAgdmFyIHNlcmllcztcbiAgZm9yIChzZXJpZXNJZHggPSBudW1fc2VyaWVzOyBzZXJpZXNJZHggPj0gMTsgc2VyaWVzSWR4LS0pIHtcbiAgICBpZiAoIXRoaXMudmlzaWJpbGl0eSgpW3Nlcmllc0lkeCAtIDFdKSBjb250aW51ZTtcblxuICAgIC8vIFBydW5lIGRvd24gdG8gdGhlIGRlc2lyZWQgcmFuZ2UsIGlmIG5lY2Vzc2FyeSAoZm9yIHpvb21pbmcpXG4gICAgLy8gQmVjYXVzZSB0aGVyZSBjYW4gYmUgbGluZXMgZ29pbmcgdG8gcG9pbnRzIG91dHNpZGUgb2YgdGhlIHZpc2libGUgYXJlYSxcbiAgICAvLyB3ZSBhY3R1YWxseSBwcnVuZSB0byB2aXNpYmxlIHBvaW50cywgcGx1cyBvbmUgb24gZWl0aGVyIHNpZGUuXG4gICAgaWYgKGRhdGVXaW5kb3cpIHtcbiAgICAgIHNlcmllcyA9IHJvbGxlZFNlcmllc1tzZXJpZXNJZHhdO1xuICAgICAgdmFyIGxvdyA9IGRhdGVXaW5kb3dbMF07XG4gICAgICB2YXIgaGlnaCA9IGRhdGVXaW5kb3dbMV07XG5cbiAgICAgIC8vIFRPRE8oZGFudmspOiBkbyBiaW5hcnkgc2VhcmNoIGluc3RlYWQgb2YgbGluZWFyIHNlYXJjaC5cbiAgICAgIC8vIFRPRE8oZGFudmspOiBwYXNzIGZpcnN0SWR4IGFuZCBsYXN0SWR4IGRpcmVjdGx5IHRvIHRoZSByZW5kZXJlci5cbiAgICAgIGZpcnN0SWR4ID0gbnVsbDtcbiAgICAgIGxhc3RJZHggPSBudWxsO1xuICAgICAgZm9yIChzYW1wbGVJZHggPSAwOyBzYW1wbGVJZHggPCBzZXJpZXMubGVuZ3RoOyBzYW1wbGVJZHgrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NhbXBsZUlkeF1bMF0gPj0gbG93ICYmIGZpcnN0SWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RJZHggPSBzYW1wbGVJZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllc1tzYW1wbGVJZHhdWzBdIDw9IGhpZ2gpIHtcbiAgICAgICAgICBsYXN0SWR4ID0gc2FtcGxlSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdElkeCA9PT0gbnVsbCkgZmlyc3RJZHggPSAwO1xuICAgICAgdmFyIGNvcnJlY3RlZEZpcnN0SWR4ID0gZmlyc3RJZHg7XG4gICAgICB2YXIgaXNJbnZhbGlkVmFsdWUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGlzSW52YWxpZFZhbHVlICYmIGNvcnJlY3RlZEZpcnN0SWR4ID4gMCkge1xuICAgICAgICBjb3JyZWN0ZWRGaXJzdElkeC0tO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgeSB2YWx1ZSBpcyBudWxsLlxuICAgICAgICBpc0ludmFsaWRWYWx1ZSA9IHNlcmllc1tjb3JyZWN0ZWRGaXJzdElkeF1bMV0gPT09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0SWR4ID09PSBudWxsKSBsYXN0SWR4ID0gc2VyaWVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgY29ycmVjdGVkTGFzdElkeCA9IGxhc3RJZHg7XG4gICAgICBpc0ludmFsaWRWYWx1ZSA9IHRydWU7XG4gICAgICB3aGlsZSAoaXNJbnZhbGlkVmFsdWUgJiYgY29ycmVjdGVkTGFzdElkeCA8IHNlcmllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvcnJlY3RlZExhc3RJZHgrKztcbiAgICAgICAgaXNJbnZhbGlkVmFsdWUgPSBzZXJpZXNbY29ycmVjdGVkTGFzdElkeF1bMV0gPT09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JyZWN0ZWRGaXJzdElkeCE9PWZpcnN0SWR4KSB7XG4gICAgICAgIGZpcnN0SWR4ID0gY29ycmVjdGVkRmlyc3RJZHg7XG4gICAgICB9XG4gICAgICBpZiAoY29ycmVjdGVkTGFzdElkeCAhPT0gbGFzdElkeCkge1xuICAgICAgICBsYXN0SWR4ID0gY29ycmVjdGVkTGFzdElkeDtcbiAgICAgIH1cblxuICAgICAgYm91bmRhcnlJZHNbc2VyaWVzSWR4LTFdID0gW2ZpcnN0SWR4LCBsYXN0SWR4XTtcblxuICAgICAgLy8gLnNsaWNlJ3MgZW5kIGlzIGV4Y2x1c2l2ZSwgd2Ugd2FudCB0byBpbmNsdWRlIGxhc3RJZHguXG4gICAgICBzZXJpZXMgPSBzZXJpZXMuc2xpY2UoZmlyc3RJZHgsIGxhc3RJZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzID0gcm9sbGVkU2VyaWVzW3Nlcmllc0lkeF07XG4gICAgICBib3VuZGFyeUlkc1tzZXJpZXNJZHgtMV0gPSBbMCwgc2VyaWVzLmxlbmd0aC0xXTtcbiAgICB9XG5cbiAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIilbc2VyaWVzSWR4XTtcbiAgICB2YXIgc2VyaWVzRXh0cmVtZXMgPSB0aGlzLmRhdGFIYW5kbGVyXy5nZXRFeHRyZW1lWVZhbHVlcyhzZXJpZXMsXG4gICAgICAgIGRhdGVXaW5kb3csIHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsc2VyaWVzTmFtZSkpO1xuXG4gICAgdmFyIHNlcmllc1BvaW50cyA9IHRoaXMuZGF0YUhhbmRsZXJfLnNlcmllc1RvUG9pbnRzKHNlcmllcyxcbiAgICAgICAgc2VyaWVzTmFtZSwgYm91bmRhcnlJZHNbc2VyaWVzSWR4LTFdWzBdKTtcblxuICAgIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJzdGFja2VkR3JhcGhcIikpIHtcbiAgICAgIGF4aXNJZHggPSB0aGlzLmF0dHJpYnV0ZXNfLmF4aXNGb3JTZXJpZXMoc2VyaWVzTmFtZSk7XG4gICAgICBpZiAoY3VtdWxhdGl2ZVl2YWxbYXhpc0lkeF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdW11bGF0aXZlWXZhbFtheGlzSWR4XSA9IFtdO1xuICAgICAgfVxuICAgICAgRHlncmFwaC5zdGFja1BvaW50c18oc2VyaWVzUG9pbnRzLCBjdW11bGF0aXZlWXZhbFtheGlzSWR4XSwgc2VyaWVzRXh0cmVtZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJzdGFja2VkR3JhcGhOYU5GaWxsXCIpKTtcbiAgICB9XG5cbiAgICBleHRyZW1lc1tzZXJpZXNOYW1lXSA9IHNlcmllc0V4dHJlbWVzO1xuICAgIHBvaW50c1tzZXJpZXNJZHhdID0gc2VyaWVzUG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIHsgcG9pbnRzOiBwb2ludHMsIGV4dHJlbWVzOiBleHRyZW1lcywgYm91bmRhcnlJZHM6IGJvdW5kYXJ5SWRzIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgZ3JhcGggd2l0aCBuZXcgZGF0YS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHZpZXdpbmcgYXJlYVxuICogaGFzIGNoYW5nZWQuIElmIHRoZSB1bmRlcmx5aW5nIGRhdGEgb3Igb3B0aW9ucyBoYXZlIGNoYW5nZWQsIHByZWRyYXdfIHdpbGxcbiAqIGJlIGNhbGxlZCBiZWZvcmUgZHJhd0dyYXBoXyBpcyBjYWxsZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZHJhd0dyYXBoXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gZHJhd0NhbGxiYWNrLCBiZWxvdy5cbiAgdmFyIGlzX2luaXRpYWxfZHJhdyA9IHRoaXMuaXNfaW5pdGlhbF9kcmF3XztcbiAgdGhpcy5pc19pbml0aWFsX2RyYXdfID0gZmFsc2U7XG5cbiAgdGhpcy5sYXlvdXRfLnJlbW92ZUFsbERhdGFzZXRzKCk7XG4gIHRoaXMuc2V0Q29sb3JzXygpO1xuICB0aGlzLmF0dHJzXy5wb2ludFNpemUgPSAwLjUgKiB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2hpZ2hsaWdodENpcmNsZVNpemUnKTtcblxuICB2YXIgcGFja2VkID0gdGhpcy5nYXRoZXJEYXRhc2V0c18odGhpcy5yb2xsZWRTZXJpZXNfLCB0aGlzLmRhdGVXaW5kb3dfKTtcbiAgdmFyIHBvaW50cyA9IHBhY2tlZC5wb2ludHM7XG4gIHZhciBleHRyZW1lcyA9IHBhY2tlZC5leHRyZW1lcztcbiAgdGhpcy5ib3VuZGFyeUlkc18gPSBwYWNrZWQuYm91bmRhcnlJZHM7XG5cbiAgdGhpcy5zZXRJbmRleEJ5TmFtZV8gPSB7fTtcbiAgdmFyIGxhYmVscyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIik7XG4gIHZhciBkYXRhSWR4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXRoaXMudmlzaWJpbGl0eSgpW2kgLSAxXSkgY29udGludWU7XG4gICAgdGhpcy5sYXlvdXRfLmFkZERhdGFzZXQobGFiZWxzW2ldLCBwb2ludHNbaV0pO1xuICAgIHRoaXMuZGF0YXNldEluZGV4X1tpXSA9IGRhdGFJZHgrKztcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuc2V0SW5kZXhCeU5hbWVfW2xhYmVsc1tpXV0gPSBpO1xuICB9XG5cbiAgdGhpcy5jb21wdXRlWUF4aXNSYW5nZXNfKGV4dHJlbWVzKTtcbiAgdGhpcy5sYXlvdXRfLnNldFlBeGVzKHRoaXMuYXhlc18pO1xuXG4gIHRoaXMuYWRkWFRpY2tzXygpO1xuXG4gIC8vIFRlbGwgUGxvdEtpdCB0byB1c2UgdGhpcyBuZXcgZGF0YSBhbmQgcmVuZGVyIGl0c2VsZlxuICB0aGlzLmxheW91dF8uZXZhbHVhdGUoKTtcbiAgdGhpcy5yZW5kZXJHcmFwaF8oaXNfaW5pdGlhbF9kcmF3KTtcblxuICBpZiAodGhpcy5nZXRTdHJpbmdPcHRpb24oXCJ0aW1pbmdOYW1lXCIpKSB7XG4gICAgdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc29sZS5sb2codGhpcy5nZXRTdHJpbmdPcHRpb24oXCJ0aW1pbmdOYW1lXCIpICsgXCIgLSBkcmF3R3JhcGg6IFwiICsgKGVuZCAtIHN0YXJ0KSArIFwibXNcIik7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBkb2VzIHRoZSB3b3JrIG9mIGRyYXdpbmcgdGhlIGNoYXJ0LiBJdCBhc3N1bWVzIHRoYXQgdGhlIGxheW91dCBhbmQgYXhpc1xuICogc2NhbGVzIGhhdmUgYWxyZWFkeSBiZWVuIHNldCAoZS5nLiBieSBwcmVkcmF3XykuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVuZGVyR3JhcGhfID0gZnVuY3Rpb24oaXNfaW5pdGlhbF9kcmF3KSB7XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2NsZWFyQ2hhcnQnKTtcbiAgdGhpcy5wbG90dGVyXy5jbGVhcigpO1xuXG4gIGNvbnN0IHVuZGVybGF5Q2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKCd1bmRlcmxheUNhbGxiYWNrJyk7XG4gIGlmICh1bmRlcmxheUNhbGxiYWNrKSB7XG4gICAgLy8gTk9URTogd2UgcGFzcyB0aGUgZHlncmFwaCBvYmplY3QgdG8gdGhpcyBjYWxsYmFjayB0d2ljZSB0byBhdm9pZCBicmVha2luZ1xuICAgIC8vIHVzZXJzIHdobyBleHBlY3QgYSBkZXByZWNhdGVkIGZvcm0gb2YgdGhpcyBjYWxsYmFjay5cbiAgICB1bmRlcmxheUNhbGxiYWNrLmNhbGwodGhpcyxcbiAgICAgICAgdGhpcy5oaWRkZW5fY3R4XywgdGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCksIHRoaXMsIHRoaXMpO1xuICB9XG5cbiAgdmFyIGUgPSB7XG4gICAgY2FudmFzOiB0aGlzLmhpZGRlbl8sXG4gICAgZHJhd2luZ0NvbnRleHQ6IHRoaXMuaGlkZGVuX2N0eF9cbiAgfTtcbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnd2lsbERyYXdDaGFydCcsIGUpO1xuICB0aGlzLnBsb3R0ZXJfLnJlbmRlcigpO1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdkaWREcmF3Q2hhcnQnLCBlKTtcbiAgdGhpcy5sYXN0Um93XyA9IC0xOyAgLy8gYmVjYXVzZSBwbHVnaW5zL2xlZ2VuZC5qcyBjbGVhcnMgdGhlIGxlZ2VuZFxuXG4gIC8vIFRPRE8oZGFudmspOiBpcyB0aGlzIGEgcGVyZm9ybWFuY2UgYm90dGxlbmVjayB3aGVuIHBhbm5pbmc/XG4gIC8vIFRoZSBpbnRlcmFjdGlvbiBjYW52YXMgc2hvdWxkIGFscmVhZHkgYmUgZW1wdHkgaW4gdGhhdCBzaXR1YXRpb24uXG4gIHRoaXMuY2FudmFzXy5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcblxuICBjb25zdCBkcmF3Q2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwiZHJhd0NhbGxiYWNrXCIpO1xuICBpZiAoZHJhd0NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgZHJhd0NhbGxiYWNrLmNhbGwodGhpcywgdGhpcywgaXNfaW5pdGlhbF9kcmF3KTtcbiAgfVxuICBpZiAoaXNfaW5pdGlhbF9kcmF3KSB7XG4gICAgdGhpcy5yZWFkeUZpcmVkXyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucmVhZHlGbnNfLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBmbiA9IHRoaXMucmVhZHlGbnNfLnBvcCgpO1xuICAgICAgZm4odGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmUgcHJvcGVydGllcyBvZiB0aGUgeS1heGVzIHdoaWNoIGFyZSBpbmRlcGVuZGVudCBvZiB0aGUgZGF0YVxuICogY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZC4gVGhpcyBpbmNsdWRlcyB0aGluZ3MgbGlrZSB0aGUgbnVtYmVyIG9mIGF4ZXMgYW5kXG4gKiB0aGUgc3R5bGUgb2YgdGhlIGF4ZXMuIEl0IGRvZXMgbm90IGluY2x1ZGUgdGhlIHJhbmdlIG9mIGVhY2ggYXhpcyBhbmQgaXRzXG4gKiB0aWNrIG1hcmtzLlxuICogVGhpcyBmaWxscyBpbiB0aGlzLmF4ZXNfLlxuICogYXhlc18gPSBbIHsgb3B0aW9ucyB9IF1cbiAqICAgaW5kaWNlcyBhcmUgaW50byB0aGUgYXhlc18gYXJyYXkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNvbXB1dGVZQXhlc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF4aXMsIGluZGV4LCBvcHRzLCB2O1xuXG4gIC8vIHRoaXMuYXhlc18gZG9lc24ndCBtYXRjaCB0aGlzLmF0dHJpYnV0ZXNfLmF4ZXNfLm9wdGlvbnMuIEl0J3MgdXNlZCBmb3JcbiAgLy8gZGF0YSBjb21wdXRhdGlvbiBhcyB3ZWxsIGFzIG9wdGlvbnMgc3RvcmFnZS5cbiAgLy8gR28gdGhyb3VnaCBvbmNlIGFuZCBhZGQgYWxsIHRoZSBheGVzLlxuICB0aGlzLmF4ZXNfID0gW107XG5cbiAgZm9yIChheGlzID0gMDsgYXhpcyA8IHRoaXMuYXR0cmlidXRlc18ubnVtQXhlcygpOyBheGlzKyspIHtcbiAgICAvLyBBZGQgYSBuZXcgYXhpcywgbWFraW5nIGEgY29weSBvZiBpdHMgcGVyLWF4aXMgb3B0aW9ucy5cbiAgICBvcHRzID0geyBnIDogdGhpcyB9O1xuICAgIHV0aWxzLnVwZGF0ZShvcHRzLCB0aGlzLmF0dHJpYnV0ZXNfLmF4aXNPcHRpb25zKGF4aXMpKTtcbiAgICB0aGlzLmF4ZXNfW2F4aXNdID0gb3B0cztcbiAgfVxuXG4gIGZvciAoYXhpcyA9IDA7IGF4aXMgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgYXhpcysrKSB7XG4gICAgaWYgKGF4aXMgPT09IDApIHtcbiAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3knICsgKGF4aXMgPyAnMicgOiAnJykpO1xuICAgICAgdiA9IG9wdHMoXCJ2YWx1ZVJhbmdlXCIpO1xuICAgICAgaWYgKHYpIHRoaXMuYXhlc19bYXhpc10udmFsdWVSYW5nZSA9IHY7XG4gICAgfSBlbHNlIHsgIC8vIFRvIGtlZXAgb2xkIGJlaGF2aW9yXG4gICAgICB2YXIgYXhlcyA9IHRoaXMudXNlcl9hdHRyc18uYXhlcztcbiAgICAgIGlmIChheGVzICYmIGF4ZXMueTIpIHtcbiAgICAgICAgdiA9IGF4ZXMueTIudmFsdWVSYW5nZTtcbiAgICAgICAgaWYgKHYpIHRoaXMuYXhlc19bYXhpc10udmFsdWVSYW5nZSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB5LWF4ZXMgb24gdGhlIGNoYXJ0LlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGF4ZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm51bUF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc18ubnVtQXhlcygpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJucyBheGlzIHByb3BlcnRpZXMgZm9yIHRoZSBnaXZlbiBzZXJpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIGZvciB3aGljaCB0byBnZXQgYXhpc1xuICogcHJvcGVydGllcywgZS5nLiAnWTEnLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgYXhpcyBwcm9wZXJ0aWVzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5heGlzUHJvcGVydGllc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICAvLyBUT0RPKGRhbnZrKTogaGFuZGxlIGVycm9ycy5cbiAgcmV0dXJuIHRoaXMuYXhlc19bdGhpcy5hdHRyaWJ1dGVzXy5heGlzRm9yU2VyaWVzKHNlcmllcyldO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGV0ZXJtaW5lIHRoZSB2YWx1ZSByYW5nZSBhbmQgdGljayBtYXJrcyBmb3IgZWFjaCBheGlzLlxuICogQHBhcmFtIHtPYmplY3R9IGV4dHJlbWVzIEEgbWFwcGluZyBmcm9tIHNlcmllc05hbWUgLT4gW2xvdywgaGlnaF1cbiAqIFRoaXMgZmlsbHMgaW4gdGhlIHZhbHVlUmFuZ2UgYW5kIHRpY2tzIGZpZWxkcyBpbiBlYWNoIGVudHJ5IG9mIHRoaXMuYXhlc18uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNvbXB1dGVZQXhpc1Jhbmdlc18gPSBmdW5jdGlvbihleHRyZW1lcykge1xuICB2YXIgaXNOdWxsVW5kZWZpbmVkT3JOYU4gPSBmdW5jdGlvbihudW0pIHtcbiAgICByZXR1cm4gaXNOYU4ocGFyc2VGbG9hdChudW0pKTtcbiAgfTtcbiAgdmFyIG51bUF4ZXMgPSB0aGlzLmF0dHJpYnV0ZXNfLm51bUF4ZXMoKTtcbiAgdmFyIHlwYWRDb21wYXQsIHNwYW4sIHNlcmllcywgeXBhZDtcblxuICB2YXIgcF9heGlzO1xuXG4gIC8vIENvbXB1dGUgZXh0cmVtZSB2YWx1ZXMsIGEgc3BhbiBhbmQgdGljayBtYXJrcyBmb3IgZWFjaCBheGlzLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF4ZXM7IGkrKykge1xuICAgIHZhciBheGlzID0gdGhpcy5heGVzX1tpXTtcbiAgICB2YXIgbG9nc2NhbGUgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKTtcbiAgICB2YXIgaW5jbHVkZVplcm8gPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJpbmNsdWRlWmVyb1wiLCBpKTtcbiAgICB2YXIgaW5kZXBlbmRlbnRUaWNrcyA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImluZGVwZW5kZW50VGlja3NcIiwgaSk7XG4gICAgc2VyaWVzID0gdGhpcy5hdHRyaWJ1dGVzXy5zZXJpZXNGb3JBeGlzKGkpO1xuXG4gICAgLy8gQWRkIHNvbWUgcGFkZGluZy4gVGhpcyBzdXBwb3J0cyB0d28gWSBwYWRkaW5nIG9wZXJhdGlvbiBtb2RlczpcbiAgICAvL1xuICAgIC8vIC0gYmFja3dhcmRzIGNvbXBhdGlibGUgKHlSYW5nZVBhZCBub3Qgc2V0KTpcbiAgICAvLyAgIDEwJSBwYWRkaW5nIGZvciBhdXRvbWF0aWMgWSByYW5nZXMsIGJ1dCBub3QgZm9yIHVzZXItc3VwcGxpZWRcbiAgICAvLyAgIHJhbmdlcywgYW5kIG1vdmUgYSBjbG9zZS10by16ZXJvIGVkZ2UgdG8gemVybywgc2luY2UgZHJhd2luZyBhdCB0aGUgZWRnZVxuICAgIC8vICAgcmVzdWx0cyBpbiBpbnZpc2libGUgbGluZXMuIFVuZm9ydHVuYXRlbHkgbGluZXMgZHJhd24gYXQgdGhlIGVkZ2Ugb2YgYVxuICAgIC8vICAgdXNlci1zdXBwbGllZCByYW5nZSB3aWxsIHN0aWxsIGJlIGludmlzaWJsZS4gSWYgbG9nc2NhbGUgaXNcbiAgICAvLyAgIHNldCwgYWRkIGEgdmFyaWFibGUgYW1vdW50IG9mIHBhZGRpbmcgYXQgdGhlIHRvcCBidXRcbiAgICAvLyAgIG5vbmUgYXQgdGhlIGJvdHRvbS5cbiAgICAvL1xuICAgIC8vIC0gbmV3LXN0eWxlICh5UmFuZ2VQYWQgc2V0IGJ5IHRoZSB1c2VyKTpcbiAgICAvLyAgIGFsd2F5cyBhZGQgdGhlIHNwZWNpZmllZCBZIHBhZGRpbmcuXG4gICAgLy9cbiAgICB5cGFkQ29tcGF0ID0gdHJ1ZTtcbiAgICB5cGFkID0gMC4xOyAvLyBhZGQgMTAlXG4gICAgY29uc3QgeVJhbmdlUGFkID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCd5UmFuZ2VQYWQnKTtcbiAgICBpZiAoeVJhbmdlUGFkICE9PSBudWxsKSB7XG4gICAgICB5cGFkQ29tcGF0ID0gZmFsc2U7XG4gICAgICAvLyBDb252ZXJ0IHBpeGVsIHBhZGRpbmcgdG8gcmF0aW9cbiAgICAgIHlwYWQgPSB5UmFuZ2VQYWQgLyB0aGlzLnBsb3R0ZXJfLmFyZWEuaDtcbiAgICB9XG5cbiAgICBpZiAoc2VyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgbm8gc2VyaWVzIGFyZSBkZWZpbmVkIG9yIHZpc2libGUgdGhlbiB1c2UgYSByZWFzb25hYmxlIGRlZmF1bHRcbiAgICAgIGF4aXMuZXh0cmVtZVJhbmdlID0gWzAsIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4dHJlbWVzIG9mIGV4dHJlbWVzLlxuICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTsgIC8vIGV4dHJlbWVzW3Nlcmllc1swXV1bMF07XG4gICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTsgIC8vIGV4dHJlbWVzW3Nlcmllc1swXV1bMV07XG4gICAgICB2YXIgZXh0cmVtZU1pblksIGV4dHJlbWVNYXhZO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyB0aGlzIHNraXBzIGludmlzaWJsZSBzZXJpZXNcbiAgICAgICAgaWYgKCFleHRyZW1lcy5oYXNPd25Qcm9wZXJ0eShzZXJpZXNbal0pKSBjb250aW51ZTtcblxuICAgICAgICAvLyBPbmx5IHVzZSB2YWxpZCBleHRyZW1lcyB0byBzdG9wIG51bGwgZGF0YSBzZXJpZXMnIGZyb20gY29ycnVwdGluZyB0aGUgc2NhbGUuXG4gICAgICAgIGV4dHJlbWVNaW5ZID0gZXh0cmVtZXNbc2VyaWVzW2pdXVswXTtcbiAgICAgICAgaWYgKGV4dHJlbWVNaW5ZICE9PSBudWxsKSB7XG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGV4dHJlbWVNaW5ZLCBtaW5ZKTtcbiAgICAgICAgfVxuICAgICAgICBleHRyZW1lTWF4WSA9IGV4dHJlbWVzW3Nlcmllc1tqXV1bMV07XG4gICAgICAgIGlmIChleHRyZW1lTWF4WSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChleHRyZW1lTWF4WSwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5jbHVkZSB6ZXJvIGlmIHJlcXVlc3RlZCBieSB0aGUgdXNlci5cbiAgICAgIGlmIChpbmNsdWRlWmVybyAmJiAhbG9nc2NhbGUpIHtcbiAgICAgICAgaWYgKG1pblkgPiAwKSBtaW5ZID0gMDtcbiAgICAgICAgaWYgKG1heFkgPCAwKSBtYXhZID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBzY2FsZSwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gWzAsIDFdIGZvciBzYWZldHkuXG4gICAgICBpZiAobWluWSA9PSBJbmZpbml0eSkgbWluWSA9IDA7XG4gICAgICBpZiAobWF4WSA9PSAtSW5maW5pdHkpIG1heFkgPSAxO1xuXG4gICAgICBzcGFuID0gbWF4WSAtIG1pblk7XG4gICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHdlIGhhdmUgbm8gc2Vuc2Ugb2Ygc2NhbGUsIGNlbnRlciBvbiB0aGUgc29sZSB2YWx1ZS5cbiAgICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICAgIGlmIChtYXhZICE9PSAwKSB7XG4gICAgICAgICAgc3BhbiA9IE1hdGguYWJzKG1heFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC4uLiBhbmQgaWYgdGhlIHNvbGUgdmFsdWUgaXMgemVybywgdXNlIHJhbmdlIDAtMS5cbiAgICAgICAgICBtYXhZID0gMTtcbiAgICAgICAgICBzcGFuID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4QXhpc1kgPSBtYXhZLCBtaW5BeGlzWSA9IG1pblk7XG4gICAgICBpZiAoeXBhZENvbXBhdCkge1xuICAgICAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgICAgICBtYXhBeGlzWSA9IG1heFkgKyB5cGFkICogc3BhbjtcbiAgICAgICAgICBtaW5BeGlzWSA9IG1pblk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4QXhpc1kgPSBtYXhZICsgeXBhZCAqIHNwYW47XG4gICAgICAgICAgbWluQXhpc1kgPSBtaW5ZIC0geXBhZCAqIHNwYW47XG5cbiAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBiZWhhdmlvcjogTW92ZSB0aGUgc3BhbiB0byBzdGFydCBvciBlbmQgYXQgemVybyBpZiBpdCdzXG4gICAgICAgICAgLy8gY2xvc2UgdG8gemVyby5cbiAgICAgICAgICBpZiAobWluQXhpc1kgPCAwICYmIG1pblkgPj0gMCkgbWluQXhpc1kgPSAwO1xuICAgICAgICAgIGlmIChtYXhBeGlzWSA+IDAgJiYgbWF4WSA8PSAwKSBtYXhBeGlzWSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF4aXMuZXh0cmVtZVJhbmdlID0gW21pbkF4aXNZLCBtYXhBeGlzWV07XG4gICAgfVxuICAgIGlmIChheGlzLnZhbHVlUmFuZ2UpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB1c2VyLXNldCB2YWx1ZSByYW5nZSBmb3IgdGhpcyBheGlzLlxuICAgICAgdmFyIHkwID0gaXNOdWxsVW5kZWZpbmVkT3JOYU4oYXhpcy52YWx1ZVJhbmdlWzBdKSA/IGF4aXMuZXh0cmVtZVJhbmdlWzBdIDogYXhpcy52YWx1ZVJhbmdlWzBdO1xuICAgICAgdmFyIHkxID0gaXNOdWxsVW5kZWZpbmVkT3JOYU4oYXhpcy52YWx1ZVJhbmdlWzFdKSA/IGF4aXMuZXh0cmVtZVJhbmdlWzFdIDogYXhpcy52YWx1ZVJhbmdlWzFdO1xuICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2UgPSBbeTAsIHkxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2UgPSBheGlzLmV4dHJlbWVSYW5nZTtcbiAgICB9XG4gICAgaWYgKCF5cGFkQ29tcGF0KSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIHlSYW5nZVBhZCwgYWRqdXN0IHRoZSB1cHBlci9sb3dlciBib3VuZHMgdG8gYWRkXG4gICAgICAvLyBwYWRkaW5nIHVubGVzcyB0aGUgdXNlciBoYXMgem9vbWVkL3Bhbm5lZCB0aGUgWSBheGlzIHJhbmdlLlxuICAgICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICAgIHkwID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICAgIHkxID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV07XG4gICAgICAgIHZhciB5MHBjdCA9IHlwYWQgLyAoMiAqIHlwYWQgLSAxKTtcbiAgICAgICAgdmFyIHkxcGN0ID0gKHlwYWQgLSAxKSAvICgyICogeXBhZCAtIDEpO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSA9IHV0aWxzLmxvZ1JhbmdlRnJhY3Rpb24oeTAsIHkxLCB5MHBjdCk7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdID0gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih5MCwgeTEsIHkxcGN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkwID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICAgIHkxID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV07XG4gICAgICAgIHNwYW4gPSB5MSAtIHkwO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSA9IHkwIC0gc3BhbiAqIHlwYWQ7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdID0geTEgKyBzcGFuICogeXBhZDtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmIChpbmRlcGVuZGVudFRpY2tzKSB7XG4gICAgICBheGlzLmluZGVwZW5kZW50VGlja3MgPSBpbmRlcGVuZGVudFRpY2tzO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3knICsgKGkgPyAnMicgOiAnJykpO1xuICAgICAgdmFyIHRpY2tlciA9IG9wdHMoJ3RpY2tlcicpO1xuICAgICAgYXhpcy50aWNrcyA9IHRpY2tlcihheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSxcbiAgICAgICAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0sXG4gICAgICAgICAgICAgIHRoaXMucGxvdHRlcl8uYXJlYS5oLFxuICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICB0aGlzKTtcbiAgICAgIC8vIERlZmluZSB0aGUgZmlyc3QgaW5kZXBlbmRlbnQgYXhpcyBhcyBwcmltYXJ5IGF4aXMuXG4gICAgICBpZiAoIXBfYXhpcykgcF9heGlzID0gYXhpcztcbiAgICB9XG4gIH1cbiAgaWYgKHBfYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgKFwiQ29uZmlndXJhdGlvbiBFcnJvcjogQXQgbGVhc3Qgb25lIGF4aXMgaGFzIHRvIGhhdmUgdGhlIFxcXCJpbmRlcGVuZGVudFRpY2tzXFxcIiBvcHRpb24gYWN0aXZhdGVkLlwiKTtcbiAgfVxuICAvLyBBZGQgdGlja3MuIEJ5IGRlZmF1bHQsIGFsbCBheGVzIGluaGVyaXQgdGhlIHRpY2sgcG9zaXRpb25zIG9mIHRoZVxuICAvLyBwcmltYXJ5IGF4aXMuIEhvd2V2ZXIsIGlmIGFuIGF4aXMgaXMgc3BlY2lmaWNhbGx5IG1hcmtlZCBhcyBoYXZpbmdcbiAgLy8gaW5kZXBlbmRlbnQgdGlja3MsIHRoZW4gdGhhdCBpcyBwZXJtaXNzaWJsZSBhcyB3ZWxsLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF4ZXM7IGkrKykge1xuICAgIHZhciBheGlzID0gdGhpcy5heGVzX1tpXTtcblxuICAgIGlmICghYXhpcy5pbmRlcGVuZGVudFRpY2tzKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoaSA/ICcyJyA6ICcnKSk7XG4gICAgICB2YXIgdGlja2VyID0gb3B0cygndGlja2VyJyk7XG4gICAgICB2YXIgcF90aWNrcyA9IHBfYXhpcy50aWNrcztcbiAgICAgIHZhciBwX3NjYWxlID0gcF9heGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSAtIHBfYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICB2YXIgc2NhbGUgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSAtIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgICAgdmFyIHRpY2tfdmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBfdGlja3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHlfZnJhYyA9IChwX3RpY2tzW2tdLnYgLSBwX2F4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdKSAvIHBfc2NhbGU7XG4gICAgICAgIHZhciB5X3ZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdICsgeV9mcmFjICogc2NhbGU7XG4gICAgICAgIHRpY2tfdmFsdWVzLnB1c2goeV92YWwpO1xuICAgICAgfVxuXG4gICAgICBheGlzLnRpY2tzID0gdGlja2VyKGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbG90dGVyXy5hcmVhLmgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tfdmFsdWVzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZWN0cyB0aGUgdHlwZSBvZiB0aGUgc3RyIChkYXRlIG9yIG51bWVyaWMpIGFuZCBzZXRzIHRoZSB2YXJpb3VzXG4gKiBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhpcy5hdHRyc18gYmFzZWQgb24gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBbiB4IHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZGV0ZWN0VHlwZUZyb21TdHJpbmdfID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBpc0RhdGUgPSBmYWxzZTtcbiAgdmFyIGRhc2hQb3MgPSBzdHIuaW5kZXhPZignLScpOyAgLy8gY291bGQgYmUgMjAwNi0wMS0wMSBfb3JfIDEuMGUtMlxuICBpZiAoKGRhc2hQb3MgPiAwICYmIChzdHJbZGFzaFBvcy0xXSAhPSAnZScgJiYgc3RyW2Rhc2hQb3MtMV0gIT0gJ0UnKSkgfHxcbiAgICAgIHN0ci5pbmRleE9mKCcvJykgPj0gMCB8fFxuICAgICAgaXNOYU4ocGFyc2VGbG9hdChzdHIpKSkge1xuICAgIGlzRGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PSA4ICYmIHN0ciA+ICcxOTcwMDEwMScgJiYgc3RyIDwgJzIwMzcxMjMxJykge1xuICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmUgc3VwcG9ydCBmb3IgdGhpcyBmb3JtYXQuXG4gICAgaXNEYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuc2V0WEF4aXNPcHRpb25zXyhpc0RhdGUpO1xufTtcblxuRHlncmFwaC5wcm90b3R5cGUuc2V0WEF4aXNPcHRpb25zXyA9IGZ1bmN0aW9uKGlzRGF0ZSkge1xuICBpZiAoaXNEYXRlKSB7XG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gdXRpbHMuZGF0ZVBhcnNlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG4gIH0gZWxzZSB7XG4gICAgLyoqIEBwcml2YXRlIChzaHV0IHVwLCBqc2RvYyEpICovXG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4gcGFyc2VGbG9hdCh4KTsgfTtcbiAgICAvLyBUT0RPKGRhbnZrKTogdXNlIER5Z3JhcGgubnVtYmVyVmFsdWVGb3JtYXR0ZXIgaGVyZT9cbiAgICAvKiogQHByaXZhdGUgKHNodXQgdXAsIGpzZG9jISkgKi9cbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3M7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlcjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGFyc2VzIGEgc3RyaW5nIGluIGEgc3BlY2lhbCBjc3YgZm9ybWF0LiAgV2UgZXhwZWN0IGEgY3N2IGZpbGUgd2hlcmUgZWFjaFxuICogbGluZSBpcyBhIGRhdGUgcG9pbnQsIGFuZCB0aGUgZmlyc3QgZmllbGQgaW4gZWFjaCBsaW5lIGlzIHRoZSBkYXRlIHN0cmluZy5cbiAqIFdlIGFsc28gZXhwZWN0IHRoYXQgYWxsIHJlbWFpbmluZyBmaWVsZHMgcmVwcmVzZW50IHNlcmllcy5cbiAqIGlmIHRoZSBlcnJvckJhcnMgYXR0cmlidXRlIGlzIHNldCwgdGhlbiBpbnRlcnByZXQgdGhlIGZpZWxkcyBhczpcbiAqIGRhdGUsIHNlcmllczEsIHN0ZGRldjEsIHNlcmllczIsIHN0ZGRldjIsIC4uLlxuICogQHBhcmFtIHtbT2JqZWN0XX0gZGF0YSBTZWUgYWJvdmUuXG4gKlxuICogQHJldHVybiBbT2JqZWN0XSBBbiBhcnJheSB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByb3cuIFRoZXNlIGVudHJpZXNcbiAqIGFyZSBhbiBhcnJheSBvZiBjZWxscyBpbiB0aGF0IHJvdy4gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBwYXJzZWQgeC12YWx1ZSBmb3JcbiAqIHRoZSByb3cuIFRoZSBzZWNvbmQsIHRoaXJkLCBldGMuIGFyZSB0aGUgeS12YWx1ZXMuIFRoZXNlIGNhbiB0YWtlIG9uIG9uZSBvZlxuICogdGhyZWUgZm9ybXMsIGRlcGVuZGluZyBvbiB0aGUgQ1NWIGFuZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxuICogMS4gbnVtZXJpYyB2YWx1ZVxuICogMi4gWyB2YWx1ZSwgc3RkZGV2IF1cbiAqIDMuIFsgbG93IHZhbHVlLCBjZW50ZXIgdmFsdWUsIGhpZ2ggdmFsdWUgXVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5wYXJzZUNTVl8gPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGxpbmVfZGVsaW1pdGVyID0gdXRpbHMuZGV0ZWN0TGluZURlbGltaXRlcihkYXRhKTtcbiAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdChsaW5lX2RlbGltaXRlciB8fCBcIlxcblwiKTtcbiAgdmFyIHZhbHMsIGo7XG5cbiAgLy8gVXNlIHRoZSBkZWZhdWx0IGRlbGltaXRlciBvciBmYWxsIGJhY2sgdG8gYSB0YWIgaWYgdGhhdCBtYWtlcyBzZW5zZS5cbiAgdmFyIGRlbGltID0gdGhpcy5nZXRTdHJpbmdPcHRpb24oJ2RlbGltaXRlcicpO1xuICBpZiAobGluZXNbMF0uaW5kZXhPZihkZWxpbSkgPT0gLTEgJiYgbGluZXNbMF0uaW5kZXhPZignXFx0JykgPj0gMCkge1xuICAgIGRlbGltID0gJ1xcdCc7XG4gIH1cblxuICB2YXIgc3RhcnQgPSAwO1xuICBpZiAoISgnbGFiZWxzJyBpbiB0aGlzLnVzZXJfYXR0cnNfKSkge1xuICAgIC8vIFVzZXIgaGFzbid0IGV4cGxpY2l0bHkgc2V0IGxhYmVscywgc28gdGhleSdyZSAocHJlc3VtYWJseSkgaW4gdGhlIENTVi5cbiAgICBzdGFydCA9IDE7XG4gICAgdGhpcy5hdHRyc18ubGFiZWxzID0gbGluZXNbMF0uc3BsaXQoZGVsaW0pOyAgLy8gTk9URTogX25vdF8gdXNlcl9hdHRyc18uXG4gICAgdGhpcy5hdHRyaWJ1dGVzXy5yZXBhcnNlU2VyaWVzKCk7XG4gIH1cbiAgdmFyIGxpbmVfbm8gPSAwO1xuXG4gIHZhciB4UGFyc2VyO1xuICB2YXIgZGVmYXVsdFBhcnNlclNldCA9IGZhbHNlOyAgLy8gYXR0ZW1wdCB0byBhdXRvLWRldGVjdCB4IHZhbHVlIHR5cGVcbiAgdmFyIGV4cGVjdGVkQ29scyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIikubGVuZ3RoO1xuICB2YXIgb3V0T2ZPcmRlciA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgbGluZV9ubyA9IGk7XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSBjb250aW51ZTsgIC8vIHNraXAgYmxhbmsgbGluZXNcbiAgICBpZiAobGluZVswXSA9PSAnIycpIGNvbnRpbnVlOyAgICAvLyBza2lwIGNvbW1lbnQgbGluZXNcbiAgICB2YXIgaW5GaWVsZHMgPSBsaW5lLnNwbGl0KGRlbGltKTtcbiAgICBpZiAoaW5GaWVsZHMubGVuZ3RoIDwgMikgY29udGludWU7XG5cbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgaWYgKCFkZWZhdWx0UGFyc2VyU2V0KSB7XG4gICAgICB0aGlzLmRldGVjdFR5cGVGcm9tU3RyaW5nXyhpbkZpZWxkc1swXSk7XG4gICAgICB4UGFyc2VyID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInhWYWx1ZVBhcnNlclwiKTtcbiAgICAgIGRlZmF1bHRQYXJzZXJTZXQgPSB0cnVlO1xuICAgIH1cbiAgICBmaWVsZHNbMF0gPSB4UGFyc2VyKGluRmllbGRzWzBdLCB0aGlzKTtcblxuICAgIC8vIElmIGZyYWN0aW9ucyBhcmUgZXhwZWN0ZWQsIHBhcnNlIHRoZSBudW1iZXJzIGFzIFwiQS9CXCJcbiAgICBpZiAodGhpcy5mcmFjdGlvbnNfKSB7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gVE9ETyhkYW52ayk6IGZpZ3VyZSBvdXQgYW4gYXBwcm9wcmlhdGUgd2F5IHRvIGZsYWcgcGFyc2UgZXJyb3JzLlxuICAgICAgICB2YWxzID0gaW5GaWVsZHNbal0uc3BsaXQoXCIvXCIpO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggIT0gMikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4cGVjdGVkIGZyYWN0aW9uYWwgXCJudW0vZGVuXCIgdmFsdWVzIGluIENTViBkYXRhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJidXQgZm91bmQgYSB2YWx1ZSAnXCIgKyBpbkZpZWxkc1tqXSArIFwiJyBvbiBsaW5lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgxICsgaSkgKyBcIiAoJ1wiICsgbGluZSArIFwiJykgd2hpY2ggaXMgbm90IG9mIHRoaXMgZm9ybS5cIik7XG4gICAgICAgICAgZmllbGRzW2pdID0gWzAsIDBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tqXSA9IFt1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzBdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8odmFsc1sxXSwgaSwgbGluZSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJlcnJvckJhcnNcIikpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvciBiYXJzLCB2YWx1ZXMgYXJlICh2YWx1ZSwgc3RkZGV2KSBwYWlyc1xuICAgICAgaWYgKGluRmllbGRzLmxlbmd0aCAlIDIgIT0gMSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeHBlY3RlZCBhbHRlcm5hdGluZyAodmFsdWUsIHN0ZGV2LikgcGFpcnMgaW4gQ1NWIGRhdGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2J1dCBsaW5lICcgKyAoMSArIGkpICsgJyBoYXMgYW4gb2RkIG51bWJlciBvZiB2YWx1ZXMgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgIChpbkZpZWxkcy5sZW5ndGggLSAxKSArIFwiKTogJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDE7IGogPCBpbkZpZWxkcy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICBmaWVsZHNbKGogKyAxKSAvIDJdID0gW3V0aWxzLnBhcnNlRmxvYXRfKGluRmllbGRzW2pdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wYXJzZUZsb2F0XyhpbkZpZWxkc1tqICsgMV0sIGksIGxpbmUpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImN1c3RvbUJhcnNcIikpIHtcbiAgICAgIC8vIEJhcnMgYXJlIGEgbG93O2NlbnRlcjtoaWdoIHR1cGxlXG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHZhbCA9IGluRmllbGRzW2pdO1xuICAgICAgICBpZiAoL14gKiQvLnRlc3QodmFsKSkge1xuICAgICAgICAgIGZpZWxkc1tqXSA9IFtudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxzID0gdmFsLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZmllbGRzW2pdID0gWyB1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzBdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8odmFsc1sxXSwgaSwgbGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMl0sIGksIGxpbmUpIF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2hlbiB1c2luZyBjdXN0b21CYXJzLCB2YWx1ZXMgbXVzdCBiZSBlaXRoZXIgYmxhbmsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ29yIFwibG93O2NlbnRlcjtoaWdoXCIgdHVwbGVzIChnb3QgXCInICsgdmFsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgb24gbGluZSAnICsgKDEraSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWx1ZXMgYXJlIGp1c3QgbnVtYmVyc1xuICAgICAgZm9yIChqID0gMTsgaiA8IGluRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZpZWxkc1tqXSA9IHV0aWxzLnBhcnNlRmxvYXRfKGluRmllbGRzW2pdLCBpLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldC5sZW5ndGggPiAwICYmIGZpZWxkc1swXSA8IHJldFtyZXQubGVuZ3RoIC0gMV1bMF0pIHtcbiAgICAgIG91dE9mT3JkZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmaWVsZHMubGVuZ3RoICE9IGV4cGVjdGVkQ29scykge1xuICAgICAgY29uc29sZS5lcnJvcihcIk51bWJlciBvZiBjb2x1bW5zIGluIGxpbmUgXCIgKyBpICsgXCIgKFwiICsgZmllbGRzLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBkb2VzIG5vdCBhZ3JlZSB3aXRoIG51bWJlciBvZiBsYWJlbHMgKFwiICsgZXhwZWN0ZWRDb2xzICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIFwiICsgbGluZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIHRoZSAnbGFiZWxzJyBvcHRpb24gYW5kIG5vbmUgb2YgdGhlIGNlbGxzIG9mIHRoZVxuICAgIC8vIGZpcnN0IHJvdyBwYXJzZWQgY29ycmVjdGx5LCB0aGVuIHRoZXkgcHJvYmFibHkgZG91YmxlLXNwZWNpZmllZCB0aGVcbiAgICAvLyBsYWJlbHMuIFdlIGdvIHdpdGggdGhlIHZhbHVlcyBzZXQgaW4gdGhlIG9wdGlvbiwgZGlzY2FyZCB0aGlzIHJvdyBhbmRcbiAgICAvLyBsb2cgYSB3YXJuaW5nIHRvIHRoZSBKUyBjb25zb2xlLlxuICAgIGlmIChpID09PSAwICYmIHRoaXMuYXR0cl8oJ2xhYmVscycpKSB7XG4gICAgICB2YXIgYWxsX251bGwgPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgYWxsX251bGwgJiYgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoZmllbGRzW2pdKSBhbGxfbnVsbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGFsbF9udWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBkeWdyYXBocyAnbGFiZWxzJyBvcHRpb24gaXMgc2V0LCBidXQgdGhlIGZpcnN0IHJvdyBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcIm9mIENTViBkYXRhICgnXCIgKyBsaW5lICsgXCInKSBhcHBlYXJzIHRvIGFsc28gY29udGFpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcImxhYmVscy4gV2lsbCBkcm9wIHRoZSBDU1YgbGFiZWxzIGFuZCB1c2UgdGhlIG9wdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcImxhYmVscy5cIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXQucHVzaChmaWVsZHMpO1xuICB9XG5cbiAgaWYgKG91dE9mT3JkZXIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDU1YgaXMgb3V0IG9mIG9yZGVyOyBvcmRlciBpdCBjb3JyZWN0bHkgdG8gc3BlZWQgbG9hZGluZy5cIik7XG4gICAgcmV0LnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gSW4gbmF0aXZlIGZvcm1hdCwgYWxsIHZhbHVlcyBtdXN0IGJlIGRhdGVzIG9yIG51bWJlcnMuXG4vLyBUaGlzIGNoZWNrIGlzbid0IHBlcmZlY3QgYnV0IHdpbGwgY2F0Y2ggbW9zdCBtaXN0YWtlbiB1c2VzIG9mIHN0cmluZ3MuXG5mdW5jdGlvbiB2YWxpZGF0ZU5hdGl2ZUZvcm1hdChkYXRhKSB7XG4gIGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcbiAgY29uc3QgZmlyc3RYID0gZmlyc3RSb3dbMF07XG4gIGlmICh0eXBlb2YgZmlyc3RYICE9PSAnbnVtYmVyJyAmJiAhdXRpbHMuaXNEYXRlTGlrZShmaXJzdFgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBudW1iZXIgb3IgZGF0ZSBidXQgZ290ICR7dHlwZW9mIGZpcnN0WH06ICR7Zmlyc3RYfS5gKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGZpcnN0Um93Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsID0gZmlyc3RSb3dbaV07XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSBjb250aW51ZTtcbiAgICBpZiAodXRpbHMuaXNBcnJheUxpa2UodmFsKSkgY29udGludWU7ICAvLyBlLmcuIGVycm9yIGJhcnMgb3IgY3VzdG9tIGJhcnMuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBudW1iZXIgb3IgYXJyYXkgYnV0IGdvdCAke3R5cGVvZiB2YWx9OiAke3ZhbH0uYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdXNlciBoYXMgcHJvdmlkZWQgdGhlaXIgZGF0YSBhcyBhIHByZS1wYWNrYWdlZCBKUyBhcnJheS4gSWYgdGhlIHggdmFsdWVzXG4gKiBhcmUgbnVtZXJpYywgdGhpcyBpcyB0aGUgc2FtZSBhcyBkeWdyYXBocycgaW50ZXJuYWwgZm9ybWF0LiBJZiB0aGUgeCB2YWx1ZXNcbiAqIGFyZSBkYXRlcywgd2UgbmVlZCB0byBjb252ZXJ0IHRoZW0gZnJvbSBEYXRlIG9iamVjdHMgdG8gbXMgc2luY2UgZXBvY2guXG4gKiBAcGFyYW0geyFBcnJheX0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fSBkYXRhIHdpdGggbnVtZXJpYyB4IHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnBhcnNlQXJyYXlfID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyBQZWVrIGF0IHRoZSBmaXJzdCB4IHZhbHVlIHRvIHNlZSBpZiBpdCdzIG51bWVyaWMuXG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDYW4ndCBwbG90IGVtcHR5IGRhdGEgc2V0XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChkYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhIHNldCBjYW5ub3QgY29udGFpbiBhbiBlbXB0eSByb3dcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YWxpZGF0ZU5hdGl2ZUZvcm1hdChkYXRhKTtcblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuYXR0cl8oXCJsYWJlbHNcIikgPT09IG51bGwpIHtcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IGxhYmVscy4gU2V0IGxhYmVscyBleHBsaWNpdGx5IHZpYSAnbGFiZWxzJyBcIiArXG4gICAgICAgICAgICAgICAgIFwiaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyXCIpO1xuICAgIHRoaXMuYXR0cnNfLmxhYmVscyA9IFsgXCJYXCIgXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgZGF0YVswXS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hdHRyc18ubGFiZWxzLnB1c2goXCJZXCIgKyBpKTsgLy8gTm90IHVzZXJfYXR0cnNfLlxuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZXNfLnJlcGFyc2VTZXJpZXMoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnVtX2xhYmVscyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIik7XG4gICAgaWYgKG51bV9sYWJlbHMubGVuZ3RoICE9IGRhdGFbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzbWF0Y2ggYmV0d2VlbiBudW1iZXIgb2YgbGFiZWxzIChcIiArIG51bV9sYWJlbHMgKyBcIilcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIGFuZCBudW1iZXIgb2YgY29sdW1ucyBpbiBhcnJheSAoXCIgKyBkYXRhWzBdLmxlbmd0aCArIFwiKVwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1dGlscy5pc0RhdGVMaWtlKGRhdGFbMF1bMF0pKSB7XG4gICAgLy8gU29tZSBpbnRlbGxpZ2VudCBkZWZhdWx0cyBmb3IgYSBkYXRlIHgtYXhpcy5cbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG5cbiAgICAvLyBBc3N1bWUgdGhleSdyZSBhbGwgZGF0ZXMuXG4gICAgdmFyIHBhcnNlZERhdGEgPSB1dGlscy5jbG9uZShkYXRhKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcnNlZERhdGFbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSb3cgXCIgKyAoMSArIGkpICsgXCIgb2YgZGF0YSBpcyBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkRGF0YVtpXVswXSA9PT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZihwYXJzZWREYXRhW2ldWzBdLmdldFRpbWUpICE9ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICBpc05hTihwYXJzZWREYXRhW2ldWzBdLmdldFRpbWUoKSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcInggdmFsdWUgaW4gcm93IFwiICsgKDEgKyBpKSArIFwiIGlzIG5vdCBhIERhdGVcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcGFyc2VkRGF0YVtpXVswXSA9IHBhcnNlZERhdGFbaV1bMF0uZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTb21lIGludGVsbGlnZW50IGRlZmF1bHRzIGZvciBhIG51bWVyaWMgeC1heGlzLlxuICAgIC8qKiBAcHJpdmF0ZSAoc2h1dCB1cCwganNkb2MhKSAqL1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMubnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIERhdGFUYWJsZSBvYmplY3QgZnJvbSBndml6LlxuICogVGhlIGRhdGEgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGZpcnN0IGNvbHVtbiB0aGF0IGlzIGVpdGhlciBhIGRhdGUgb3IgYVxuICogbnVtYmVyLiBBbGwgc3Vic2VxdWVudCBjb2x1bW5zIG11c3QgYmUgbnVtYmVycy4gSWYgdGhlcmUgaXMgYSBjbGVhciBtaXNtYXRjaFxuICogYmV0d2VlbiB0aGlzLnhWYWx1ZVBhcnNlcl8gYW5kIHRoZSB0eXBlIG9mIHRoZSBmaXJzdCBjb2x1bW4sIGl0IHdpbGwgYmVcbiAqIGZpeGVkLiBGaWxscyBvdXQgcmF3RGF0YV8uXG4gKiBAcGFyYW0geyFnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGV9IGRhdGEgU2VlIGFib3ZlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucGFyc2VEYXRhVGFibGVfID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgc2hvcnRUZXh0Rm9yQW5ub3RhdGlvbk51bSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIC8vIGNvbnZlcnRzIFswLTldKyBbQS1aXVthLXpdKlxuICAgIC8vIGV4YW1wbGU6IDA9QSwgMT1CLCAyNT1aLCAyNj1BYSwgMjc9QWJcbiAgICAvLyBhbmQgY29udGludWVzIGxpa2UuLiBCYSBCYiAuLiBaYSAuLiBaei4uQWFhLi4uWnp6IEFhYWEgWnp6elxuICAgIHZhciBzaG9ydFRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIEEgKi8gKyBudW0gJSAyNik7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAyNik7XG4gICAgd2hpbGUgKCBudW0gPiAwICkge1xuICAgICAgc2hvcnRUZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSAvKiBBICovICsgKG51bSAtIDEpICUgMjYgKSArIHNob3J0VGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgbnVtID0gTWF0aC5mbG9vcigobnVtIC0gMSkgLyAyNik7XG4gICAgfVxuICAgIHJldHVybiBzaG9ydFRleHQ7XG4gIH07XG5cbiAgdmFyIGNvbHMgPSBkYXRhLmdldE51bWJlck9mQ29sdW1ucygpO1xuICB2YXIgcm93cyA9IGRhdGEuZ2V0TnVtYmVyT2ZSb3dzKCk7XG5cbiAgdmFyIGluZGVwVHlwZSA9IGRhdGEuZ2V0Q29sdW1uVHlwZSgwKTtcbiAgaWYgKGluZGVwVHlwZSA9PSAnZGF0ZScgfHwgaW5kZXBUeXBlID09ICdkYXRldGltZScpIHtcbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSB1dGlscy5kYXRlUGFyc2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcbiAgfSBlbHNlIGlmIChpbmRlcFR5cGUgPT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUZsb2F0KHgpOyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIm9ubHkgJ2RhdGUnLCAnZGF0ZXRpbWUnIGFuZCAnbnVtYmVyJyB0eXBlcyBhcmUgc3VwcG9ydGVkIFwiICtcbiAgICAgICAgICBcImZvciBjb2x1bW4gMSBvZiBEYXRhVGFibGUgaW5wdXQgKEdvdCAnXCIgKyBpbmRlcFR5cGUgKyBcIicpXCIpO1xuICB9XG5cbiAgLy8gQXJyYXkgb2YgdGhlIGNvbHVtbiBpbmRpY2VzIHdoaWNoIGNvbnRhaW4gZGF0YSAoYW5kIG5vdCBhbm5vdGF0aW9ucykuXG4gIHZhciBjb2xJZHggPSBbXTtcbiAgdmFyIGFubm90YXRpb25Db2xzID0ge307ICAvLyBkYXRhIGluZGV4IC0+IFthbm5vdGF0aW9uIGNvbHNdXG4gIHZhciBoYXNBbm5vdGF0aW9ucyA9IGZhbHNlO1xuICB2YXIgaSwgajtcbiAgZm9yIChpID0gMTsgaSA8IGNvbHM7IGkrKykge1xuICAgIHZhciB0eXBlID0gZGF0YS5nZXRDb2x1bW5UeXBlKGkpO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgICBjb2xJZHgucHVzaChpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycgJiYgdGhpcy5nZXRCb29sZWFuT3B0aW9uKCdkaXNwbGF5QW5ub3RhdGlvbnMnKSkge1xuICAgICAgLy8gVGhpcyBpcyBPSyAtLSBpdCdzIGFuIGFubm90YXRpb24gY29sdW1uLlxuICAgICAgdmFyIGRhdGFJZHggPSBjb2xJZHhbY29sSWR4Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFhbm5vdGF0aW9uQ29scy5oYXNPd25Qcm9wZXJ0eShkYXRhSWR4KSkge1xuICAgICAgICBhbm5vdGF0aW9uQ29sc1tkYXRhSWR4XSA9IFtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFubm90YXRpb25Db2xzW2RhdGFJZHhdLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBoYXNBbm5vdGF0aW9ucyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIk9ubHkgJ251bWJlcicgaXMgc3VwcG9ydGVkIGFzIGEgZGVwZW5kZW50IHR5cGUgd2l0aCBHdml6LlwiICtcbiAgICAgICAgICBcIiAnc3RyaW5nJyBpcyBvbmx5IHN1cHBvcnRlZCBpZiBkaXNwbGF5QW5ub3RhdGlvbnMgaXMgdHJ1ZVwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGNvbHVtbiBsYWJlbHNcbiAgLy8gVE9ETyhkYW52ayk6IGFkZCBzdXBwb3J0IGJhY2sgZm9yIGVycm9yQmFyc1xuICB2YXIgbGFiZWxzID0gW2RhdGEuZ2V0Q29sdW1uTGFiZWwoMCldO1xuICBmb3IgKGkgPSAwOyBpIDwgY29sSWR4Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWxzLnB1c2goZGF0YS5nZXRDb2x1bW5MYWJlbChjb2xJZHhbaV0pKTtcbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpKSBpICs9IDE7XG4gIH1cbiAgdGhpcy5hdHRyc18ubGFiZWxzID0gbGFiZWxzO1xuICBjb2xzID0gbGFiZWxzLmxlbmd0aDtcblxuICB2YXIgcmV0ID0gW107XG4gIHZhciBvdXRPZk9yZGVyID0gZmFsc2U7XG4gIHZhciBhbm5vdGF0aW9ucyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIGlmICh0eXBlb2YoZGF0YS5nZXRWYWx1ZShpLCAwKSkgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGRhdGEuZ2V0VmFsdWUoaSwgMCkgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIklnbm9yaW5nIHJvdyBcIiArIGkgK1xuICAgICAgICAgICAgICAgICAgIFwiIG9mIERhdGFUYWJsZSBiZWNhdXNlIG9mIHVuZGVmaW5lZCBvciBudWxsIGZpcnN0IGNvbHVtbi5cIik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXBUeXBlID09ICdkYXRlJyB8fCBpbmRlcFR5cGUgPT0gJ2RhdGV0aW1lJykge1xuICAgICAgcm93LnB1c2goZGF0YS5nZXRWYWx1ZShpLCAwKS5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3cucHVzaChkYXRhLmdldFZhbHVlKGksIDApKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJlcnJvckJhcnNcIikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2xJZHgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNvbCA9IGNvbElkeFtqXTtcbiAgICAgICAgcm93LnB1c2goZGF0YS5nZXRWYWx1ZShpLCBjb2wpKTtcbiAgICAgICAgaWYgKGhhc0Fubm90YXRpb25zICYmXG4gICAgICAgICAgICBhbm5vdGF0aW9uQ29scy5oYXNPd25Qcm9wZXJ0eShjb2wpICYmXG4gICAgICAgICAgICBkYXRhLmdldFZhbHVlKGksIGFubm90YXRpb25Db2xzW2NvbF1bMF0pICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGFubiA9IHt9O1xuICAgICAgICAgIGFubi5zZXJpZXMgPSBkYXRhLmdldENvbHVtbkxhYmVsKGNvbCk7XG4gICAgICAgICAgYW5uLnh2YWwgPSByb3dbMF07XG4gICAgICAgICAgYW5uLnNob3J0VGV4dCA9IHNob3J0VGV4dEZvckFubm90YXRpb25OdW0oYW5ub3RhdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICBhbm4udGV4dCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYW5ub3RhdGlvbkNvbHNbY29sXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGspIGFubi50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBhbm4udGV4dCArPSBkYXRhLmdldFZhbHVlKGksIGFubm90YXRpb25Db2xzW2NvbF1ba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3RyaXAgb3V0IGluZmluaXRpZXMsIHdoaWNoIGdpdmUgZHlncmFwaHMgcHJvYmxlbXMgbGF0ZXIgb24uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUocm93W2pdKSkgcm93W2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHMgLSAxOyBqKyspIHtcbiAgICAgICAgcm93LnB1c2goWyBkYXRhLmdldFZhbHVlKGksIDEgKyAyICogaiksIGRhdGEuZ2V0VmFsdWUoaSwgMiArIDIgKiBqKSBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldC5sZW5ndGggPiAwICYmIHJvd1swXSA8IHJldFtyZXQubGVuZ3RoIC0gMV1bMF0pIHtcbiAgICAgIG91dE9mT3JkZXIgPSB0cnVlO1xuICAgIH1cbiAgICByZXQucHVzaChyb3cpO1xuICB9XG5cbiAgaWYgKG91dE9mT3JkZXIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJEYXRhVGFibGUgaXMgb3V0IG9mIG9yZGVyOyBvcmRlciBpdCBjb3JyZWN0bHkgdG8gc3BlZWQgbG9hZGluZy5cIik7XG4gICAgcmV0LnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gIH1cbiAgdGhpcy5yYXdEYXRhXyA9IHJldDtcblxuICBpZiAoYW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuc2V0QW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMsIHRydWUpO1xuICB9XG4gIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xufTtcblxuLyoqXG4gKiBTaWduYWxzIHRvIHBsdWdpbnMgdGhhdCB0aGUgY2hhcnQgZGF0YSBoYXMgdXBkYXRlZC5cbiAqIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZGF0YSBoYXMgdXBkYXRlZCBidXQgYmVmb3JlIHRoZSBjaGFydCBoYXMgcmVkcmF3bi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNhc2NhZGVEYXRhRGlkVXBkYXRlRXZlbnRfID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8oZGFudmspOiB0aGVyZSBhcmUgc29tZSBpc3N1ZXMgY2hlY2tpbmcgeEF4aXNSYW5nZSgpIGFuZCB1c2luZ1xuICAvLyB0b0RvbUNvb3JkcyBmcm9tIGhhbmRsZXJzIG9mIHRoaXMgZXZlbnQuIFRoZSB2aXNpYmxlIHJhbmdlIHNob3VsZCBiZSBzZXRcbiAgLy8gd2hlbiB0aGUgY2hhcnQgaXMgZHJhd24sIG5vdCBkZXJpdmVkIGZyb20gdGhlIGRhdGEuXG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2RhdGFEaWRVcGRhdGUnLCB7fSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQ1NWIGRhdGEuIElmIGl0J3MgaW4gYSBmdW5jdGlvbiwgY2FsbCB0aGF0IGZ1bmN0aW9uLiBJZiBpdCdzIGluIGFcbiAqIGZpbGUsIGRvIGFuIFhNTEh0dHBSZXF1ZXN0IHRvIGdldCBpdC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnN0YXJ0XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IHRoaXMuZmlsZV87XG5cbiAgLy8gRnVuY3Rpb25zIGNhbiByZXR1cm4gcmVmZXJlbmNlcyBvZiBhbGwgb3RoZXIgdHlwZXMuXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YSA9IGRhdGEoKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0FycmF5TGlrZShkYXRhKSkge1xuICAgIHRoaXMucmF3RGF0YV8gPSB0aGlzLnBhcnNlQXJyYXlfKGRhdGEpO1xuICAgIHRoaXMuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8oKTtcbiAgICB0aGlzLnByZWRyYXdfKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICB0eXBlb2YgZGF0YS5nZXRDb2x1bW5SYW5nZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gbXVzdCBiZSBhIERhdGFUYWJsZSBmcm9tIGd2aXouXG4gICAgdGhpcy5wYXJzZURhdGFUYWJsZV8oZGF0YSk7XG4gICAgdGhpcy5jYXNjYWRlRGF0YURpZFVwZGF0ZUV2ZW50XygpO1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIC8vIEhldXJpc3RpYzogYSBuZXdsaW5lIG1lYW5zIGl0J3MgQ1NWIGRhdGEuIE90aGVyd2lzZSBpdCdzIGFuIFVSTC5cbiAgICB2YXIgbGluZV9kZWxpbWl0ZXIgPSB1dGlscy5kZXRlY3RMaW5lRGVsaW1pdGVyKGRhdGEpO1xuICAgIGlmIChsaW5lX2RlbGltaXRlcikge1xuICAgICAgdGhpcy5sb2FkZWRFdmVudF8oZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJFTU9WRV9GT1JfSUVcbiAgICAgIHZhciByZXE7XG4gICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIEZpcmVmb3gsIE9wZXJhLCBJRTcsIGFuZCBvdGhlciBicm93c2VycyB3aWxsIHVzZSB0aGUgbmF0aXZlIG9iamVjdFxuICAgICAgICByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElFIDUgYW5kIDYgd2lsbCB1c2UgdGhlIEFjdGl2ZVggY29udHJvbFxuICAgICAgICByZXEgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FsbGVyID0gdGhpcztcbiAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCB8fCAgLy8gTm9ybWFsIGh0dHBcbiAgICAgICAgICAgICAgcmVxLnN0YXR1cyA9PT0gMCkgeyAgICAvLyBDaHJvbWUgdy8gLS1hbGxvdy1maWxlLWFjY2Vzcy1mcm9tLWZpbGVzXG4gICAgICAgICAgICBjYWxsZXIubG9hZGVkRXZlbnRfKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgZGF0YSwgdHJ1ZSk7XG4gICAgICByZXEuc2VuZChudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVua25vd24gZGF0YSBmb3JtYXQ6IFwiICsgKHR5cGVvZiBkYXRhKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlcyB2YXJpb3VzIHByb3BlcnRpZXMgb2YgdGhlIGdyYXBoLiBUaGVzZSBjYW4gaW5jbHVkZTpcbiAqIDx1bD5cbiAqIDxsaT5maWxlOiBjaGFuZ2VzIHRoZSBzb3VyY2UgZGF0YSBmb3IgdGhlIGdyYXBoPC9saT5cbiAqIDxsaT5lcnJvckJhcnM6IGNoYW5nZXMgd2hldGhlciB0aGUgZGF0YSBjb250YWlucyBzdGRkZXY8L2xpPlxuICogPC91bD5cbiAqXG4gKiBUaGVyZSdzIGEgaHVnZSB2YXJpZXR5IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLiBGb3IgYVxuICogZnVsbCBsaXN0LCBzZWUgaHR0cDovL2R5Z3JhcGhzLmNvbS9vcHRpb25zLmh0bWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0X2F0dHJzIFRoZSBuZXcgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJsb2NrX3JlZHJhdyBVc3VhbGx5IHRoZSBjaGFydCBpcyByZWRyYXduIGFmdGVyIGV2ZXJ5XG4gKiAgICAgY2FsbCB0byB1cGRhdGVPcHRpb25zKCkuIElmIHlvdSBrbm93IGJldHRlciwgeW91IGNhbiBwYXNzIHRydWUgdG9cbiAqICAgICBleHBsaWNpdGx5IGJsb2NrIHRoZSByZWRyYXcuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgY2hhaW5pbmdcbiAqICAgICB1cGRhdGVPcHRpb25zKCkgY2FsbHMsIGF2b2lkaW5nIHRoZSBvY2Nhc2lvbmFsIGluZmluaXRlIGxvb3AgYW5kXG4gKiAgICAgcHJldmVudGluZyByZWRyYXdzIHdoZW4gaXQncyBub3QgbmVjZXNzYXJ5IChlLmcuIHdoZW4gdXBkYXRpbmcgYVxuICogICAgIGNhbGxiYWNrKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKGlucHV0X2F0dHJzLCBibG9ja19yZWRyYXcpIHtcbiAgaWYgKHR5cGVvZihibG9ja19yZWRyYXcpID09ICd1bmRlZmluZWQnKSBibG9ja19yZWRyYXcgPSBmYWxzZTtcblxuICAvLyBjb3B5VXNlckF0dHJzXyBkcm9wcyB0aGUgXCJmaWxlXCIgcGFyYW1ldGVyIGFzIGEgY29udmVuaWVuY2UgdG8gdXMuXG4gIHZhciBmaWxlID0gaW5wdXRfYXR0cnMuZmlsZTtcbiAgdmFyIGF0dHJzID0gRHlncmFwaC5jb3B5VXNlckF0dHJzXyhpbnB1dF9hdHRycyk7XG5cbiAgLy8gVE9ETyhkYW52ayk6IHRoaXMgaXMgYSBtZXNzLiBNb3ZlIHRoZXNlIG9wdGlvbnMgaW50byBhdHRyXy5cbiAgaWYgKCdyb2xsUGVyaW9kJyBpbiBhdHRycykge1xuICAgIHRoaXMucm9sbFBlcmlvZF8gPSBhdHRycy5yb2xsUGVyaW9kO1xuICB9XG4gIGlmICgnZGF0ZVdpbmRvdycgaW4gYXR0cnMpIHtcbiAgICB0aGlzLmRhdGVXaW5kb3dfID0gYXR0cnMuZGF0ZVdpbmRvdztcbiAgfVxuXG4gIC8vIFRPRE8oZGFudmspOiB2YWxpZGF0ZSBwZXItc2VyaWVzIG9wdGlvbnMuXG4gIC8vIFN1cHBvcnRlZDpcbiAgLy8gc3Ryb2tlV2lkdGhcbiAgLy8gcG9pbnRTaXplXG4gIC8vIGRyYXdQb2ludHNcbiAgLy8gaGlnaGxpZ2h0Q2lyY2xlU2l6ZVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgc2V0IG9wdGlvbnMgd2lsbCByZXF1aXJlIG5ldyBwb2ludHMuXG4gIHZhciByZXF1aXJlc05ld1BvaW50cyA9IHV0aWxzLmlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QodGhpcy5hdHRyXyhcImxhYmVsc1wiKSwgYXR0cnMpO1xuXG4gIHV0aWxzLnVwZGF0ZURlZXAodGhpcy51c2VyX2F0dHJzXywgYXR0cnMpO1xuXG4gIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xuXG4gIGlmIChmaWxlKSB7XG4gICAgLy8gVGhpcyBldmVudCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBhYm91dCB0byBjaGFuZ2UsIGJ1dCBoYXNuJ3QgeWV0LlxuICAgIC8vIFRPRE8oZGFudmspOiBzdXBwb3J0IGNhbmNlbGxhdGlvbiBvZiB0aGUgdXBkYXRlIHZpYSB0aGlzIGV2ZW50LlxuICAgIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2RhdGFXaWxsVXBkYXRlJywge30pO1xuXG4gICAgdGhpcy5maWxlXyA9IGZpbGU7XG4gICAgaWYgKCFibG9ja19yZWRyYXcpIHRoaXMuc3RhcnRfKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFibG9ja19yZWRyYXcpIHtcbiAgICAgIGlmIChyZXF1aXJlc05ld1BvaW50cykge1xuICAgICAgICB0aGlzLnByZWRyYXdfKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlckdyYXBoXyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBjb3B5IG9mIGlucHV0IGF0dHJpYnV0ZXMsIHJlbW92aW5nIGZpbGUgYXMgYSBjb252ZW5pZW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGguY29weVVzZXJBdHRyc18gPSBmdW5jdGlvbihhdHRycykge1xuICB2YXIgbXlfYXR0cnMgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBhdHRycykge1xuICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkoaykpIGNvbnRpbnVlO1xuICAgIGlmIChrID09ICdmaWxlJykgY29udGludWU7XG4gICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGspKSBteV9hdHRyc1trXSA9IGF0dHJzW2tdO1xuICB9XG4gIHJldHVybiBteV9hdHRycztcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgZHlncmFwaC4gSWYgbm8gcGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkLCByZXNpemVzIHRvIGZpbGwgdGhlXG4gKiBjb250YWluaW5nIGRpdiAod2hpY2ggaGFzIHByZXN1bWFibHkgY2hhbmdlZCBzaXplIHNpbmNlIHRoZSBkeWdyYXBoIHdhc1xuICogaW5zdGFudGlhdGVkLiBJZiB0aGUgd2lkdGgvaGVpZ2h0IGFyZSBzcGVjaWZpZWQsIHRoZSBkaXYgd2lsbCBiZSByZXNpemVkLlxuICpcbiAqIFRoaXMgaXMgZmFyIG1vcmUgZWZmaWNpZW50IHRoYW4gZGVzdHJveWluZyBhbmQgcmUtaW5zdGFudGlhdGluZyBhXG4gKiBEeWdyYXBoLCBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gcmVwYXJzZSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCAoaW4gcGl4ZWxzKVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgKGluIHBpeGVscylcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICBpZiAodGhpcy5yZXNpemVfbG9jaykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlc2l6ZV9sb2NrID0gdHJ1ZTtcblxuICBpZiAoKHdpZHRoID09PSBudWxsKSAhPSAoaGVpZ2h0ID09PSBudWxsKSkge1xuICAgIGNvbnNvbGUud2FybihcIkR5Z3JhcGgucmVzaXplKCkgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHplcm8gcGFyYW1ldGVycyBvciBcIiArXG4gICAgICAgICAgICAgICAgIFwidHdvIG5vbi1OVUxMIHBhcmFtZXRlcnMuIFByZXRlbmRpbmcgaXQgd2FzIHplcm8uXCIpO1xuICAgIHdpZHRoID0gaGVpZ2h0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvbGRfd2lkdGggPSB0aGlzLndpZHRoXztcbiAgdmFyIG9sZF9oZWlnaHQgPSB0aGlzLmhlaWdodF87XG5cbiAgaWYgKHdpZHRoKSB7XG4gICAgdGhpcy5tYWluZGl2Xy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIHRoaXMubWFpbmRpdl8uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIHRoaXMud2lkdGhfID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHRfID0gaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2lkdGhfID0gdGhpcy5tYWluZGl2Xy5jbGllbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodF8gPSB0aGlzLm1haW5kaXZfLmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIGlmIChvbGRfd2lkdGggIT0gdGhpcy53aWR0aF8gfHwgb2xkX2hlaWdodCAhPSB0aGlzLmhlaWdodF8pIHtcbiAgICAvLyBSZXNpemluZyBhIGNhbnZhcyBlcmFzZXMgaXQsIGV2ZW4gd2hlbiB0aGUgc2l6ZSBkb2Vzbid0IGNoYW5nZSwgc29cbiAgICAvLyBhbnkgcmVzaXplIG5lZWRzIHRvIGJlIGZvbGxvd2VkIGJ5IGEgcmVkcmF3LlxuICAgIHRoaXMucmVzaXplRWxlbWVudHNfKCk7XG4gICAgdGhpcy5wcmVkcmF3XygpO1xuICB9XG5cbiAgdGhpcy5yZXNpemVfbG9jayA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGp1c3RzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSByb2xsaW5nIGF2ZXJhZ2UuIFVwZGF0ZXMgdGhlIGdyYXBoIHRvXG4gKiByZWZsZWN0IHRoZSBuZXcgYXZlcmFnaW5nIHBlcmlvZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIHBvaW50cyBvdmVyIHdoaWNoIHRvIGF2ZXJhZ2UgdGhlIGRhdGEuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFkanVzdFJvbGwgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdGhpcy5yb2xsUGVyaW9kXyA9IGxlbmd0aDtcbiAgdGhpcy5wcmVkcmF3XygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBhcnJheSBvZiB2aXNpYmlsaXR5IHN0YXR1c2VzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS52aXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIERvIGxhenktaW5pdGlhbGl6YXRpb24sIHNvIHRoYXQgdGhpcyBoYXBwZW5zIGFmdGVyIHdlIGtub3cgdGhlIG51bWJlciBvZlxuICAvLyBkYXRhIHNlcmllcy5cbiAgaWYgKCF0aGlzLmdldE9wdGlvbihcInZpc2liaWxpdHlcIikpIHtcbiAgICB0aGlzLmF0dHJzXy52aXNpYmlsaXR5ID0gW107XG4gIH1cbiAgLy8gVE9ETyhkYW52ayk6IGl0IGxvb2tzIGxpa2UgdGhpcyBjb3VsZCBnbyBpbnRvIGFuIGluZmluaXRlIGxvb3Agdy8gdXNlcl9hdHRycy5cbiAgd2hpbGUgKHRoaXMuZ2V0T3B0aW9uKFwidmlzaWJpbGl0eVwiKS5sZW5ndGggPCB0aGlzLm51bUNvbHVtbnMoKSAtIDEpIHtcbiAgICB0aGlzLmF0dHJzXy52aXNpYmlsaXR5LnB1c2godHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwidmlzaWJpbGl0eVwiKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgdmlzaWJpbGl0eSBvZiBvbmUgb3IgbW9yZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW118b2JqZWN0fSBudW0gdGhlIHNlcmllcyBpbmRleCBvciBhbiBhcnJheSBvZiBzZXJpZXMgaW5kaWNlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBib29sZWFuIGFycmF5IG9mIHZpc2liaWxpdHkgc3RhdGVzIGJ5IGluZGV4XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhbiBvYmplY3QgbWFwcGluZyBzZXJpZXMgbnVtYmVycywgYXMga2V5cywgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgc3RhdGUgKGJvb2xlYW4gdmFsdWVzKVxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBleHByZXNzZWQgYXMgYSBib29sZWFuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNldFZpc2liaWxpdHkgPSBmdW5jdGlvbihudW0sIHZhbHVlKSB7XG4gIHZhciB4ID0gdGhpcy52aXNpYmlsaXR5KCk7XG4gIHZhciBudW1Jc09iamVjdCA9IGZhbHNlO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShudW0pKSB7XG4gICAgaWYgKG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0Jykge1xuICAgICAgbnVtSXNPYmplY3QgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW0gPSBbbnVtXTtcbiAgICB9XG4gIH1cblxuICBpZiAobnVtSXNPYmplY3QpIHtcbiAgICBmb3IgKHZhciBpIGluIG51bSkge1xuICAgICAgaWYgKG51bS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSB4Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc2VyaWVzIG51bWJlciBpbiBzZXRWaXNpYmlsaXR5OiBcIiArIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhbaV0gPSBudW1baV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgbnVtW2ldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGkgPj0geC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHNlcmllcyBudW1iZXIgaW4gc2V0VmlzaWJpbGl0eTogXCIgKyBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4W2ldID0gbnVtW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobnVtW2ldIDwgMCB8fCBudW1baV0gPj0geC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHNlcmllcyBudW1iZXIgaW4gc2V0VmlzaWJpbGl0eTogXCIgKyBudW1baV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhbbnVtW2ldXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcmVkcmF3XygpO1xufTtcblxuLyoqXG4gKiBIb3cgbGFyZ2Ugb2YgYW4gYXJlYSB3aWxsIHRoZSBkeWdyYXBoIHJlbmRlciBpdHNlbGYgaW4/XG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRlc3RpbmcuXG4gKiBAcmV0dXJuIEEge3dpZHRoOiB3LCBoZWlnaHQ6IGh9IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgd2lkdGg6IHRoaXMud2lkdGhfLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0XyB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGxpc3Qgb2YgYW5ub3RhdGlvbnMgYW5kIHJlZHJhdyB0aGUgY2hhcnQuXG4gKiBTZWUgZHlncmFwaHMuY29tL2Fubm90YXRpb25zLmh0bWwgZm9yIG1vcmUgaW5mbyBvbiBob3cgdG8gdXNlIGFubm90YXRpb25zLlxuICogQHBhcmFtIGFubiB7QXJyYXl9IEFuIGFycmF5IG9mIGFubm90YXRpb24gb2JqZWN0cy5cbiAqIEBwYXJhbSBzdXBwcmVzc0RyYXcge0Jvb2xlYW59IFNldCB0byBcInRydWVcIiB0byBibG9jayBjaGFydCByZWRyYXcgKG9wdGlvbmFsKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm4sIHN1cHByZXNzRHJhdykge1xuICAvLyBPbmx5IGFkZCB0aGUgYW5ub3RhdGlvbiBDU1MgcnVsZSBvbmNlIHdlIGtub3cgaXQgd2lsbCBiZSB1c2VkLlxuICB0aGlzLmFubm90YXRpb25zXyA9IGFubjtcbiAgaWYgKCF0aGlzLmxheW91dF8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byBzZXRBbm5vdGF0aW9ucyBiZWZvcmUgZHlncmFwaCB3YXMgcmVhZHkuIFwiICtcbiAgICAgICAgICAgICAgICAgXCJUcnkgc2V0dGluZyB0aGVtIGluIGEgcmVhZHkoKSBibG9jay4gU2VlIFwiICtcbiAgICAgICAgICAgICAgICAgXCJkeWdyYXBocy5jb20vdGVzdHMvYW5ub3RhdGlvbi5odG1sXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMubGF5b3V0Xy5zZXRBbm5vdGF0aW9ucyh0aGlzLmFubm90YXRpb25zXyk7XG4gIGlmICghc3VwcHJlc3NEcmF3KSB7XG4gICAgdGhpcy5wcmVkcmF3XygpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhbm5vdGF0aW9ucy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnNfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgbGFiZWwgbmFtZXMgZm9yIHRoaXMgZ3JhcGguIFRoZSBmaXJzdCBjb2x1bW4gaXMgdGhlXG4gKiB4LWF4aXMsIHNvIHRoZSBkYXRhIHNlcmllcyBuYW1lcyBzdGFydCBhdCBpbmRleCAxLlxuICpcbiAqIFJldHVybnMgbnVsbCB3aGVuIGxhYmVscyBoYXZlIG5vdCB5ZXQgYmVlbiBkZWZpbmVkLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRMYWJlbHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVscyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIik7XG4gIHJldHVybiBsYWJlbHMgPyBsYWJlbHMuc2xpY2UoKSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYSBzZXJpZXMgKGNvbHVtbikgZ2l2ZW4gaXRzIG5hbWUuIFRoZSBmaXJzdCBjb2x1bW4gaXMgdGhlXG4gKiB4LWF4aXMsIHNvIHRoZSBkYXRhIHNlcmllcyBzdGFydCB3aXRoIGluZGV4IDEuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmluZGV4RnJvbVNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnNldEluZGV4QnlOYW1lX1tuYW1lXTtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgcm93IG51bWJlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB4LXZhbHVlLlxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHN1Y2ggeC12YWx1ZSBpbiB0aGUgZGF0YS5cbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSByb3dzIHdpdGggdGhlIHNhbWUgeC12YWx1ZSwgdGhpcyB3aWxsIHJldHVybiB0aGVcbiAqIGZpcnN0IG9uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4VmFsIFRoZSB4LXZhbHVlIHRvIGxvb2sgZm9yIChlLmcuIG1pbGxpcyBzaW5jZSBlcG9jaCkuXG4gKiBAcmV0dXJuIHs/bnVtYmVyfSBUaGUgcm93IG51bWJlciwgd2hpY2ggeW91IGNhbiBwYXNzIHRvIGdldFZhbHVlKCksIG9yIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFJvd0ZvclggPSBmdW5jdGlvbih4VmFsKSB7XG4gIHZhciBsb3cgPSAwLFxuICAgICAgaGlnaCA9IHRoaXMubnVtUm93cygpIC0gMTtcblxuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICB2YXIgaWR4ID0gKGhpZ2ggKyBsb3cpID4+IDE7XG4gICAgdmFyIHggPSB0aGlzLmdldFZhbHVlKGlkeCwgMCk7XG4gICAgaWYgKHggPCB4VmFsKSB7XG4gICAgICBsb3cgPSBpZHggKyAxO1xuICAgIH0gZWxzZSBpZiAoeCA+IHhWYWwpIHtcbiAgICAgIGhpZ2ggPSBpZHggLSAxO1xuICAgIH0gZWxzZSBpZiAobG93ICE9IGlkeCkgeyAgLy8gZXF1YWwsIGJ1dCB0aGVyZSBtYXkgYmUgYW4gZWFybGllciBtYXRjaC5cbiAgICAgIGhpZ2ggPSBpZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYSBjYWxsYmFjayB3aGVuIHRoZSBkeWdyYXBoIGhhcyBkcmF3biBpdHNlbGYgYW5kIGlzIHJlYWR5IHRvIGJlXG4gKiBtYW5pcHVsYXRlZC4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIHdoZW4gZHlncmFwaHMgaGFzIHRvIGRvIGFuIFhIUiBmb3IgdGhlXG4gKiBkYXRhIChpLmUuIGEgVVJMIGlzIHBhc3NlZCBhcyB0aGUgZGF0YSBzb3VyY2UpIGFuZCB0aGUgY2hhcnQgaXMgZHJhd25cbiAqIGFzeW5jaHJvbm91c2x5LiBJZiB0aGUgY2hhcnQgaGFzIGFscmVhZHkgZHJhd24sIHRoZSBjYWxsYmFjayB3aWxsIGZpcmVcbiAqIGltbWVkaWF0ZWx5LlxuICpcbiAqIFRoaXMgaXMgYSBnb29kIHBsYWNlIHRvIGNhbGwgc2V0QW5ub3RhdGlvbigpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oIUR5Z3JhcGgpfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gdHJpZ2dlciB3aGVuIHRoZSBjaGFydFxuICogICAgIGlzIHJlYWR5LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzX2luaXRpYWxfZHJhd18pIHtcbiAgICB0aGlzLnJlYWR5Rm5zXy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBoYW5kbGVyLiBUaGlzIGV2ZW50IGhhbmRsZXIgaXMga2VwdCB1bnRpbCB0aGUgZ3JhcGggaXNcbiAqIGRlc3Ryb3llZCB3aXRoIGEgY2FsbCB0byBncmFwaC5kZXN0cm95KCkuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gZWxlbSBUaGUgZWxlbWVudCB0byBhZGQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50LCBlLmcuICdjbGljaycgb3IgJ21vdXNlbW92ZScuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50KTooYm9vbGVhbnx1bmRlZmluZWQpfSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICogICAgIG9uIHRoZSBldmVudC4gVGhlIGZ1bmN0aW9uIHRha2VzIG9uZSBwYXJhbWV0ZXI6IHRoZSBldmVudCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hZGRBbmRUcmFja0V2ZW50ID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgdXRpbHMuYWRkRXZlbnQoZWxlbSwgdHlwZSwgZm4pO1xuICB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfLnB1c2goe2VsZW0sIHR5cGUsIGZufSk7XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5yZW1vdmVUcmFja2VkRXZlbnRzXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWdpc3RlcmVkRXZlbnRzXykge1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMucmVnaXN0ZXJlZEV2ZW50c18ubGVuZ3RoOyBpZHgrKykge1xuICAgICAgdmFyIHJlZyA9IHRoaXMucmVnaXN0ZXJlZEV2ZW50c19baWR4XTtcbiAgICAgIHV0aWxzLnJlbW92ZUV2ZW50KHJlZy5lbGVtLCByZWcudHlwZSwgcmVnLmZuKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfID0gW107XG59O1xuXG5cbi8vIEluc3RhbGxlZCBwbHVnaW5zLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlIChtb3N0LWdlbmVyYWwgdG8gbW9zdC1zcGVjaWZpYykuXG5EeWdyYXBoLlBMVUdJTlMgPSBbXG4gIExlZ2VuZFBsdWdpbixcbiAgQXhlc1BsdWdpbixcbiAgUmFuZ2VTZWxlY3RvclBsdWdpbiwgLy8gSGFzIHRvIGJlIGJlZm9yZSBDaGFydExhYmVscyBzbyB0aGF0IGl0cyBjYWxsYmFja3MgYXJlIGNhbGxlZCBhZnRlciBDaGFydExhYmVscycgY2FsbGJhY2tzLlxuICBDaGFydExhYmVsc1BsdWdpbixcbiAgQW5ub3RhdGlvbnNQbHVnaW4sXG4gIEdyaWRQbHVnaW5cbl07XG5cbi8vIFRoZXJlIGFyZSBtYW55IHN5bWJvbHMgd2hpY2ggaGF2ZSBoaXN0b3JpY2FsbHkgYmVlbiBhdmFpbGFibGUgdGhyb3VnaCB0aGVcbi8vIER5Z3JhcGggY2xhc3MuIFRoZXNlIGFyZSBleHBvcnRlZCBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbkR5Z3JhcGguR1ZpekNoYXJ0ID0gR1ZpekNoYXJ0O1xuRHlncmFwaC5EQVNIRURfTElORSA9IHV0aWxzLkRBU0hFRF9MSU5FO1xuRHlncmFwaC5ET1RfREFTSF9MSU5FID0gdXRpbHMuRE9UX0RBU0hfTElORTtcbkR5Z3JhcGguZGF0ZUF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG5EeWdyYXBoLnRvUkdCXyA9IHV0aWxzLnRvUkdCXztcbkR5Z3JhcGguZmluZFBvcyA9IHV0aWxzLmZpbmRQb3M7XG5EeWdyYXBoLnBhZ2VYID0gdXRpbHMucGFnZVg7XG5EeWdyYXBoLnBhZ2VZID0gdXRpbHMucGFnZVk7XG5EeWdyYXBoLmRhdGVTdHJpbmdfID0gdXRpbHMuZGF0ZVN0cmluZ187XG5EeWdyYXBoLmRlZmF1bHRJbnRlcmFjdGlvbk1vZGVsID0gRHlncmFwaEludGVyYWN0aW9uLmRlZmF1bHRNb2RlbDtcbkR5Z3JhcGgubm9uSW50ZXJhY3RpdmVNb2RlbCA9IER5Z3JhcGgubm9uSW50ZXJhY3RpdmVNb2RlbF8gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubm9uSW50ZXJhY3RpdmVNb2RlbF87XG5EeWdyYXBoLkNpcmNsZXMgPSB1dGlscy5DaXJjbGVzO1xuXG5EeWdyYXBoLlBsdWdpbnMgPSB7XG4gIExlZ2VuZDogTGVnZW5kUGx1Z2luLFxuICBBeGVzOiBBeGVzUGx1Z2luLFxuICBBbm5vdGF0aW9uczogQW5ub3RhdGlvbnNQbHVnaW4sXG4gIENoYXJ0TGFiZWxzOiBDaGFydExhYmVsc1BsdWdpbixcbiAgR3JpZDogR3JpZFBsdWdpbixcbiAgUmFuZ2VTZWxlY3RvcjogUmFuZ2VTZWxlY3RvclBsdWdpblxufTtcblxuRHlncmFwaC5EYXRhSGFuZGxlcnMgPSB7XG4gIERlZmF1bHRIYW5kbGVyLFxuICBCYXJzSGFuZGxlcixcbiAgQ3VzdG9tQmFyc0hhbmRsZXIsXG4gIERlZmF1bHRGcmFjdGlvbkhhbmRsZXIsXG4gIEVycm9yQmFyc0hhbmRsZXIsXG4gIEZyYWN0aW9uc0JhcnNIYW5kbGVyXG59O1xuXG5EeWdyYXBoLnN0YXJ0UGFuID0gRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuO1xuRHlncmFwaC5zdGFydFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tO1xuRHlncmFwaC5tb3ZlUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVQYW47XG5EeWdyYXBoLm1vdmVab29tID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVab29tO1xuRHlncmFwaC5lbmRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuO1xuRHlncmFwaC5lbmRab29tID0gRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb207XG5cbkR5Z3JhcGgubnVtZXJpY0xpbmVhclRpY2tzID0gRHlncmFwaFRpY2tlcnMubnVtZXJpY0xpbmVhclRpY2tzO1xuRHlncmFwaC5udW1lcmljVGlja3MgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3M7XG5EeWdyYXBoLmRhdGVUaWNrZXIgPSBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyO1xuRHlncmFwaC5HcmFudWxhcml0eSA9IER5Z3JhcGhUaWNrZXJzLkdyYW51bGFyaXR5O1xuRHlncmFwaC5nZXREYXRlQXhpcyA9IER5Z3JhcGhUaWNrZXJzLmdldERhdGVBeGlzO1xuRHlncmFwaC5mbG9hdEZvcm1hdCA9IHV0aWxzLmZsb2F0Rm9ybWF0O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _dygraph_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n\n\n\n\n\n\n\n// Default attribute values.\nvar DEFAULT_ATTRS = {\n  highlightCircleSize: 3,\n  highlightSeriesOpts: null,\n  highlightSeriesBackgroundAlpha: 0.5,\n  highlightSeriesBackgroundColor: \'rgb(255, 255, 255)\',\n\n  labelsSeparateLines: false,\n  labelsShowZeroValues: true,\n  labelsKMB: false,\n  labelsKMG2: false,\n  showLabelsOnHighlight: true,\n\n  digitsAfterDecimal: 2,\n  maxNumberWidth: 6,\n  sigFigs: null,\n\n  strokeWidth: 1.0,\n  strokeBorderWidth: 0,\n  strokeBorderColor: "white",\n\n  axisTickSize: 3,\n  axisLabelFontSize: 14,\n  rightGap: 5,\n\n  showRoller: false,\n  xValueParser: undefined,\n\n  delimiter: \',\',\n\n  sigma: 2.0,\n  errorBars: false,\n  fractions: false,\n  wilsonInterval: true,  // only relevant if fractions is true\n  customBars: false,\n  fillGraph: false,\n  fillAlpha: 0.15,\n  connectSeparatedPoints: false,\n\n  stackedGraph: false,\n  stackedGraphNaNFill: \'all\',\n  hideOverlayOnMouseOut: true,\n\n  legend: \'onmouseover\',\n  stepPlot: false,\n  xRangePad: 0,\n  yRangePad: null,\n  drawAxesAtZero: false,\n\n  // Sizes of the various chart labels.\n  titleHeight: 28,\n  xLabelHeight: 18,\n  yLabelWidth: 18,\n\n  axisLineColor: "black",\n  axisLineWidth: 0.3,\n  gridLineWidth: 0.3,\n  axisLabelWidth: 50,\n  gridLineColor: "rgb(128,128,128)",\n\n  interactionModel: _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].defaultModel,\n  animatedZooms: false,  // (for now)\n\n  // Range selector options\n  showRangeSelector: false,\n  rangeSelectorHeight: 40,\n  rangeSelectorPlotStrokeColor: "#808FAB",\n  rangeSelectorPlotFillGradientColor: "white",\n  rangeSelectorPlotFillColor: "#A7B1C4",\n  rangeSelectorBackgroundStrokeColor: "gray",\n  rangeSelectorBackgroundLineWidth: 1,\n  rangeSelectorPlotLineWidth:1.5,\n  rangeSelectorForegroundStrokeColor: "black",\n  rangeSelectorForegroundLineWidth: 1,\n  rangeSelectorAlpha: 0.6,\n  showInRangeSelector: null,\n\n  // The ordering here ensures that central lines always appear above any\n  // fill bars/error bars.\n  plotter: [\n    _dygraph_canvas__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]._fillPlotter,\n    _dygraph_canvas__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]._errorPlotter,\n    _dygraph_canvas__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]._linePlotter\n  ],\n\n  plugins: [ ],\n\n  // per-axis options\n  axes: {\n    x: {\n      pixelsPerLabel: 70,\n      axisLabelWidth: 60,\n      axisLabelFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* dateAxisLabelFormatter */ "o"],\n      valueFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* dateValueFormatter */ "r"],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* dateTicker */ "b"]\n    },\n    y: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* numberValueFormatter */ "K"],\n      axisLabelFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* numberAxisLabelFormatter */ "J"],\n      drawGrid: true,\n      drawAxis: true,\n      independentTicks: true,\n      ticker: _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* numericTicks */ "e"]\n    },\n    y2: {\n      axisLabelWidth: 50,\n      pixelsPerLabel: 30,\n      valueFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* numberValueFormatter */ "K"],\n      axisLabelFormatter: _dygraph_utils__WEBPACK_IMPORTED_MODULE_3__[/* numberAxisLabelFormatter */ "J"],\n      drawAxis: true,  // only applies when there are two axes of data.\n      drawGrid: false,\n      independentTicks: false,\n      ticker: _dygraph_tickers__WEBPACK_IMPORTED_MODULE_0__[/* numericTicks */ "e"]\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (DEFAULT_ATTRS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC1kZWZhdWx0LWF0dHJzLmpzPzM0Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIER5Z3JhcGhUaWNrZXJzIGZyb20gJy4vZHlncmFwaC10aWNrZXJzJztcbmltcG9ydCBEeWdyYXBoSW50ZXJhY3Rpb24gZnJvbSAnLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9keWdyYXBoLWNhbnZhcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vLyBEZWZhdWx0IGF0dHJpYnV0ZSB2YWx1ZXMuXG52YXIgREVGQVVMVF9BVFRSUyA9IHtcbiAgaGlnaGxpZ2h0Q2lyY2xlU2l6ZTogMyxcbiAgaGlnaGxpZ2h0U2VyaWVzT3B0czogbnVsbCxcbiAgaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZEFscGhhOiAwLjUsXG4gIGhpZ2hsaWdodFNlcmllc0JhY2tncm91bmRDb2xvcjogJ3JnYigyNTUsIDI1NSwgMjU1KScsXG5cbiAgbGFiZWxzU2VwYXJhdGVMaW5lczogZmFsc2UsXG4gIGxhYmVsc1Nob3daZXJvVmFsdWVzOiB0cnVlLFxuICBsYWJlbHNLTUI6IGZhbHNlLFxuICBsYWJlbHNLTUcyOiBmYWxzZSxcbiAgc2hvd0xhYmVsc09uSGlnaGxpZ2h0OiB0cnVlLFxuXG4gIGRpZ2l0c0FmdGVyRGVjaW1hbDogMixcbiAgbWF4TnVtYmVyV2lkdGg6IDYsXG4gIHNpZ0ZpZ3M6IG51bGwsXG5cbiAgc3Ryb2tlV2lkdGg6IDEuMCxcbiAgc3Ryb2tlQm9yZGVyV2lkdGg6IDAsXG4gIHN0cm9rZUJvcmRlckNvbG9yOiBcIndoaXRlXCIsXG5cbiAgYXhpc1RpY2tTaXplOiAzLFxuICBheGlzTGFiZWxGb250U2l6ZTogMTQsXG4gIHJpZ2h0R2FwOiA1LFxuXG4gIHNob3dSb2xsZXI6IGZhbHNlLFxuICB4VmFsdWVQYXJzZXI6IHVuZGVmaW5lZCxcblxuICBkZWxpbWl0ZXI6ICcsJyxcblxuICBzaWdtYTogMi4wLFxuICBlcnJvckJhcnM6IGZhbHNlLFxuICBmcmFjdGlvbnM6IGZhbHNlLFxuICB3aWxzb25JbnRlcnZhbDogdHJ1ZSwgIC8vIG9ubHkgcmVsZXZhbnQgaWYgZnJhY3Rpb25zIGlzIHRydWVcbiAgY3VzdG9tQmFyczogZmFsc2UsXG4gIGZpbGxHcmFwaDogZmFsc2UsXG4gIGZpbGxBbHBoYTogMC4xNSxcbiAgY29ubmVjdFNlcGFyYXRlZFBvaW50czogZmFsc2UsXG5cbiAgc3RhY2tlZEdyYXBoOiBmYWxzZSxcbiAgc3RhY2tlZEdyYXBoTmFORmlsbDogJ2FsbCcsXG4gIGhpZGVPdmVybGF5T25Nb3VzZU91dDogdHJ1ZSxcblxuICBsZWdlbmQ6ICdvbm1vdXNlb3ZlcicsXG4gIHN0ZXBQbG90OiBmYWxzZSxcbiAgeFJhbmdlUGFkOiAwLFxuICB5UmFuZ2VQYWQ6IG51bGwsXG4gIGRyYXdBeGVzQXRaZXJvOiBmYWxzZSxcblxuICAvLyBTaXplcyBvZiB0aGUgdmFyaW91cyBjaGFydCBsYWJlbHMuXG4gIHRpdGxlSGVpZ2h0OiAyOCxcbiAgeExhYmVsSGVpZ2h0OiAxOCxcbiAgeUxhYmVsV2lkdGg6IDE4LFxuXG4gIGF4aXNMaW5lQ29sb3I6IFwiYmxhY2tcIixcbiAgYXhpc0xpbmVXaWR0aDogMC4zLFxuICBncmlkTGluZVdpZHRoOiAwLjMsXG4gIGF4aXNMYWJlbFdpZHRoOiA1MCxcbiAgZ3JpZExpbmVDb2xvcjogXCJyZ2IoMTI4LDEyOCwxMjgpXCIsXG5cbiAgaW50ZXJhY3Rpb25Nb2RlbDogRHlncmFwaEludGVyYWN0aW9uLmRlZmF1bHRNb2RlbCxcbiAgYW5pbWF0ZWRab29tczogZmFsc2UsICAvLyAoZm9yIG5vdylcblxuICAvLyBSYW5nZSBzZWxlY3RvciBvcHRpb25zXG4gIHNob3dSYW5nZVNlbGVjdG9yOiBmYWxzZSxcbiAgcmFuZ2VTZWxlY3RvckhlaWdodDogNDAsXG4gIHJhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3I6IFwiIzgwOEZBQlwiLFxuICByYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yOiBcIndoaXRlXCIsXG4gIHJhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yOiBcIiNBN0IxQzRcIixcbiAgcmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcjogXCJncmF5XCIsXG4gIHJhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoOiAxLFxuICByYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aDoxLjUsXG4gIHJhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3I6IFwiYmxhY2tcIixcbiAgcmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGg6IDEsXG4gIHJhbmdlU2VsZWN0b3JBbHBoYTogMC42LFxuICBzaG93SW5SYW5nZVNlbGVjdG9yOiBudWxsLFxuXG4gIC8vIFRoZSBvcmRlcmluZyBoZXJlIGVuc3VyZXMgdGhhdCBjZW50cmFsIGxpbmVzIGFsd2F5cyBhcHBlYXIgYWJvdmUgYW55XG4gIC8vIGZpbGwgYmFycy9lcnJvciBiYXJzLlxuICBwbG90dGVyOiBbXG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9maWxsUGxvdHRlcixcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlcixcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2xpbmVQbG90dGVyXG4gIF0sXG5cbiAgcGx1Z2luczogWyBdLFxuXG4gIC8vIHBlci1heGlzIG9wdGlvbnNcbiAgYXhlczoge1xuICAgIHg6IHtcbiAgICAgIHBpeGVsc1BlckxhYmVsOiA3MCxcbiAgICAgIGF4aXNMYWJlbFdpZHRoOiA2MCxcbiAgICAgIGF4aXNMYWJlbEZvcm1hdHRlcjogdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIHZhbHVlRm9ybWF0dGVyOiB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBkcmF3R3JpZDogdHJ1ZSxcbiAgICAgIGRyYXdBeGlzOiB0cnVlLFxuICAgICAgaW5kZXBlbmRlbnRUaWNrczogdHJ1ZSxcbiAgICAgIHRpY2tlcjogRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlclxuICAgIH0sXG4gICAgeToge1xuICAgICAgYXhpc0xhYmVsV2lkdGg6IDUwLFxuICAgICAgcGl4ZWxzUGVyTGFiZWw6IDMwLFxuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHV0aWxzLm51bWJlclZhbHVlRm9ybWF0dGVyLFxuICAgICAgYXhpc0xhYmVsRm9ybWF0dGVyOiB1dGlscy5udW1iZXJBeGlzTGFiZWxGb3JtYXR0ZXIsXG4gICAgICBkcmF3R3JpZDogdHJ1ZSxcbiAgICAgIGRyYXdBeGlzOiB0cnVlLFxuICAgICAgaW5kZXBlbmRlbnRUaWNrczogdHJ1ZSxcbiAgICAgIHRpY2tlcjogRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzXG4gICAgfSxcbiAgICB5Mjoge1xuICAgICAgYXhpc0xhYmVsV2lkdGg6IDUwLFxuICAgICAgcGl4ZWxzUGVyTGFiZWw6IDMwLFxuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHV0aWxzLm51bWJlclZhbHVlRm9ybWF0dGVyLFxuICAgICAgYXhpc0xhYmVsRm9ybWF0dGVyOiB1dGlscy5udW1iZXJBeGlzTGFiZWxGb3JtYXR0ZXIsXG4gICAgICBkcmF3QXhpczogdHJ1ZSwgIC8vIG9ubHkgYXBwbGllcyB3aGVuIHRoZXJlIGFyZSB0d28gYXhlcyBvZiBkYXRhLlxuICAgICAgZHJhd0dyaWQ6IGZhbHNlLFxuICAgICAgaW5kZXBlbmRlbnRUaWNrczogZmFsc2UsXG4gICAgICB0aWNrZXI6IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrc1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgREVGQVVMVF9BVFRSUztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKitLayout, but modified to meet the needs of\n * dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * Creates a new DygraphLayout object.\n *\n * This class contains all the data to be charted.\n * It uses data coordinates, but also records the chart range (in data\n * coordinates) and hence is able to calculate percentage positions ('In this\n * view, Point A lies 25% down the x-axis.')\n *\n * Two things that it does not do are:\n * 1. Record pixel coordinates for anything.\n * 2. (oddly) determine anything about the layout of chart elements.\n *\n * The naming is a vestige of Dygraph's original PlotKit roots.\n *\n * @constructor\n */\nvar DygraphLayout = function(dygraph) {\n  this.dygraph_ = dygraph;\n  /**\n   * Array of points for each series.\n   *\n   * [series index][row index in series] = |Point| structure,\n   * where series index refers to visible series only, and the\n   * point index is for the reduced set of points for the current\n   * zoom region (including one point just outside the window).\n   * All points in the same row index share the same X value.\n   *\n   * @type {Array.<Array.<Dygraph.PointType>>}\n   */\n  this.points = [];\n  this.setNames = [];\n  this.annotations = [];\n  this.yAxes_ = null;\n\n  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and\n  // yticks are outputs. Clean this up.\n  this.xTicks_ = null;\n  this.yTicks_ = null;\n};\n\n/**\n * Add points for a single series.\n *\n * @param {string} setname Name of the series.\n * @param {Array.<Dygraph.PointType>} set_xy Points for the series.\n */\nDygraphLayout.prototype.addDataset = function(setname, set_xy) {\n  this.points.push(set_xy);\n  this.setNames.push(setname);\n};\n\n/**\n * Returns the box which the chart should be drawn in. This is the canvas's\n * box, less space needed for the axis and chart labels.\n *\n * @return {{x: number, y: number, w: number, h: number}}\n */\nDygraphLayout.prototype.getPlotArea = function() {\n  return this.area_;\n};\n\n// Compute the box which the chart should be drawn in. This is the canvas's\n// box, less space needed for axis, chart labels, and other plug-ins.\n// NOTE: This should only be called by Dygraph.predraw_().\nDygraphLayout.prototype.computePlotArea = function() {\n  var area = {\n    // TODO(danvk): per-axis setting.\n    x: 0,\n    y: 0\n  };\n\n  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');\n  area.h = this.dygraph_.height_;\n\n  // Let plugins reserve space.\n  var e = {\n    chart_div: this.dygraph_.graphDiv,\n    reserveSpaceLeft: function(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.x += px;\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceRight: function(px) {\n      var r = {\n        x: area.x + area.w - px,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceTop: function(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: area.w,\n        h: px\n      };\n      area.y += px;\n      area.h -= px;\n      return r;\n    },\n    reserveSpaceBottom: function(px) {\n      var r = {\n        x: area.x,\n        y: area.y + area.h - px,\n        w: area.w,\n        h: px\n      };\n      area.h -= px;\n      return r;\n    },\n    chartRect: function() {\n      return {x:area.x, y:area.y, w:area.w, h:area.h};\n    }\n  };\n  this.dygraph_.cascadeEvents_('layout', e);\n\n  this.area_ = area;\n};\n\nDygraphLayout.prototype.setAnnotations = function(ann) {\n  // The Dygraph object's annotations aren't parsed. We parse them here and\n  // save a copy. If there is no parser, then the user must be using raw format.\n  this.annotations = [];\n  var parse = this.dygraph_.getOption('xValueParser') || function(x) { return x; };\n  for (var i = 0; i < ann.length; i++) {\n    var a = {};\n    if (!ann[i].xval && ann[i].x === undefined) {\n      console.error(\"Annotations must have an 'x' property\");\n      return;\n    }\n    if (ann[i].icon &&\n        !(ann[i].hasOwnProperty('width') &&\n          ann[i].hasOwnProperty('height'))) {\n      console.error(\"Must set width and height when setting \" +\n                    \"annotation.icon property\");\n      return;\n    }\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ \"R\"](a, ann[i]);\n    if (!a.xval) a.xval = parse(a.x);\n    this.annotations.push(a);\n  }\n};\n\nDygraphLayout.prototype.setXTicks = function(xTicks) {\n  this.xTicks_ = xTicks;\n};\n\n// TODO(danvk): add this to the Dygraph object's API or move it into Layout.\nDygraphLayout.prototype.setYAxes = function (yAxes) {\n  this.yAxes_ = yAxes;\n};\n\nDygraphLayout.prototype.evaluate = function() {\n  this._xAxis = {};\n  this._evaluateLimits();\n  this._evaluateLineCharts();\n  this._evaluateLineTicks();\n  this._evaluateAnnotations();\n};\n\nDygraphLayout.prototype._evaluateLimits = function() {\n  var xlimits = this.dygraph_.xAxisRange();\n  this._xAxis.minval = xlimits[0];\n  this._xAxis.maxval = xlimits[1];\n  var xrange = xlimits[1] - xlimits[0];\n  this._xAxis.scale = (xrange !== 0 ? 1 / xrange : 1.0);\n\n  if (this.dygraph_.getOptionForAxis(\"logscale\", 'x')) {\n    this._xAxis.xlogrange = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](this._xAxis.maxval) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](this._xAxis.minval);\n    this._xAxis.xlogscale = (this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0);\n  }\n  for (var i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    axis.minyval = axis.computedValueRange[0];\n    axis.maxyval = axis.computedValueRange[1];\n    axis.yrange = axis.maxyval - axis.minyval;\n    axis.yscale = (axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0);\n\n    if (this.dygraph_.getOption(\"logscale\")) {\n      axis.ylogrange = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](axis.maxyval) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](axis.minyval);\n      axis.ylogscale = (axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0);\n      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {\n        console.error('axis ' + i + ' of graph at ' + axis.g +\n                      ' can\\'t be displayed in log scale for range [' +\n                      axis.minyval + ' - ' + axis.maxyval + ']');\n      }\n    }\n  }\n};\n\nDygraphLayout.calcXNormal_ = function(value, xAxis, logscale) {\n  if (logscale) {\n    return ((_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](value) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](xAxis.minval)) * xAxis.xlogscale);\n  } else {\n    return (value - xAxis.minval) * xAxis.scale;\n  }\n};\n\n/**\n * @param {DygraphAxisType} axis\n * @param {number} value\n * @param {boolean} logscale\n * @return {number}\n */\nDygraphLayout.calcYNormal_ = function(axis, value, logscale) {\n  if (logscale) {\n    var x = 1.0 - ((_dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](value) - _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](axis.minyval)) * axis.ylogscale);\n    return isFinite(x) ? x : NaN;  // shim for v8 issue; see pull request 276\n  } else {\n    return 1.0 - ((value - axis.minyval) * axis.yscale);\n  }\n};\n\nDygraphLayout.prototype._evaluateLineCharts = function() {\n  var isStacked = this.dygraph_.getOption(\"stackedGraph\");\n  var isLogscaleForX = this.dygraph_.getOptionForAxis(\"logscale\", 'x');\n\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    var setName = this.setNames[setIdx];\n    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);\n    var axis = this.dygraph_.axisPropertiesForSeries(setName);\n    // TODO (konigsberg): use optionsForAxis instead.\n    var logscale = this.dygraph_.attributes_.getForSeries(\"logscale\", setName);\n\n    for (var j = 0; j < points.length; j++) {\n      var point = points[j];\n\n      // Range from 0-1 where 0 represents left and 1 represents right.\n      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);\n      // Range from 0-1 where 0 represents top and 1 represents bottom\n      var yval = point.yval;\n      if (isStacked) {\n        point.y_stacked = DygraphLayout.calcYNormal_(\n            axis, point.yval_stacked, logscale);\n        if (yval !== null && !isNaN(yval)) {\n          yval = point.yval_stacked;\n        }\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    }\n\n    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);\n  }\n};\n\nDygraphLayout.prototype._evaluateLineTicks = function() {\n  var i, tick, label, pos, v, has_tick;\n  this.xticks = [];\n  for (i = 0; i < this.xTicks_.length; i++) {\n    tick = this.xTicks_[i];\n    label = tick.label;\n    has_tick = !('label_v' in tick);\n    v = has_tick ? tick.v : tick.label_v;\n    pos = this.dygraph_.toPercentXCoord(v);\n    if ((pos >= 0.0) && (pos < 1.0)) {\n      this.xticks.push({pos, label, has_tick});\n    }\n  }\n\n  this.yticks = [];\n  for (i = 0; i < this.yAxes_.length; i++ ) {\n    var axis = this.yAxes_[i];\n    for (var j = 0; j < axis.ticks.length; j++) {\n      tick = axis.ticks[j];\n      label = tick.label;\n      has_tick = !('label_v' in tick);\n      v = has_tick ? tick.v : tick.label_v;\n      pos = this.dygraph_.toPercentYCoord(v, i);\n      if ((pos > 0.0) && (pos <= 1.0)) {\n        this.yticks.push({axis: i, pos, label, has_tick});\n      }\n    }\n  }\n};\n\nDygraphLayout.prototype._evaluateAnnotations = function() {\n  // Add the annotations to the point to which they belong.\n  // Make a map from (setName, xval) to annotation for quick lookups.\n  var i;\n  var annotations = {};\n  for (i = 0; i < this.annotations.length; i++) {\n    var a = this.annotations[i];\n    annotations[a.xval + \",\" + a.series] = a;\n  }\n\n  this.annotated_points = [];\n\n  // Exit the function early if there are no annotations.\n  if (!this.annotations || !this.annotations.length) {\n    return;\n  }\n\n  // TODO(antrob): loop through annotations not points.\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    for (i = 0; i < points.length; i++) {\n      var p = points[i];\n      var k = p.xval + \",\" + p.name;\n      if (k in annotations) {\n        p.annotation = annotations[k];\n        this.annotated_points.push(p);\n      }\n    }\n  }\n};\n\n/**\n * Convenience function to remove all the data sets from a graph\n */\nDygraphLayout.prototype.removeAllDatasets = function() {\n  delete this.points;\n  delete this.setNames;\n  delete this.setPointsLengths;\n  delete this.setPointsOffsets;\n  this.points = [];\n  this.setNames = [];\n  this.setPointsLengths = [];\n  this.setPointsOffsets = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DygraphLayout);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZHlncmFwaC1sYXlvdXQuanM/ZDljZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0TGF5b3V0LCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGUgbmVlZHMgb2ZcbiAqIGR5Z3JhcGhzLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBhbGwgdGhlIGRhdGEgdG8gYmUgY2hhcnRlZC5cbiAqIEl0IHVzZXMgZGF0YSBjb29yZGluYXRlcywgYnV0IGFsc28gcmVjb3JkcyB0aGUgY2hhcnQgcmFuZ2UgKGluIGRhdGFcbiAqIGNvb3JkaW5hdGVzKSBhbmQgaGVuY2UgaXMgYWJsZSB0byBjYWxjdWxhdGUgcGVyY2VudGFnZSBwb3NpdGlvbnMgKCdJbiB0aGlzXG4gKiB2aWV3LCBQb2ludCBBIGxpZXMgMjUlIGRvd24gdGhlIHgtYXhpcy4nKVxuICpcbiAqIFR3byB0aGluZ3MgdGhhdCBpdCBkb2VzIG5vdCBkbyBhcmU6XG4gKiAxLiBSZWNvcmQgcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGFueXRoaW5nLlxuICogMi4gKG9kZGx5KSBkZXRlcm1pbmUgYW55dGhpbmcgYWJvdXQgdGhlIGxheW91dCBvZiBjaGFydCBlbGVtZW50cy5cbiAqXG4gKiBUaGUgbmFtaW5nIGlzIGEgdmVzdGlnZSBvZiBEeWdyYXBoJ3Mgb3JpZ2luYWwgUGxvdEtpdCByb290cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhMYXlvdXQgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICAvKipcbiAgICogQXJyYXkgb2YgcG9pbnRzIGZvciBlYWNoIHNlcmllcy5cbiAgICpcbiAgICogW3NlcmllcyBpbmRleF1bcm93IGluZGV4IGluIHNlcmllc10gPSB8UG9pbnR8IHN0cnVjdHVyZSxcbiAgICogd2hlcmUgc2VyaWVzIGluZGV4IHJlZmVycyB0byB2aXNpYmxlIHNlcmllcyBvbmx5LCBhbmQgdGhlXG4gICAqIHBvaW50IGluZGV4IGlzIGZvciB0aGUgcmVkdWNlZCBzZXQgb2YgcG9pbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiB6b29tIHJlZ2lvbiAoaW5jbHVkaW5nIG9uZSBwb2ludCBqdXN0IG91dHNpZGUgdGhlIHdpbmRvdykuXG4gICAqIEFsbCBwb2ludHMgaW4gdGhlIHNhbWUgcm93IGluZGV4IHNoYXJlIHRoZSBzYW1lIFggdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj59XG4gICAqL1xuICB0aGlzLnBvaW50cyA9IFtdO1xuICB0aGlzLnNldE5hbWVzID0gW107XG4gIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgdGhpcy55QXhlc18gPSBudWxsO1xuXG4gIC8vIFRPRE8oZGFudmspOiBpdCdzIG9kZCB0aGF0IHhUaWNrc18gYW5kIHlUaWNrc18gYXJlIGlucHV0cywgYnV0IHh0aWNrcyBhbmRcbiAgLy8geXRpY2tzIGFyZSBvdXRwdXRzLiBDbGVhbiB0aGlzIHVwLlxuICB0aGlzLnhUaWNrc18gPSBudWxsO1xuICB0aGlzLnlUaWNrc18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzIGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNldG5hbWUgTmFtZSBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIHtBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBzZXRfeHkgUG9pbnRzIGZvciB0aGUgc2VyaWVzLlxuICovXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5hZGREYXRhc2V0ID0gZnVuY3Rpb24oc2V0bmFtZSwgc2V0X3h5KSB7XG4gIHRoaXMucG9pbnRzLnB1c2goc2V0X3h5KTtcbiAgdGhpcy5zZXROYW1lcy5wdXNoKHNldG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3ggd2hpY2ggdGhlIGNoYXJ0IHNob3VsZCBiZSBkcmF3biBpbi4gVGhpcyBpcyB0aGUgY2FudmFzJ3NcbiAqIGJveCwgbGVzcyBzcGFjZSBuZWVkZWQgZm9yIHRoZSBheGlzIGFuZCBjaGFydCBsYWJlbHMuXG4gKlxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcn19XG4gKi9cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmdldFBsb3RBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFyZWFfO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgYm94IHdoaWNoIHRoZSBjaGFydCBzaG91bGQgYmUgZHJhd24gaW4uIFRoaXMgaXMgdGhlIGNhbnZhcydzXG4vLyBib3gsIGxlc3Mgc3BhY2UgbmVlZGVkIGZvciBheGlzLCBjaGFydCBsYWJlbHMsIGFuZCBvdGhlciBwbHVnLWlucy5cbi8vIE5PVEU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IER5Z3JhcGgucHJlZHJhd18oKS5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmNvbXB1dGVQbG90QXJlYSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJlYSA9IHtcbiAgICAvLyBUT0RPKGRhbnZrKTogcGVyLWF4aXMgc2V0dGluZy5cbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBhcmVhLncgPSB0aGlzLmR5Z3JhcGhfLndpZHRoXyAtIGFyZWEueCAtIHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKCdyaWdodEdhcCcpO1xuICBhcmVhLmggPSB0aGlzLmR5Z3JhcGhfLmhlaWdodF87XG5cbiAgLy8gTGV0IHBsdWdpbnMgcmVzZXJ2ZSBzcGFjZS5cbiAgdmFyIGUgPSB7XG4gICAgY2hhcnRfZGl2OiB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2LFxuICAgIHJlc2VydmVTcGFjZUxlZnQ6IGZ1bmN0aW9uKHB4KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeDogYXJlYS54LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLnggKz0gcHg7XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVJpZ2h0OiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCArIGFyZWEudyAtIHB4LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVRvcDogZnVuY3Rpb24ocHgpIHtcbiAgICAgIHZhciByID0ge1xuICAgICAgICB4OiBhcmVhLngsXG4gICAgICAgIHk6IGFyZWEueSxcbiAgICAgICAgdzogYXJlYS53LFxuICAgICAgICBoOiBweFxuICAgICAgfTtcbiAgICAgIGFyZWEueSArPSBweDtcbiAgICAgIGFyZWEuaCAtPSBweDtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgcmVzZXJ2ZVNwYWNlQm90dG9tOiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCxcbiAgICAgICAgeTogYXJlYS55ICsgYXJlYS5oIC0gcHgsXG4gICAgICAgIHc6IGFyZWEudyxcbiAgICAgICAgaDogcHhcbiAgICAgIH07XG4gICAgICBhcmVhLmggLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIGNoYXJ0UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3g6YXJlYS54LCB5OmFyZWEueSwgdzphcmVhLncsIGg6YXJlYS5ofTtcbiAgICB9XG4gIH07XG4gIHRoaXMuZHlncmFwaF8uY2FzY2FkZUV2ZW50c18oJ2xheW91dCcsIGUpO1xuXG4gIHRoaXMuYXJlYV8gPSBhcmVhO1xufTtcblxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm4pIHtcbiAgLy8gVGhlIER5Z3JhcGggb2JqZWN0J3MgYW5ub3RhdGlvbnMgYXJlbid0IHBhcnNlZC4gV2UgcGFyc2UgdGhlbSBoZXJlIGFuZFxuICAvLyBzYXZlIGEgY29weS4gSWYgdGhlcmUgaXMgbm8gcGFyc2VyLCB0aGVuIHRoZSB1c2VyIG11c3QgYmUgdXNpbmcgcmF3IGZvcm1hdC5cbiAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB2YXIgcGFyc2UgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbigneFZhbHVlUGFyc2VyJykgfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IHt9O1xuICAgIGlmICghYW5uW2ldLnh2YWwgJiYgYW5uW2ldLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFubm90YXRpb25zIG11c3QgaGF2ZSBhbiAneCcgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbm5baV0uaWNvbiAmJlxuICAgICAgICAhKGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSAmJlxuICAgICAgICAgIGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTXVzdCBzZXQgd2lkdGggYW5kIGhlaWdodCB3aGVuIHNldHRpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFubm90YXRpb24uaWNvbiBwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXRpbHMudXBkYXRlKGEsIGFubltpXSk7XG4gICAgaWYgKCFhLnh2YWwpIGEueHZhbCA9IHBhcnNlKGEueCk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGEpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRYVGlja3MgPSBmdW5jdGlvbih4VGlja3MpIHtcbiAgdGhpcy54VGlja3NfID0geFRpY2tzO1xufTtcblxuLy8gVE9ETyhkYW52ayk6IGFkZCB0aGlzIHRvIHRoZSBEeWdyYXBoIG9iamVjdCdzIEFQSSBvciBtb3ZlIGl0IGludG8gTGF5b3V0LlxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0WUF4ZXMgPSBmdW5jdGlvbiAoeUF4ZXMpIHtcbiAgdGhpcy55QXhlc18gPSB5QXhlcztcbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3hBeGlzID0ge307XG4gIHRoaXMuX2V2YWx1YXRlTGltaXRzKCk7XG4gIHRoaXMuX2V2YWx1YXRlTGluZUNoYXJ0cygpO1xuICB0aGlzLl9ldmFsdWF0ZUxpbmVUaWNrcygpO1xuICB0aGlzLl9ldmFsdWF0ZUFubm90YXRpb25zKCk7XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhsaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdGhpcy5feEF4aXMubWludmFsID0geGxpbWl0c1swXTtcbiAgdGhpcy5feEF4aXMubWF4dmFsID0geGxpbWl0c1sxXTtcbiAgdmFyIHhyYW5nZSA9IHhsaW1pdHNbMV0gLSB4bGltaXRzWzBdO1xuICB0aGlzLl94QXhpcy5zY2FsZSA9ICh4cmFuZ2UgIT09IDAgPyAxIC8geHJhbmdlIDogMS4wKTtcblxuICBpZiAodGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHRoaXMuX3hBeGlzLnhsb2dyYW5nZSA9IHV0aWxzLmxvZzEwKHRoaXMuX3hBeGlzLm1heHZhbCkgLSB1dGlscy5sb2cxMCh0aGlzLl94QXhpcy5taW52YWwpO1xuICAgIHRoaXMuX3hBeGlzLnhsb2dzY2FsZSA9ICh0aGlzLl94QXhpcy54bG9ncmFuZ2UgIT09IDAgPyAxLjAgLyB0aGlzLl94QXhpcy54bG9ncmFuZ2UgOiAxLjApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55QXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGF4aXMubWlueXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgIGF4aXMubWF4eXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgIGF4aXMueXJhbmdlID0gYXhpcy5tYXh5dmFsIC0gYXhpcy5taW55dmFsO1xuICAgIGF4aXMueXNjYWxlID0gKGF4aXMueXJhbmdlICE9PSAwID8gMS4wIC8gYXhpcy55cmFuZ2UgOiAxLjApO1xuXG4gICAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIGF4aXMueWxvZ3JhbmdlID0gdXRpbHMubG9nMTAoYXhpcy5tYXh5dmFsKSAtIHV0aWxzLmxvZzEwKGF4aXMubWlueXZhbCk7XG4gICAgICBheGlzLnlsb2dzY2FsZSA9IChheGlzLnlsb2dyYW5nZSAhPT0gMCA/IDEuMCAvIGF4aXMueWxvZ3JhbmdlIDogMS4wKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYXhpcy55bG9ncmFuZ2UpIHx8IGlzTmFOKGF4aXMueWxvZ3JhbmdlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdheGlzICcgKyBpICsgJyBvZiBncmFwaCBhdCAnICsgYXhpcy5nICtcbiAgICAgICAgICAgICAgICAgICAgICAnIGNhblxcJ3QgYmUgZGlzcGxheWVkIGluIGxvZyBzY2FsZSBmb3IgcmFuZ2UgWycgK1xuICAgICAgICAgICAgICAgICAgICAgIGF4aXMubWlueXZhbCArICcgLSAnICsgYXhpcy5tYXh5dmFsICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQuY2FsY1hOb3JtYWxfID0gZnVuY3Rpb24odmFsdWUsIHhBeGlzLCBsb2dzY2FsZSkge1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICByZXR1cm4gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMCh4QXhpcy5taW52YWwpKSAqIHhBeGlzLnhsb2dzY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHhBeGlzLm1pbnZhbCkgKiB4QXhpcy5zY2FsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0R5Z3JhcGhBeGlzVHlwZX0gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ3NjYWxlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkR5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfID0gZnVuY3Rpb24oYXhpcywgdmFsdWUsIGxvZ3NjYWxlKSB7XG4gIGlmIChsb2dzY2FsZSkge1xuICAgIHZhciB4ID0gMS4wIC0gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMChheGlzLm1pbnl2YWwpKSAqIGF4aXMueWxvZ3NjYWxlKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoeCkgPyB4IDogTmFOOyAgLy8gc2hpbSBmb3IgdjggaXNzdWU7IHNlZSBwdWxsIHJlcXVlc3QgMjc2XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEuMCAtICgodmFsdWUgLSBheGlzLm1pbnl2YWwpICogYXhpcy55c2NhbGUpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW5lQ2hhcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1N0YWNrZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGlzTG9nc2NhbGVGb3JYID0gdGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKTtcblxuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzW3NldElkeF07XG4gICAgdmFyIHNldE5hbWUgPSB0aGlzLnNldE5hbWVzW3NldElkeF07XG4gICAgdmFyIGNvbm5lY3RTZXBhcmF0ZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbignY29ubmVjdFNlcGFyYXRlZFBvaW50cycsIHNldE5hbWUpO1xuICAgIHZhciBheGlzID0gdGhpcy5keWdyYXBoXy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICAvLyBUT0RPIChrb25pZ3NiZXJnKTogdXNlIG9wdGlvbnNGb3JBeGlzIGluc3RlYWQuXG4gICAgdmFyIGxvZ3NjYWxlID0gdGhpcy5keWdyYXBoXy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMoXCJsb2dzY2FsZVwiLCBzZXROYW1lKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG5cbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyBsZWZ0IGFuZCAxIHJlcHJlc2VudHMgcmlnaHQuXG4gICAgICBwb2ludC54ID0gRHlncmFwaExheW91dC5jYWxjWE5vcm1hbF8ocG9pbnQueHZhbCwgdGhpcy5feEF4aXMsIGlzTG9nc2NhbGVGb3JYKTtcbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyB0b3AgYW5kIDEgcmVwcmVzZW50cyBib3R0b21cbiAgICAgIHZhciB5dmFsID0gcG9pbnQueXZhbDtcbiAgICAgIGlmIChpc1N0YWNrZWQpIHtcbiAgICAgICAgcG9pbnQueV9zdGFja2VkID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oXG4gICAgICAgICAgICBheGlzLCBwb2ludC55dmFsX3N0YWNrZWQsIGxvZ3NjYWxlKTtcbiAgICAgICAgaWYgKHl2YWwgIT09IG51bGwgJiYgIWlzTmFOKHl2YWwpKSB7XG4gICAgICAgICAgeXZhbCA9IHBvaW50Lnl2YWxfc3RhY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHl2YWwgPT09IG51bGwpIHtcbiAgICAgICAgeXZhbCA9IE5hTjtcbiAgICAgICAgaWYgKCFjb25uZWN0U2VwYXJhdGVkKSB7XG4gICAgICAgICAgcG9pbnQueXZhbCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnQueSA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHl2YWwsIGxvZ3NjYWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLmR5Z3JhcGhfLmRhdGFIYW5kbGVyXy5vbkxpbmVFdmFsdWF0ZWQocG9pbnRzLCBheGlzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLl9ldmFsdWF0ZUxpbmVUaWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgdGljaywgbGFiZWwsIHBvcywgdiwgaGFzX3RpY2s7XG4gIHRoaXMueHRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnhUaWNrc18ubGVuZ3RoOyBpKyspIHtcbiAgICB0aWNrID0gdGhpcy54VGlja3NfW2ldO1xuICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgIHYgPSBoYXNfdGljayA/IHRpY2sudiA6IHRpY2subGFiZWxfdjtcbiAgICBwb3MgPSB0aGlzLmR5Z3JhcGhfLnRvUGVyY2VudFhDb29yZCh2KTtcbiAgICBpZiAoKHBvcyA+PSAwLjApICYmIChwb3MgPCAxLjApKSB7XG4gICAgICB0aGlzLnh0aWNrcy5wdXNoKHtwb3MsIGxhYmVsLCBoYXNfdGlja30pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueXRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnlBeGVzXy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXhpcy50aWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgdGljayA9IGF4aXMudGlja3Nbal07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgICAgdiA9IGhhc190aWNrID8gdGljay52IDogdGljay5sYWJlbF92O1xuICAgICAgcG9zID0gdGhpcy5keWdyYXBoXy50b1BlcmNlbnRZQ29vcmQodiwgaSk7XG4gICAgICBpZiAoKHBvcyA+IDAuMCkgJiYgKHBvcyA8PSAxLjApKSB7XG4gICAgICAgIHRoaXMueXRpY2tzLnB1c2goe2F4aXM6IGksIHBvcywgbGFiZWwsIGhhc190aWNrfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIHRvIHRoZSBwb2ludCB0byB3aGljaCB0aGV5IGJlbG9uZy5cbiAgLy8gTWFrZSBhIG1hcCBmcm9tIChzZXROYW1lLCB4dmFsKSB0byBhbm5vdGF0aW9uIGZvciBxdWljayBsb29rdXBzLlxuICB2YXIgaTtcbiAgdmFyIGFubm90YXRpb25zID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zW2ldO1xuICAgIGFubm90YXRpb25zW2EueHZhbCArIFwiLFwiICsgYS5zZXJpZXNdID0gYTtcbiAgfVxuXG4gIHRoaXMuYW5ub3RhdGVkX3BvaW50cyA9IFtdO1xuXG4gIC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBhbm5vdGF0aW9ucy5cbiAgaWYgKCF0aGlzLmFubm90YXRpb25zIHx8ICF0aGlzLmFubm90YXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8oYW50cm9iKTogbG9vcCB0aHJvdWdoIGFubm90YXRpb25zIG5vdCBwb2ludHMuXG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMucG9pbnRzLmxlbmd0aDsgc2V0SWR4KyspIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBrID0gcC54dmFsICsgXCIsXCIgKyBwLm5hbWU7XG4gICAgICBpZiAoayBpbiBhbm5vdGF0aW9ucykge1xuICAgICAgICBwLmFubm90YXRpb24gPSBhbm5vdGF0aW9uc1trXTtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRfcG9pbnRzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgdGhlIGRhdGEgc2V0cyBmcm9tIGEgZ3JhcGhcbiAqL1xuRHlncmFwaExheW91dC5wcm90b3R5cGUucmVtb3ZlQWxsRGF0YXNldHMgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMucG9pbnRzO1xuICBkZWxldGUgdGhpcy5zZXROYW1lcztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzTGVuZ3RocztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzT2Zmc2V0cztcbiAgdGhpcy5wb2ludHMgPSBbXTtcbiAgdGhpcy5zZXROYW1lcyA9IFtdO1xuICB0aGlzLnNldFBvaW50c0xlbmd0aHMgPSBbXTtcbiAgdGhpcy5zZXRQb2ludHNPZmZzZXRzID0gW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoTGF5b3V0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _datahandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler default implementation used for simple line charts.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandler\n */\nvar DefaultHandler = function() {\n};\n\nDefaultHandler.prototype = new _datahandler__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();\n\n/** @inheritDoc */\nDefaultHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var logScale = options.get(\'logscale\');\n  for ( var j = 0; j < rawData.length; j++) {\n    var x = rawData[j][0];\n    var point = rawData[j][i];\n    if (logScale) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point <= 0) {\n        point = null;\n      }\n    }\n    series.push([ x, point ]);\n  }\n  return series;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.rollingAverage = function(originalData, rollPeriod,\n    options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i, j, y, sum, num_ok;\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where\n  // there is not enough data to roll over the full number of points\n  if (rollPeriod == 1) {\n    return originalData;\n  }\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y))\n        continue;\n      num_ok++;\n      sum += originalData[j][1];\n    }\n    if (num_ok) {\n      rollingData[i] = [ originalData[i][0], sum / num_ok ];\n    } else {\n      rollingData[i] = [ originalData[i][0], null ];\n    }\n  }\n\n  return rollingData;\n};\n\n/** @inheritDoc */\nDefaultHandler.prototype.getExtremeYValues = function(series, dateWindow,\n    options) {\n  var minY = null, maxY = null, y;\n  var firstIdx = 0, lastIdx = series.length - 1;\n\n  for ( var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y))\n      continue;\n    if (maxY === null || y > maxY) {\n      maxY = y;\n    }\n    if (minY === null || y < minY) {\n      minY = y;\n    }\n  }\n  return [ minY, maxY ];\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (DefaultHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvZGVmYXVsdC5qcz80NTkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZWQgZm9yIHNpbXBsZSBsaW5lIGNoYXJ0cy5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEeWdyYXBoRGF0YUhhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlcic7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEeWdyYXBoLkRhdGFIYW5kbGVyXG4gKi9cbnZhciBEZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xufTtcblxuRGVmYXVsdEhhbmRsZXIucHJvdG90eXBlID0gbmV3IER5Z3JhcGhEYXRhSGFuZGxlcigpO1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgaSwgb3B0aW9ucykge1xuICAvLyBUT0RPKGRhbnZrKTogcHJlLWFsbG9jYXRlIHNlcmllcyBoZXJlLlxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciBsb2dTY2FsZSA9IG9wdGlvbnMuZ2V0KCdsb2dzY2FsZScpO1xuICBmb3IgKCB2YXIgaiA9IDA7IGogPCByYXdEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHZhciBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnQgPD0gMCkge1xuICAgICAgICBwb2ludCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHNlcmllcy5wdXNoKFsgeCwgcG9pbnQgXSk7XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRGVmYXVsdEhhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID0gZnVuY3Rpb24ob3JpZ2luYWxEYXRhLCByb2xsUGVyaW9kLFxuICAgIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcblxuICB2YXIgaSwgaiwgeSwgc3VtLCBudW1fb2s7XG4gIC8vIENhbGN1bGF0ZSB0aGUgcm9sbGluZyBhdmVyYWdlIGZvciB0aGUgZmlyc3Qgcm9sbFBlcmlvZCAtIDEgcG9pbnRzXG4gIC8vIHdoZXJlXG4gIC8vIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSB0byByb2xsIG92ZXIgdGhlIGZ1bGwgbnVtYmVyIG9mIHBvaW50c1xuICBpZiAocm9sbFBlcmlvZCA9PSAxKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsRGF0YTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgb3JpZ2luYWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtID0gMDtcbiAgICBudW1fb2sgPSAwO1xuICAgIGZvciAoaiA9IE1hdGgubWF4KDAsIGkgLSByb2xsUGVyaW9kICsgMSk7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICB5ID0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbnVtX29rKys7XG4gICAgICBzdW0gKz0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgIH1cbiAgICBpZiAobnVtX29rKSB7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCBzdW0gLyBudW1fb2sgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIG9yaWdpbmFsRGF0YVtpXVswXSwgbnVsbCBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRGVmYXVsdEhhbmRsZXIucHJvdG90eXBlLmdldEV4dHJlbWVZVmFsdWVzID0gZnVuY3Rpb24oc2VyaWVzLCBkYXRlV2luZG93LFxuICAgIG9wdGlvbnMpIHtcbiAgdmFyIG1pblkgPSBudWxsLCBtYXhZID0gbnVsbCwgeTtcbiAgdmFyIGZpcnN0SWR4ID0gMCwgbGFzdElkeCA9IHNlcmllcy5sZW5ndGggLSAxO1xuXG4gIGZvciAoIHZhciBqID0gZmlyc3RJZHg7IGogPD0gbGFzdElkeDsgaisrKSB7XG4gICAgeSA9IHNlcmllc1tqXVsxXTtcbiAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChtYXhZID09PSBudWxsIHx8IHkgPiBtYXhZKSB7XG4gICAgICBtYXhZID0geTtcbiAgICB9XG4gICAgaWYgKG1pblkgPT09IG51bGwgfHwgeSA8IG1pblkpIHtcbiAgICAgIG1pblkgPSB5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gWyBtaW5ZLCBtYXhZIF07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0SGFuZGxlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * To create a \"drag\" interaction, you typically register a mousedown event\n * handler on the element where the drag begins. In that handler, you register a\n * mouseup handler on the window to determine when the mouse is released,\n * wherever that release happens. This works well, except when the user releases\n * the mouse over an off-domain iframe. In that case, the mouseup event is\n * handled by the iframe and never bubbles up to the window handler.\n *\n * To deal with this issue, we cover iframes with high z-index divs to make sure\n * they don't capture mouseup.\n *\n * Usage:\n * element.addEventListener('mousedown', function() {\n *   var tarper = new IFrameTarp();\n *   tarper.cover();\n *   var mouseUpHandler = function() {\n *     ...\n *     window.removeEventListener(mouseUpHandler);\n *     tarper.uncover();\n *   };\n *   window.addEventListener('mouseup', mouseUpHandler);\n * };\n *\n * @constructor\n */\n\n\nfunction IFrameTarp() {\n  /** @type {Array.<!HTMLDivElement>} */\n  this.tarps = [];\n};\n\n/**\n * Find all the iframes in the document and cover them with high z-index\n * transparent divs.\n */\nIFrameTarp.prototype.cover = function() {\n  var iframes = document.getElementsByTagName(\"iframe\");\n  for (var i = 0; i < iframes.length; i++) {\n    var iframe = iframes[i];\n    var pos = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* findPos */ \"v\"](iframe),\n        x = pos.x,\n        y = pos.y,\n        width = iframe.offsetWidth,\n        height = iframe.offsetHeight;\n\n    var div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.left = x + 'px';\n    div.style.top = y + 'px';\n    div.style.width = width + 'px';\n    div.style.height = height + 'px';\n    div.style.zIndex = 999;\n    document.body.appendChild(div);\n    this.tarps.push(div);\n  }\n};\n\n/**\n * Remove all the iframe covers. You should call this in a mouseup handler.\n */\nIFrameTarp.prototype.uncover = function() {\n  for (var i = 0; i < this.tarps.length; i++) {\n    this.tarps[i].parentNode.removeChild(this.tarps[i]);\n  }\n  this.tarps = [];\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (IFrameTarp);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2lmcmFtZS10YXJwLmpzP2ZjNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUbyBjcmVhdGUgYSBcImRyYWdcIiBpbnRlcmFjdGlvbiwgeW91IHR5cGljYWxseSByZWdpc3RlciBhIG1vdXNlZG93biBldmVudFxuICogaGFuZGxlciBvbiB0aGUgZWxlbWVudCB3aGVyZSB0aGUgZHJhZyBiZWdpbnMuIEluIHRoYXQgaGFuZGxlciwgeW91IHJlZ2lzdGVyIGFcbiAqIG1vdXNldXAgaGFuZGxlciBvbiB0aGUgd2luZG93IHRvIGRldGVybWluZSB3aGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZCxcbiAqIHdoZXJldmVyIHRoYXQgcmVsZWFzZSBoYXBwZW5zLiBUaGlzIHdvcmtzIHdlbGwsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzXG4gKiB0aGUgbW91c2Ugb3ZlciBhbiBvZmYtZG9tYWluIGlmcmFtZS4gSW4gdGhhdCBjYXNlLCB0aGUgbW91c2V1cCBldmVudCBpc1xuICogaGFuZGxlZCBieSB0aGUgaWZyYW1lIGFuZCBuZXZlciBidWJibGVzIHVwIHRvIHRoZSB3aW5kb3cgaGFuZGxlci5cbiAqXG4gKiBUbyBkZWFsIHdpdGggdGhpcyBpc3N1ZSwgd2UgY292ZXIgaWZyYW1lcyB3aXRoIGhpZ2ggei1pbmRleCBkaXZzIHRvIG1ha2Ugc3VyZVxuICogdGhleSBkb24ndCBjYXB0dXJlIG1vdXNldXAuXG4gKlxuICogVXNhZ2U6XG4gKiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuICogICB2YXIgdGFycGVyID0gbmV3IElGcmFtZVRhcnAoKTtcbiAqICAgdGFycGVyLmNvdmVyKCk7XG4gKiAgIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICogICAgIC4uLlxuICogICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlVXBIYW5kbGVyKTtcbiAqICAgICB0YXJwZXIudW5jb3ZlcigpO1xuICogICB9O1xuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcbiAqIH07XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5cbmZ1bmN0aW9uIElGcmFtZVRhcnAoKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPCFIVE1MRGl2RWxlbWVudD59ICovXG4gIHRoaXMudGFycHMgPSBbXTtcbn07XG5cbi8qKlxuICogRmluZCBhbGwgdGhlIGlmcmFtZXMgaW4gdGhlIGRvY3VtZW50IGFuZCBjb3ZlciB0aGVtIHdpdGggaGlnaCB6LWluZGV4XG4gKiB0cmFuc3BhcmVudCBkaXZzLlxuICovXG5JRnJhbWVUYXJwLnByb3RvdHlwZS5jb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWZyYW1lcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaWZyYW1lXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWZyYW1lID0gaWZyYW1lc1tpXTtcbiAgICB2YXIgcG9zID0gdXRpbHMuZmluZFBvcyhpZnJhbWUpLFxuICAgICAgICB4ID0gcG9zLngsXG4gICAgICAgIHkgPSBwb3MueSxcbiAgICAgICAgd2lkdGggPSBpZnJhbWUub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGlmcmFtZS5vZmZzZXRIZWlnaHQ7XG5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICBkaXYuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGRpdi5zdHlsZS56SW5kZXggPSA5OTk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHRoaXMudGFycHMucHVzaChkaXYpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgdGhlIGlmcmFtZSBjb3ZlcnMuIFlvdSBzaG91bGQgY2FsbCB0aGlzIGluIGEgbW91c2V1cCBoYW5kbGVyLlxuICovXG5JRnJhbWVUYXJwLnByb3RvdHlwZS51bmNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50YXJwcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMudGFycHNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnRhcnBzW2ldKTtcbiAgfVxuICB0aGlzLnRhcnBzID0gW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBJRnJhbWVUYXJwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _bars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the error bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends BarsHandler\n */\nvar ErrorBarsHandler = function() {\n};\n\nErrorBarsHandler.prototype = new _bars__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  var sigma = options.get("sigma");\n  var logScale = options.get(\'logscale\');\n  for ( var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[0];\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1];\n        // preserve original error value in extras for further\n        // filtering\n        series.push([ x, y, [ y - variance, y + variance, point[1] ] ]);\n      } else {\n        series.push([ x, y, [ y, y, y ] ]);\n      }\n    } else {\n      series.push([ x, null, [ null, null, null ] ]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nErrorBarsHandler.prototype.rollingAverage =\n    function(originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get("sigma");\n\n  var i, j, y, v, sum, num_ok, stddev, variance, value;\n\n  // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y))\n        continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [ originalData[i][0], value,\n          [value - sigma * stddev, value + sigma * stddev] ];\n    } else {\n      // This explicitly preserves NaNs to aid with "independent\n      // series".\n      // See testRollingAveragePreservesNaNs.\n      v = (rollPeriod == 1) ? originalData[i][1] : null;\n      rollingData[i] = [ originalData[i][0], v, [ v, v ] ];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (ErrorBarsHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2JhcnMtZXJyb3IuanM/MzIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBlcnJvciBiYXJzIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFyc0hhbmRsZXJcbiAqL1xudmFyIEVycm9yQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkVycm9yQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgdmFyaWFuY2UsIHBvaW50O1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzBdIC0gc2lnbWEgKiBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIHkgPSBwb2ludFswXTtcbiAgICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgICB2YXJpYW5jZSA9IHNpZ21hICogcG9pbnRbMV07XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIGVycm9yIHZhbHVlIGluIGV4dHJhcyBmb3IgZnVydGhlclxuICAgICAgICAvLyBmaWx0ZXJpbmdcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHkgLSB2YXJpYW5jZSwgeSArIHZhcmlhbmNlLCBwb2ludFsxXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuXG4gIHZhciBpLCBqLCB5LCB2LCBzdW0sIG51bV9vaywgc3RkZGV2LCB2YXJpYW5jZSwgdmFsdWU7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgZm9yIHRoZSBmaXJzdCByb2xsUGVyaW9kIC0gMSBwb2ludHNcbiAgLy8gd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIHRvIHJvbGwgb3ZlciB0aGUgZnVsbCBudW1iZXIgb2YgcG9pbnRzXG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIHZhcmlhbmNlID0gMDtcbiAgICBudW1fb2sgPSAwO1xuICAgIGZvciAoaiA9IE1hdGgubWF4KDAsIGkgLSByb2xsUGVyaW9kICsgMSk7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICB5ID0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbnVtX29rKys7XG4gICAgICBzdW0gKz0geTtcbiAgICAgIHZhcmlhbmNlICs9IE1hdGgucG93KG9yaWdpbmFsRGF0YVtqXVsyXVsyXSwgMik7XG4gICAgfVxuICAgIGlmIChudW1fb2spIHtcbiAgICAgIHN0ZGRldiA9IE1hdGguc3FydCh2YXJpYW5jZSkgLyBudW1fb2s7XG4gICAgICB2YWx1ZSA9IHN1bSAvIG51bV9vaztcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIHZhbHVlLFxuICAgICAgICAgIFt2YWx1ZSAtIHNpZ21hICogc3RkZGV2LCB2YWx1ZSArIHNpZ21hICogc3RkZGV2XSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGV4cGxpY2l0bHkgcHJlc2VydmVzIE5hTnMgdG8gYWlkIHdpdGggXCJpbmRlcGVuZGVudFxuICAgICAgLy8gc2VyaWVzXCIuXG4gICAgICAvLyBTZWUgdGVzdFJvbGxpbmdBdmVyYWdlUHJlc2VydmVzTmFOcy5cbiAgICAgIHYgPSAocm9sbFBlcmlvZCA9PSAxKSA/IG9yaWdpbmFsRGF0YVtpXVsxXSA6IG51bGw7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCB2LCBbIHYsIHYgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVycm9yQmFyc0hhbmRsZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _bars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the custom bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar CustomBarsHandler = function() {\n};\n\nCustomBarsHandler.prototype = new _bars__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point;\n  var logScale = options.get(\'logscale\');\n  for ( var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      y = point[1];\n      if (y !== null && !isNaN(y)) {\n        series.push([ x, y, [ point[0], point[2] ] ]);\n      } else {\n        series.push([ x, y, [ y, y ] ]);\n      }\n    } else {\n      series.push([ x, null, [ null, null ] ]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nCustomBarsHandler.prototype.rollingAverage =\n    function(originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var y, low, high, mid,count, i, extremes;\n\n  low = 0;\n  mid = 0;\n  high = 0;\n  count = 0;\n  for (i = 0; i < originalData.length; i++) {\n    y = originalData[i][1];\n    extremes = originalData[i][2];\n    rollingData[i] = originalData[i];\n\n    if (y !== null && !isNaN(y)) {\n      low += extremes[0];\n      mid += y;\n      high += extremes[1];\n      count += 1;\n    }\n    if (i - rollPeriod >= 0) {\n      var prev = originalData[i - rollPeriod];\n      if (prev[1] !== null && !isNaN(prev[1])) {\n        low -= prev[2][0];\n        mid -= prev[1];\n        high -= prev[2][1];\n        count -= 1;\n      }\n    }\n    if (count) {\n      rollingData[i] = [\n          originalData[i][0],\n          1.0 * mid / count, \n          [ 1.0 * low / count,\n            1.0 * high / count ] ];\n    } else {\n      rollingData[i] = [ originalData[i][0], null, [ null, null ] ];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (CustomBarsHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2JhcnMtY3VzdG9tLmpzPzUxNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgY3VzdG9tIGJhcnMgb3B0aW9uLlxuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEJhcnNIYW5kbGVyIGZyb20gJy4vYmFycyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEeWdyYXBoLkRhdGFIYW5kbGVycy5CYXJzSGFuZGxlclxuICovXG52YXIgQ3VzdG9tQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkN1c3RvbUJhcnNIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBCYXJzSGFuZGxlcigpO1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkN1c3RvbUJhcnNIYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgaSwgb3B0aW9ucykge1xuICAvLyBUT0RPKGRhbnZrKTogcHJlLWFsbG9jYXRlIHNlcmllcyBoZXJlLlxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciB4LCB5LCBwb2ludDtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlICYmIHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnRbMF0gPD0gMCB8fCBwb2ludFsxXSA8PSAwIHx8IHBvaW50WzJdIDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHRyYWN0IHRvIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0LlxuICAgIGlmIChwb2ludCAhPT0gbnVsbCkge1xuICAgICAgeSA9IHBvaW50WzFdO1xuICAgICAgaWYgKHkgIT09IG51bGwgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgeSwgWyBwb2ludFswXSwgcG9pbnRbMl0gXSBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgeSwgWyB5LCB5IF0gXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmllcy5wdXNoKFsgeCwgbnVsbCwgWyBudWxsLCBudWxsIF0gXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpZXM7XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkN1c3RvbUJhcnNIYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9XG4gICAgZnVuY3Rpb24ob3JpZ2luYWxEYXRhLCByb2xsUGVyaW9kLCBvcHRpb25zKSB7XG4gIHJvbGxQZXJpb2QgPSBNYXRoLm1pbihyb2xsUGVyaW9kLCBvcmlnaW5hbERhdGEubGVuZ3RoKTtcbiAgdmFyIHJvbGxpbmdEYXRhID0gW107XG4gIHZhciB5LCBsb3csIGhpZ2gsIG1pZCxjb3VudCwgaSwgZXh0cmVtZXM7XG5cbiAgbG93ID0gMDtcbiAgbWlkID0gMDtcbiAgaGlnaCA9IDA7XG4gIGNvdW50ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHkgPSBvcmlnaW5hbERhdGFbaV1bMV07XG4gICAgZXh0cmVtZXMgPSBvcmlnaW5hbERhdGFbaV1bMl07XG4gICAgcm9sbGluZ0RhdGFbaV0gPSBvcmlnaW5hbERhdGFbaV07XG5cbiAgICBpZiAoeSAhPT0gbnVsbCAmJiAhaXNOYU4oeSkpIHtcbiAgICAgIGxvdyArPSBleHRyZW1lc1swXTtcbiAgICAgIG1pZCArPSB5O1xuICAgICAgaGlnaCArPSBleHRyZW1lc1sxXTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGlmIChpIC0gcm9sbFBlcmlvZCA+PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF07XG4gICAgICBpZiAocHJldlsxXSAhPT0gbnVsbCAmJiAhaXNOYU4ocHJldlsxXSkpIHtcbiAgICAgICAgbG93IC09IHByZXZbMl1bMF07XG4gICAgICAgIG1pZCAtPSBwcmV2WzFdO1xuICAgICAgICBoaWdoIC09IHByZXZbMl1bMV07XG4gICAgICAgIGNvdW50IC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbXG4gICAgICAgICAgb3JpZ2luYWxEYXRhW2ldWzBdLFxuICAgICAgICAgIDEuMCAqIG1pZCAvIGNvdW50LCBcbiAgICAgICAgICBbIDEuMCAqIGxvdyAvIGNvdW50LFxuICAgICAgICAgICAgMS4wICogaGlnaCAvIGNvdW50IF0gXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIG9yaWdpbmFsRGF0YVtpXVswXSwgbnVsbCwgWyBudWxsLCBudWxsIF0gXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9sbGluZ0RhdGE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDdXN0b21CYXJzSGFuZGxlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _datahandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n/* harmony import */ var _default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the fractions option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * @extends DefaultHandler\n * @constructor\n */\nvar DefaultFractionHandler = function() {\n};\n  \nDefaultFractionHandler.prototype = new _default__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]();\n\nDefaultFractionHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value;\n  var mult = 100.0;\n  var logScale = options.get(\'logscale\');\n  for ( var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([ x, y, [ num, den ] ]);\n      } else {\n        series.push([ x, num, [ num, den ] ]);\n      }\n    } else {\n      series.push([ x, null, [ null, null ] ]);\n    }\n  }\n  return series;\n};\n\nDefaultFractionHandler.prototype.rollingAverage = function(originalData, rollPeriod,\n    options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n\n  var i;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][0];\n    den += originalData[i][2][1];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][0];\n      den -= originalData[i - rollPeriod][2][1];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    rollingData[i] = [ date, mult * value ];\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (DefaultFractionHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2RlZmF1bHQtZnJhY3Rpb25zLmpzPzUyYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgZnJhY3Rpb25zIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEeWdyYXBoRGF0YUhhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlcic7XG5pbXBvcnQgRGVmYXVsdEhhbmRsZXIgZnJvbSAnLi9kZWZhdWx0JztcblxuLyoqXG4gKiBAZXh0ZW5kcyBEZWZhdWx0SGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuICBcbkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIucHJvdG90eXBlID0gbmV3IERlZmF1bHRIYW5kbGVyKCk7XG5cbkRlZmF1bHRGcmFjdGlvbkhhbmRsZXIucHJvdG90eXBlLmV4dHJhY3RTZXJpZXMgPSBmdW5jdGlvbihyYXdEYXRhLCBpLCBvcHRpb25zKSB7XG4gIC8vIFRPRE8oZGFudmspOiBwcmUtYWxsb2NhdGUgc2VyaWVzIGhlcmUuXG4gIHZhciBzZXJpZXMgPSBbXTtcbiAgdmFyIHgsIHksIHBvaW50LCBudW0sIGRlbiwgdmFsdWU7XG4gIHZhciBtdWx0ID0gMTAwLjA7XG4gIHZhciBsb2dTY2FsZSA9IG9wdGlvbnMuZ2V0KCdsb2dzY2FsZScpO1xuICBmb3IgKCB2YXIgaiA9IDA7IGogPCByYXdEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgeCA9IHJhd0RhdGFbal1bMF07XG4gICAgcG9pbnQgPSByYXdEYXRhW2pdW2ldO1xuICAgIGlmIChsb2dTY2FsZSAmJiBwb2ludCAhPT0gbnVsbCkge1xuICAgICAgLy8gT24gdGhlIGxvZyBzY2FsZSwgcG9pbnRzIGxlc3MgdGhhbiB6ZXJvIGRvIG5vdCBleGlzdC5cbiAgICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBnYXAgaW4gdGhlIGNoYXJ0LlxuICAgICAgaWYgKHBvaW50WzBdIDw9IDAgfHwgcG9pbnRbMV0gPD0gMCkge1xuICAgICAgICBwb2ludCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgdG8gdGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQuXG4gICAgaWYgKHBvaW50ICE9PSBudWxsKSB7XG4gICAgICBudW0gPSBwb2ludFswXTtcbiAgICAgIGRlbiA9IHBvaW50WzFdO1xuICAgICAgaWYgKG51bSAhPT0gbnVsbCAmJiAhaXNOYU4obnVtKSkge1xuICAgICAgICB2YWx1ZSA9IGRlbiA/IG51bSAvIGRlbiA6IDAuMDtcbiAgICAgICAgeSA9IG11bHQgKiB2YWx1ZTtcbiAgICAgICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgdmFsdWVzIGluIGV4dHJhcyBmb3IgZnVydGhlciBmaWx0ZXJpbmdcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIG51bSwgZGVuIF0gXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIG51bSwgWyBudW0sIGRlbiBdIF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpZXMucHVzaChbIHgsIG51bGwsIFsgbnVsbCwgbnVsbCBdIF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWVzO1xufTtcblxuRGVmYXVsdEZyYWN0aW9uSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPSBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsXG4gICAgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgbnVtID0gMDtcbiAgdmFyIGRlbiA9IDA7IC8vIG51bWVyYXRvci9kZW5vbWluYXRvclxuICB2YXIgbXVsdCA9IDEwMC4wO1xuICBmb3IgKGkgPSAwOyBpIDwgb3JpZ2luYWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgbnVtICs9IG9yaWdpbmFsRGF0YVtpXVsyXVswXTtcbiAgICBkZW4gKz0gb3JpZ2luYWxEYXRhW2ldWzJdWzFdO1xuICAgIGlmIChpIC0gcm9sbFBlcmlvZCA+PSAwKSB7XG4gICAgICBudW0gLT0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXVsyXVswXTtcbiAgICAgIGRlbiAtPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdWzJdWzFdO1xuICAgIH1cblxuICAgIHZhciBkYXRlID0gb3JpZ2luYWxEYXRhW2ldWzBdO1xuICAgIHZhciB2YWx1ZSA9IGRlbiA/IG51bSAvIGRlbiA6IDAuMDtcbiAgICByb2xsaW5nRGF0YVtpXSA9IFsgZGF0ZSwgbXVsdCAqIHZhbHVlIF07XG4gIH1cblxuICByZXR1cm4gcm9sbGluZ0RhdGE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _bars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the combination \n * of error bars and fractions options.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\nvar FractionsBarsHandler = function() {\n};\n\nFractionsBarsHandler.prototype = new _bars__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.extractSeries = function(rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value, stddev, variance;\n  var mult = 100.0;\n  var sigma = options.get("sigma");\n  var logScale = options.get(\'logscale\');\n  for ( var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    }\n    // Extract to the unified data format.\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n        variance = mult * stddev;\n        y = mult * value;\n        // preserve original values in extras for further filtering\n        series.push([ x, y, [ y - variance, y + variance, num, den ] ]);\n      } else {\n        series.push([ x, num, [ num, num, num, den ] ]);\n      }\n    } else {\n      series.push([ x, null, [ null, null, null, null ] ]);\n    }\n  }\n  return series;\n};\n\n/** @inheritDoc */\nFractionsBarsHandler.prototype.rollingAverage =\n    function(originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get("sigma");\n  var wilsonInterval = options.get("wilsonInterval");\n\n  var low, high, i, stddev;\n  var num = 0;\n  var den = 0; // numerator/denominator\n  var mult = 100.0;\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][2];\n    den += originalData[i][2][3];\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][2];\n      den -= originalData[i - rollPeriod][2][3];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    if (wilsonInterval) {\n      // For more details on this confidence interval, see:\n      // http://en.wikipedia.org/wiki/Binomial_confidence_interval\n      if (den) {\n        var p = value < 0 ? 0 : value, n = den;\n        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));\n        var denom = 1 + sigma * sigma / den;\n        low = (p + sigma * sigma / (2 * den) - pm) / denom;\n        high = (p + sigma * sigma / (2 * den) + pm) / denom;\n        rollingData[i] = [ date, p * mult,\n            [ low * mult, high * mult ] ];\n      } else {\n        rollingData[i] = [ date, 0, [ 0, 0 ] ];\n      }\n    } else {\n      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n      rollingData[i] = [ date, mult * value, \n                         [ mult * (value - stddev), mult * (value + stddev) ] ];\n    }\n  }\n\n  return rollingData;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (FractionsBarsHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2JhcnMtZnJhY3Rpb25zLmpzPzRkNzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTMgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGFIYW5kbGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgY29tYmluYXRpb24gXG4gKiBvZiBlcnJvciBiYXJzIGFuZCBmcmFjdGlvbnMgb3B0aW9ucy5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlcnMuQmFyc0hhbmRsZXJcbiAqL1xudmFyIEZyYWN0aW9uc0JhcnNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQmFyc0hhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgcG9pbnQsIG51bSwgZGVuLCB2YWx1ZSwgc3RkZGV2LCB2YXJpYW5jZTtcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlICYmIHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnRbMF0gPD0gMCB8fCBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIG51bSA9IHBvaW50WzBdO1xuICAgICAgZGVuID0gcG9pbnRbMV07XG4gICAgICBpZiAobnVtICE9PSBudWxsICYmICFpc05hTihudW0pKSB7XG4gICAgICAgIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgICAgICBzdGRkZXYgPSBkZW4gPyBzaWdtYSAqIE1hdGguc3FydCh2YWx1ZSAqICgxIC0gdmFsdWUpIC8gZGVuKSA6IDEuMDtcbiAgICAgICAgdmFyaWFuY2UgPSBtdWx0ICogc3RkZGV2O1xuICAgICAgICB5ID0gbXVsdCAqIHZhbHVlO1xuICAgICAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB2YWx1ZXMgaW4gZXh0cmFzIGZvciBmdXJ0aGVyIGZpbHRlcmluZ1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgeSAtIHZhcmlhbmNlLCB5ICsgdmFyaWFuY2UsIG51bSwgZGVuIF0gXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIG51bSwgWyBudW0sIG51bSwgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRnJhY3Rpb25zQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihvcmlnaW5hbERhdGEsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgcm9sbFBlcmlvZCA9IE1hdGgubWluKHJvbGxQZXJpb2QsIG9yaWdpbmFsRGF0YS5sZW5ndGgpO1xuICB2YXIgcm9sbGluZ0RhdGEgPSBbXTtcbiAgdmFyIHNpZ21hID0gb3B0aW9ucy5nZXQoXCJzaWdtYVwiKTtcbiAgdmFyIHdpbHNvbkludGVydmFsID0gb3B0aW9ucy5nZXQoXCJ3aWxzb25JbnRlcnZhbFwiKTtcblxuICB2YXIgbG93LCBoaWdoLCBpLCBzdGRkZXY7XG4gIHZhciBudW0gPSAwO1xuICB2YXIgZGVuID0gMDsgLy8gbnVtZXJhdG9yL2Rlbm9taW5hdG9yXG4gIHZhciBtdWx0ID0gMTAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBudW0gKz0gb3JpZ2luYWxEYXRhW2ldWzJdWzJdO1xuICAgIGRlbiArPSBvcmlnaW5hbERhdGFbaV1bMl1bM107XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIG51bSAtPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdWzJdWzJdO1xuICAgICAgZGVuIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bM107XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBvcmlnaW5hbERhdGFbaV1bMF07XG4gICAgdmFyIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgIGlmICh3aWxzb25JbnRlcnZhbCkge1xuICAgICAgLy8gRm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGNvbmZpZGVuY2UgaW50ZXJ2YWwsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlub21pYWxfY29uZmlkZW5jZV9pbnRlcnZhbFxuICAgICAgaWYgKGRlbikge1xuICAgICAgICB2YXIgcCA9IHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSwgbiA9IGRlbjtcbiAgICAgICAgdmFyIHBtID0gc2lnbWEgKiBNYXRoLnNxcnQocCAqICgxIC0gcCkgLyBuICsgc2lnbWEgKiBzaWdtYSAvICg0ICogbiAqIG4pKTtcbiAgICAgICAgdmFyIGRlbm9tID0gMSArIHNpZ21hICogc2lnbWEgLyBkZW47XG4gICAgICAgIGxvdyA9IChwICsgc2lnbWEgKiBzaWdtYSAvICgyICogZGVuKSAtIHBtKSAvIGRlbm9tO1xuICAgICAgICBoaWdoID0gKHAgKyBzaWdtYSAqIHNpZ21hIC8gKDIgKiBkZW4pICsgcG0pIC8gZGVub207XG4gICAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBkYXRlLCBwICogbXVsdCxcbiAgICAgICAgICAgIFsgbG93ICogbXVsdCwgaGlnaCAqIG11bHQgXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIDAsIFsgMCwgMCBdIF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZGRldiA9IGRlbiA/IHNpZ21hICogTWF0aC5zcXJ0KHZhbHVlICogKDEgLSB2YWx1ZSkgLyBkZW4pIDogMS4wO1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIG11bHQgKiB2YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgWyBtdWx0ICogKHZhbHVlIC0gc3RkZGV2KSwgbXVsdCAqICh2YWx1ZSArIHN0ZGRldikgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYWN0aW9uc0JhcnNIYW5kbGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/**\nCurrent bits of jankiness:\n- Uses dygraph.layout_ to get the parsed annotations.\n- Uses dygraph.plotter_.area\n\nIt would be nice if the plugin didn't require so much special support inside\nthe core dygraphs classes, but annotations involve quite a bit of parsing and\nlayout.\n\nTODO(danvk): cache DOM elements.\n*/\n\nvar annotations = function() {\n  this.annotations_ = [];\n};\n\nannotations.prototype.toString = function() {\n  return \"Annotations Plugin\";\n};\n\nannotations.prototype.activate = function(g) {\n  return {\n    clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\nannotations.prototype.detachLabels = function() {\n  for (var i = 0; i < this.annotations_.length; i++) {\n    var a = this.annotations_[i];\n    if (a.parentNode) a.parentNode.removeChild(a);\n    this.annotations_[i] = null;\n  }\n  this.annotations_ = [];\n};\n\nannotations.prototype.clearChart = function(e) {\n  this.detachLabels();\n};\n\nannotations.prototype.didDrawChart = function(e) {\n  var g = e.dygraph;\n\n  // Early out in the (common) case of zero annotations.\n  var points = g.layout_.annotated_points;\n  if (!points || points.length === 0) return;\n\n  var containerDiv = e.canvas.parentNode;\n\n  var bindEvt = function(eventName, classEventName, pt) {\n    return function(annotation_event) {\n      var a = pt.annotation;\n      if (a.hasOwnProperty(eventName)) {\n        a[eventName](a, pt, g, annotation_event);\n      } else if (g.getOption(classEventName)) {\n        g.getOption(classEventName)(a, pt, g, annotation_event );\n      }\n    };\n  };\n\n  // Add the annotations one-by-one.\n  var area = e.dygraph.getArea();\n\n  // x-coord to sum of previous annotation's heights (used for stacking).\n  var xToUsedHeight = {};\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p.canvasx < area.x || p.canvasx > area.x + area.w ||\n        p.canvasy < area.y || p.canvasy > area.y + area.h) {\n      continue;\n    }\n\n    var a = p.annotation;\n    var tick_height = 6;\n    if (a.hasOwnProperty(\"tickHeight\")) {\n      tick_height = a.tickHeight;\n    }\n\n    // TODO: deprecate axisLabelFontSize in favor of CSS\n    var div = document.createElement(\"div\");\n    div.style['fontSize'] = g.getOption('axisLabelFontSize') + \"px\";\n    var className = 'dygraph-annotation';\n    if (!a.hasOwnProperty('icon')) {\n      // camelCase class names are deprecated.\n      className += ' dygraphDefaultAnnotation dygraph-default-annotation';\n    }\n    if (a.hasOwnProperty('cssClass')) {\n      className += \" \" + a.cssClass;\n    }\n    div.className = className;\n\n    var width = a.hasOwnProperty('width') ? a.width : 16;\n    var height = a.hasOwnProperty('height') ? a.height : 16;\n    if (a.hasOwnProperty('icon')) {\n      var img = document.createElement(\"img\");\n      img.src = a.icon;\n      img.width = width;\n      img.height = height;\n      div.appendChild(img);\n    } else if (p.annotation.hasOwnProperty('shortText')) {\n      div.appendChild(document.createTextNode(p.annotation.shortText));\n    }\n    var left = p.canvasx - width / 2;\n    div.style.left = left + \"px\";\n    var divTop = 0;\n    if (a.attachAtBottom) {\n      var y = (area.y + area.h - height - tick_height);\n      if (xToUsedHeight[left]) {\n        y -= xToUsedHeight[left];\n      } else {\n        xToUsedHeight[left] = 0;\n      }\n      xToUsedHeight[left] += (tick_height + height);\n      divTop = y;\n    } else {\n      divTop = p.canvasy - height - tick_height;\n    }\n    div.style.top = divTop + \"px\";\n    div.style.width = width + \"px\";\n    div.style.height = height + \"px\";\n    div.title = p.annotation.text;\n    div.style.color = g.colorsMap_[p.name];\n    div.style.borderColor = g.colorsMap_[p.name];\n    a.div = div;\n\n    g.addAndTrackEvent(div, 'click',\n        bindEvt('clickHandler', 'annotationClickHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseover',\n        bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));\n    g.addAndTrackEvent(div, 'mouseout',\n        bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));\n    g.addAndTrackEvent(div, 'dblclick',\n        bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));\n\n    containerDiv.appendChild(div);\n    this.annotations_.push(div);\n\n    var ctx = e.drawingContext;\n    ctx.save();\n    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];\n    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');\n    ctx.beginPath();\n    if (!a.attachAtBottom) {\n      ctx.moveTo(p.canvasx, p.canvasy);\n      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);\n    } else {\n      var y = divTop + height;\n      ctx.moveTo(p.canvasx, y);\n      ctx.lineTo(p.canvasx, y + tick_height);\n    }\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n};\n\nannotations.prototype.destroy = function() {\n  this.detachLabels();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (annotations);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvYW5ub3RhdGlvbnMuanM/YTk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuQ3VycmVudCBiaXRzIG9mIGphbmtpbmVzczpcbi0gVXNlcyBkeWdyYXBoLmxheW91dF8gdG8gZ2V0IHRoZSBwYXJzZWQgYW5ub3RhdGlvbnMuXG4tIFVzZXMgZHlncmFwaC5wbG90dGVyXy5hcmVhXG5cbkl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIHBsdWdpbiBkaWRuJ3QgcmVxdWlyZSBzbyBtdWNoIHNwZWNpYWwgc3VwcG9ydCBpbnNpZGVcbnRoZSBjb3JlIGR5Z3JhcGhzIGNsYXNzZXMsIGJ1dCBhbm5vdGF0aW9ucyBpbnZvbHZlIHF1aXRlIGEgYml0IG9mIHBhcnNpbmcgYW5kXG5sYXlvdXQuXG5cblRPRE8oZGFudmspOiBjYWNoZSBET00gZWxlbWVudHMuXG4qL1xuXG52YXIgYW5ub3RhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBbXTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJBbm5vdGF0aW9ucyBQbHVnaW5cIjtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgcmV0dXJuIHtcbiAgICBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmRldGFjaExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5ub3RhdGlvbnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zX1tpXTtcbiAgICBpZiAoYS5wYXJlbnROb2RlKSBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uc19baV0gPSBudWxsO1xuICB9XG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuY2xlYXJDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHMoKTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kaWREcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuXG4gIC8vIEVhcmx5IG91dCBpbiB0aGUgKGNvbW1vbikgY2FzZSBvZiB6ZXJvIGFubm90YXRpb25zLlxuICB2YXIgcG9pbnRzID0gZy5sYXlvdXRfLmFubm90YXRlZF9wb2ludHM7XG4gIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICB2YXIgY29udGFpbmVyRGl2ID0gZS5jYW52YXMucGFyZW50Tm9kZTtcblxuICB2YXIgYmluZEV2dCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2xhc3NFdmVudE5hbWUsIHB0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFubm90YXRpb25fZXZlbnQpIHtcbiAgICAgIHZhciBhID0gcHQuYW5ub3RhdGlvbjtcbiAgICAgIGlmIChhLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgYVtldmVudE5hbWVdKGEsIHB0LCBnLCBhbm5vdGF0aW9uX2V2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZy5nZXRPcHRpb24oY2xhc3NFdmVudE5hbWUpKSB7XG4gICAgICAgIGcuZ2V0T3B0aW9uKGNsYXNzRXZlbnROYW1lKShhLCBwdCwgZywgYW5ub3RhdGlvbl9ldmVudCApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gQWRkIHRoZSBhbm5vdGF0aW9ucyBvbmUtYnktb25lLlxuICB2YXIgYXJlYSA9IGUuZHlncmFwaC5nZXRBcmVhKCk7XG5cbiAgLy8geC1jb29yZCB0byBzdW0gb2YgcHJldmlvdXMgYW5ub3RhdGlvbidzIGhlaWdodHMgKHVzZWQgZm9yIHN0YWNraW5nKS5cbiAgdmFyIHhUb1VzZWRIZWlnaHQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIGlmIChwLmNhbnZhc3ggPCBhcmVhLnggfHwgcC5jYW52YXN4ID4gYXJlYS54ICsgYXJlYS53IHx8XG4gICAgICAgIHAuY2FudmFzeSA8IGFyZWEueSB8fCBwLmNhbnZhc3kgPiBhcmVhLnkgKyBhcmVhLmgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBhID0gcC5hbm5vdGF0aW9uO1xuICAgIHZhciB0aWNrX2hlaWdodCA9IDY7XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoXCJ0aWNrSGVpZ2h0XCIpKSB7XG4gICAgICB0aWNrX2hlaWdodCA9IGEudGlja0hlaWdodDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGUgYXhpc0xhYmVsRm9udFNpemUgaW4gZmF2b3Igb2YgQ1NTXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlWydmb250U2l6ZSddID0gZy5nZXRPcHRpb24oJ2F4aXNMYWJlbEZvbnRTaXplJykgKyBcInB4XCI7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICdkeWdyYXBoLWFubm90YXRpb24nO1xuICAgIGlmICghYS5oYXNPd25Qcm9wZXJ0eSgnaWNvbicpKSB7XG4gICAgICAvLyBjYW1lbENhc2UgY2xhc3MgbmFtZXMgYXJlIGRlcHJlY2F0ZWQuXG4gICAgICBjbGFzc05hbWUgKz0gJyBkeWdyYXBoRGVmYXVsdEFubm90YXRpb24gZHlncmFwaC1kZWZhdWx0LWFubm90YXRpb24nO1xuICAgIH1cbiAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eSgnY3NzQ2xhc3MnKSkge1xuICAgICAgY2xhc3NOYW1lICs9IFwiIFwiICsgYS5jc3NDbGFzcztcbiAgICB9XG4gICAgZGl2LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICAgIHZhciB3aWR0aCA9IGEuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgPyBhLndpZHRoIDogMTY7XG4gICAgdmFyIGhlaWdodCA9IGEuaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpID8gYS5oZWlnaHQgOiAxNjtcbiAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eSgnaWNvbicpKSB7XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltZy5zcmMgPSBhLmljb247XG4gICAgICBpbWcud2lkdGggPSB3aWR0aDtcbiAgICAgIGltZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHAuYW5ub3RhdGlvbi5oYXNPd25Qcm9wZXJ0eSgnc2hvcnRUZXh0JykpIHtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwLmFubm90YXRpb24uc2hvcnRUZXh0KSk7XG4gICAgfVxuICAgIHZhciBsZWZ0ID0gcC5jYW52YXN4IC0gd2lkdGggLyAyO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICB2YXIgZGl2VG9wID0gMDtcbiAgICBpZiAoYS5hdHRhY2hBdEJvdHRvbSkge1xuICAgICAgdmFyIHkgPSAoYXJlYS55ICsgYXJlYS5oIC0gaGVpZ2h0IC0gdGlja19oZWlnaHQpO1xuICAgICAgaWYgKHhUb1VzZWRIZWlnaHRbbGVmdF0pIHtcbiAgICAgICAgeSAtPSB4VG9Vc2VkSGVpZ2h0W2xlZnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFRvVXNlZEhlaWdodFtsZWZ0XSA9IDA7XG4gICAgICB9XG4gICAgICB4VG9Vc2VkSGVpZ2h0W2xlZnRdICs9ICh0aWNrX2hlaWdodCArIGhlaWdodCk7XG4gICAgICBkaXZUb3AgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXZUb3AgPSBwLmNhbnZhc3kgLSBoZWlnaHQgLSB0aWNrX2hlaWdodDtcbiAgICB9XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdlRvcCArIFwicHhcIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIGRpdi50aXRsZSA9IHAuYW5ub3RhdGlvbi50ZXh0O1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGRpdi5zdHlsZS5ib3JkZXJDb2xvciA9IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGEuZGl2ID0gZGl2O1xuXG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ2NsaWNrJyxcbiAgICAgICAgYmluZEV2dCgnY2xpY2tIYW5kbGVyJywgJ2Fubm90YXRpb25DbGlja0hhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ21vdXNlb3ZlcicsXG4gICAgICAgIGJpbmRFdnQoJ21vdXNlT3ZlckhhbmRsZXInLCAnYW5ub3RhdGlvbk1vdXNlT3ZlckhhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ21vdXNlb3V0JyxcbiAgICAgICAgYmluZEV2dCgnbW91c2VPdXRIYW5kbGVyJywgJ2Fubm90YXRpb25Nb3VzZU91dEhhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ2RibGNsaWNrJyxcbiAgICAgICAgYmluZEV2dCgnZGJsQ2xpY2tIYW5kbGVyJywgJ2Fubm90YXRpb25EYmxDbGlja0hhbmRsZXInLCBwLCB0aGlzKSk7XG5cbiAgICBjb250YWluZXJEaXYuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLmFubm90YXRpb25zXy5wdXNoKGRpdik7XG5cbiAgICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGEuaGFzT3duUHJvcGVydHkoJ3RpY2tDb2xvcicpID8gYS50aWNrQ29sb3IgOiBnLmNvbG9yc01hcF9bcC5uYW1lXTtcbiAgICBjdHgubGluZVdpZHRoID0gYS5oYXNPd25Qcm9wZXJ0eSgndGlja1dpZHRoJykgPyBhLnRpY2tXaWR0aCA6IGcuZ2V0T3B0aW9uKCdzdHJva2VXaWR0aCcpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoIWEuYXR0YWNoQXRCb3R0b20pIHtcbiAgICAgIGN0eC5tb3ZlVG8ocC5jYW52YXN4LCBwLmNhbnZhc3kpO1xuICAgICAgY3R4LmxpbmVUbyhwLmNhbnZhc3gsIHAuY2FudmFzeSAtIDIgLSB0aWNrX2hlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5ID0gZGl2VG9wICsgaGVpZ2h0O1xuICAgICAgY3R4Lm1vdmVUbyhwLmNhbnZhc3gsIHkpO1xuICAgICAgY3R4LmxpbmVUbyhwLmNhbnZhc3gsIHkgKyB0aWNrX2hlaWdodCk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHMoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFubm90YXRpb25zO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n\n\n/*\nBits of jankiness:\n- Direct layout access\n- Direct area access\n- Should include calculation of ticks, not just the drawing.\n\nOptions left to make axis-friendly.\n  ('drawAxesAtZero')\n  ('xAxisHeight')\n*/\n\n\n\n/**\n * Draws the axes. This includes the labels on the x- and y-axes, as well\n * as the tick marks on the axes.\n * It does _not_ draw the grid lines which span the entire chart.\n */\nvar axes = function() {\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.toString = function() {\n  return 'Axes Plugin';\n};\n\naxes.prototype.activate = function(g) {\n  return {\n    layout: this.layout,\n    clearChart: this.clearChart,\n    willDrawChart: this.willDrawChart\n  };\n};\n\naxes.prototype.layout = function(e) {\n  var g = e.dygraph;\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');\n    e.reserveSpaceLeft(w);\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    var h;\n    // NOTE: I think this is probably broken now, since g.getOption() now\n    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always\n    // has a value.)\n    if (g.getOption('xAxisHeight')) {\n      h = g.getOption('xAxisHeight');\n    } else {\n      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');\n    }\n    e.reserveSpaceBottom(h);\n  }\n\n  if (g.numAxes() == 2) {\n    if (g.getOptionForAxis('drawAxis', 'y2')) {\n      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');\n      e.reserveSpaceRight(w);\n    }\n  } else if (g.numAxes() > 2) {\n    g.error('Only two y-axes are supported at this time. (Trying ' +\n            'to use ' + g.numAxes() + ')');\n  }\n};\n\naxes.prototype.detachLabels = function() {\n  function removeArray(ary) {\n    for (var i = 0; i < ary.length; i++) {\n      var el = ary[i];\n      if (el.parentNode) el.parentNode.removeChild(el);\n    }\n  }\n\n  removeArray(this.xlabels_);\n  removeArray(this.ylabels_);\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.clearChart = function(e) {\n  this.detachLabels();\n};\n\naxes.prototype.willDrawChart = function(e) {\n  var g = e.dygraph;\n\n  if (!g.getOptionForAxis('drawAxis', 'x') &&\n      !g.getOptionForAxis('drawAxis', 'y') &&\n      !g.getOptionForAxis('drawAxis', 'y2')) {\n    return;\n  }\n\n  // Round pixels to half-integer boundaries for crisper drawing.\n  function halfUp(x)  { return Math.round(x) + 0.5; }\n  function halfDown(y){ return Math.round(y) - 0.5; }\n\n  var context = e.drawingContext;\n  var containerDiv = e.canvas.parentNode;\n  var canvasWidth = g.width_;  // e.canvas.width is affected by pixel ratio.\n  var canvasHeight = g.height_;\n\n  var label, x, y, tick, i;\n\n  var makeLabelStyle = function(axis) {\n    return {\n      position: 'absolute',\n      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',\n      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px',\n    };\n  };\n\n  var labelStyles = {\n    x: makeLabelStyle('x'),\n    y: makeLabelStyle('y'),\n    y2: makeLabelStyle('y2')\n  };\n\n  var makeDiv = function(txt, axis, prec_axis) {\n    /*\n     * This seems to be called with the following three sets of axis/prec_axis:\n     * x: undefined\n     * y: y1\n     * y: y2\n     */\n    var div = document.createElement('div');\n    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ \"R\"](div.style, labelStyle);\n    // TODO: combine outer & inner divs\n    var inner_div = document.createElement('div');\n    inner_div.className = 'dygraph-axis-label' +\n                          ' dygraph-axis-label-' + axis +\n                          (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');\n    inner_div.innerHTML = txt;\n    div.appendChild(inner_div);\n    return div;\n  };\n\n  // axis lines\n  context.save();\n\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  // Helper for repeated axis-option accesses.\n  var makeOptionGetter = function(axis) {\n    return function(option) {\n      return g.getOptionForAxis(option, axis);\n    };\n  };\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    if (layout.yticks && layout.yticks.length > 0) {\n      var num_axes = g.numAxes();\n      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];\n      layout.yticks.forEach(tick => {\n        if (tick.label === undefined) return;  // this tick only has a grid line.\n        x = area.x;\n        var sgn = 1;\n        var prec_axis = 'y1';\n        var getAxisOption = getOptions[0];\n        if (tick.axis == 1) {  // right-side y-axis\n          x = area.x + area.w;\n          sgn = -1;\n          prec_axis = 'y2';\n          getAxisOption = getOptions[1];\n        }\n        var fontSize = getAxisOption('axisLabelFontSize');\n        y = area.y + tick.pos * area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);\n        var top = (y - fontSize / 2);\n        if (top < 0) top = 0;\n\n        if (top + fontSize + 3 > canvasHeight) {\n          label.style.bottom = '0';\n        } else {\n          label.style.top = top + 'px';\n        }\n        // TODO: replace these with css classes?\n        if (tick.axis === 0) {\n          label.style.left = (area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize')) + 'px';\n          label.style.textAlign = 'right';\n        } else if (tick.axis == 1) {\n          label.style.left = (area.x + area.w +\n                              getAxisOption('axisTickSize')) + 'px';\n          label.style.textAlign = 'left';\n        }\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        this.ylabels_.push(label);\n      });\n\n      // The lowest tick on the y-axis often overlaps with the leftmost\n      // tick on the x-axis. Shift the bottom tick up a little bit to\n      // compensate if necessary.\n      var bottomTick = this.ylabels_[0];\n      // Interested in the y2 axis also?\n      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');\n      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;\n      if (bottom > canvasHeight - fontSize) {\n        bottomTick.style.top = (parseInt(bottomTick.style.top, 10) -\n            fontSize / 2) + 'px';\n      }\n    }\n\n    // draw a vertical line on the left to separate the chart from the labels.\n    var axisX;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentXCoord(0);\n      if (r > 1 || r < 0 || isNaN(r)) r = 0;\n      axisX = halfUp(area.x + r * area.w);\n    } else {\n      axisX = halfUp(area.x);\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');\n\n    context.beginPath();\n    context.moveTo(axisX, halfDown(area.y));\n    context.lineTo(axisX, halfDown(area.y + area.h));\n    context.closePath();\n    context.stroke();\n\n    // if there's a secondary y-axis, draw a vertical line for that, too.\n    if (g.numAxes() == 2) {\n      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');\n      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');\n      context.beginPath();\n      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));\n      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));\n      context.closePath();\n      context.stroke();\n    }\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    if (layout.xticks) {\n      var getAxisOption = makeOptionGetter('x');\n      layout.xticks.forEach(tick => {\n        if (tick.label === undefined) return;  // this tick only has a grid line.\n        x = area.x + tick.pos * area.w;\n        y = area.y + area.h;\n\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'x');\n        label.style.textAlign = 'center';\n        label.style.top = (y + getAxisOption('axisTickSize')) + 'px';\n\n        var left = (x - getAxisOption('axisLabelWidth')/2);\n        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {\n          left = canvasWidth - getAxisOption('axisLabelWidth');\n          label.style.textAlign = 'right';\n        }\n        if (left < 0) {\n          left = 0;\n          label.style.textAlign = 'left';\n        }\n\n        label.style.left = left + 'px';\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n        this.xlabels_.push(label);\n      });\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');\n    context.beginPath();\n    var axisY;\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentYCoord(0, 0);\n      if (r > 1 || r < 0) r = 1;\n      axisY = halfDown(area.y + r * area.h);\n    } else {\n      axisY = halfDown(area.y + area.h);\n    }\n    context.moveTo(halfUp(area.x), axisY);\n    context.lineTo(halfUp(area.x + area.w), axisY);\n    context.closePath();\n    context.stroke();\n  }\n\n  context.restore();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (axes);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvYXhlcy5qcz81Yzk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qXG5CaXRzIG9mIGphbmtpbmVzczpcbi0gRGlyZWN0IGxheW91dCBhY2Nlc3Ncbi0gRGlyZWN0IGFyZWEgYWNjZXNzXG4tIFNob3VsZCBpbmNsdWRlIGNhbGN1bGF0aW9uIG9mIHRpY2tzLCBub3QganVzdCB0aGUgZHJhd2luZy5cblxuT3B0aW9ucyBsZWZ0IHRvIG1ha2UgYXhpcy1mcmllbmRseS5cbiAgKCdkcmF3QXhlc0F0WmVybycpXG4gICgneEF4aXNIZWlnaHQnKVxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vZHlncmFwaC11dGlscyc7XG5cbi8qKlxuICogRHJhd3MgdGhlIGF4ZXMuIFRoaXMgaW5jbHVkZXMgdGhlIGxhYmVscyBvbiB0aGUgeC0gYW5kIHktYXhlcywgYXMgd2VsbFxuICogYXMgdGhlIHRpY2sgbWFya3Mgb24gdGhlIGF4ZXMuXG4gKiBJdCBkb2VzIF9ub3RfIGRyYXcgdGhlIGdyaWQgbGluZXMgd2hpY2ggc3BhbiB0aGUgZW50aXJlIGNoYXJ0LlxuICovXG52YXIgYXhlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnhsYWJlbHNfID0gW107XG4gIHRoaXMueWxhYmVsc18gPSBbXTtcbn07XG5cbmF4ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnQXhlcyBQbHVnaW4nO1xufTtcblxuYXhlcy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiB0aGlzLmxheW91dCxcbiAgICBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgd2lsbERyYXdDaGFydDogdGhpcy53aWxsRHJhd0NoYXJ0XG4gIH07XG59O1xuXG5heGVzLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3knKSkge1xuICAgIHZhciB3ID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5JykgKyAyICogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzVGlja1NpemUnLCAneScpO1xuICAgIGUucmVzZXJ2ZVNwYWNlTGVmdCh3KTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSkge1xuICAgIHZhciBoO1xuICAgIC8vIE5PVEU6IEkgdGhpbmsgdGhpcyBpcyBwcm9iYWJseSBicm9rZW4gbm93LCBzaW5jZSBnLmdldE9wdGlvbigpIG5vd1xuICAgIC8vIGhpdHMgdGhlIGRpY3Rpb25hcnkuIChUaGF0IGlzLCBnLmdldE9wdGlvbigneEF4aXNIZWlnaHQnKSBub3cgYWx3YXlzXG4gICAgLy8gaGFzIGEgdmFsdWUuKVxuICAgIGlmIChnLmdldE9wdGlvbigneEF4aXNIZWlnaHQnKSkge1xuICAgICAgaCA9IGcuZ2V0T3B0aW9uKCd4QXhpc0hlaWdodCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxGb250U2l6ZScsICd4JykgKyAyICogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzVGlja1NpemUnLCAneCcpO1xuICAgIH1cbiAgICBlLnJlc2VydmVTcGFjZUJvdHRvbShoKTtcbiAgfVxuXG4gIGlmIChnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneTInKSkge1xuICAgICAgdmFyIHcgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgJ3kyJykgKyAyICogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzVGlja1NpemUnLCAneTInKTtcbiAgICAgIGUucmVzZXJ2ZVNwYWNlUmlnaHQodyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGcubnVtQXhlcygpID4gMikge1xuICAgIGcuZXJyb3IoJ09ubHkgdHdvIHktYXhlcyBhcmUgc3VwcG9ydGVkIGF0IHRoaXMgdGltZS4gKFRyeWluZyAnICtcbiAgICAgICAgICAgICd0byB1c2UgJyArIGcubnVtQXhlcygpICsgJyknKTtcbiAgfVxufTtcblxuYXhlcy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHJlbW92ZUFycmF5KGFyeSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBhcnlbaV07XG4gICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQXJyYXkodGhpcy54bGFiZWxzXyk7XG4gIHJlbW92ZUFycmF5KHRoaXMueWxhYmVsc18pO1xuICB0aGlzLnhsYWJlbHNfID0gW107XG4gIHRoaXMueWxhYmVsc18gPSBbXTtcbn07XG5cbmF4ZXMucHJvdG90eXBlLmNsZWFyQ2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzKCk7XG59O1xuXG5heGVzLnByb3RvdHlwZS53aWxsRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICBpZiAoIWcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpICYmXG4gICAgICAhZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykgJiZcbiAgICAgICFnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3kyJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSb3VuZCBwaXhlbHMgdG8gaGFsZi1pbnRlZ2VyIGJvdW5kYXJpZXMgZm9yIGNyaXNwZXIgZHJhd2luZy5cbiAgZnVuY3Rpb24gaGFsZlVwKHgpICB7IHJldHVybiBNYXRoLnJvdW5kKHgpICsgMC41OyB9XG4gIGZ1bmN0aW9uIGhhbGZEb3duKHkpeyByZXR1cm4gTWF0aC5yb3VuZCh5KSAtIDAuNTsgfVxuXG4gIHZhciBjb250ZXh0ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGNvbnRhaW5lckRpdiA9IGUuY2FudmFzLnBhcmVudE5vZGU7XG4gIHZhciBjYW52YXNXaWR0aCA9IGcud2lkdGhfOyAgLy8gZS5jYW52YXMud2lkdGggaXMgYWZmZWN0ZWQgYnkgcGl4ZWwgcmF0aW8uXG4gIHZhciBjYW52YXNIZWlnaHQgPSBnLmhlaWdodF87XG5cbiAgdmFyIGxhYmVsLCB4LCB5LCB0aWNrLCBpO1xuXG4gIHZhciBtYWtlTGFiZWxTdHlsZSA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBmb250U2l6ZTogZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxGb250U2l6ZScsIGF4aXMpICsgJ3B4JyxcbiAgICAgIHdpZHRoOiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgYXhpcykgKyAncHgnLFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGxhYmVsU3R5bGVzID0ge1xuICAgIHg6IG1ha2VMYWJlbFN0eWxlKCd4JyksXG4gICAgeTogbWFrZUxhYmVsU3R5bGUoJ3knKSxcbiAgICB5MjogbWFrZUxhYmVsU3R5bGUoJ3kyJylcbiAgfTtcblxuICB2YXIgbWFrZURpdiA9IGZ1bmN0aW9uKHR4dCwgYXhpcywgcHJlY19heGlzKSB7XG4gICAgLypcbiAgICAgKiBUaGlzIHNlZW1zIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgdGhyZWUgc2V0cyBvZiBheGlzL3ByZWNfYXhpczpcbiAgICAgKiB4OiB1bmRlZmluZWRcbiAgICAgKiB5OiB5MVxuICAgICAqIHk6IHkyXG4gICAgICovXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBsYWJlbFN0eWxlID0gbGFiZWxTdHlsZXNbcHJlY19heGlzID09ICd5MicgPyAneTInIDogYXhpc107XG4gICAgdXRpbHMudXBkYXRlKGRpdi5zdHlsZSwgbGFiZWxTdHlsZSk7XG4gICAgLy8gVE9ETzogY29tYmluZSBvdXRlciAmIGlubmVyIGRpdnNcbiAgICB2YXIgaW5uZXJfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5uZXJfZGl2LmNsYXNzTmFtZSA9ICdkeWdyYXBoLWF4aXMtbGFiZWwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJyBkeWdyYXBoLWF4aXMtbGFiZWwtJyArIGF4aXMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlY19heGlzID8gJyBkeWdyYXBoLWF4aXMtbGFiZWwtJyArIHByZWNfYXhpcyA6ICcnKTtcbiAgICBpbm5lcl9kaXYuaW5uZXJIVE1MID0gdHh0O1xuICAgIGRpdi5hcHBlbmRDaGlsZChpbm5lcl9kaXYpO1xuICAgIHJldHVybiBkaXY7XG4gIH07XG5cbiAgLy8gYXhpcyBsaW5lc1xuICBjb250ZXh0LnNhdmUoKTtcblxuICB2YXIgbGF5b3V0ID0gZy5sYXlvdXRfO1xuICB2YXIgYXJlYSA9IGUuZHlncmFwaC5wbG90dGVyXy5hcmVhO1xuXG4gIC8vIEhlbHBlciBmb3IgcmVwZWF0ZWQgYXhpcy1vcHRpb24gYWNjZXNzZXMuXG4gIHZhciBtYWtlT3B0aW9uR2V0dGVyID0gZnVuY3Rpb24oYXhpcykge1xuICAgIHJldHVybiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgIHJldHVybiBnLmdldE9wdGlvbkZvckF4aXMob3B0aW9uLCBheGlzKTtcbiAgICB9O1xuICB9O1xuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3knKSkge1xuICAgIGlmIChsYXlvdXQueXRpY2tzICYmIGxheW91dC55dGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG51bV9heGVzID0gZy5udW1BeGVzKCk7XG4gICAgICB2YXIgZ2V0T3B0aW9ucyA9IFttYWtlT3B0aW9uR2V0dGVyKCd5JyksIG1ha2VPcHRpb25HZXR0ZXIoJ3kyJyldO1xuICAgICAgbGF5b3V0Lnl0aWNrcy5mb3JFYWNoKHRpY2sgPT4ge1xuICAgICAgICBpZiAodGljay5sYWJlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47ICAvLyB0aGlzIHRpY2sgb25seSBoYXMgYSBncmlkIGxpbmUuXG4gICAgICAgIHggPSBhcmVhLng7XG4gICAgICAgIHZhciBzZ24gPSAxO1xuICAgICAgICB2YXIgcHJlY19heGlzID0gJ3kxJztcbiAgICAgICAgdmFyIGdldEF4aXNPcHRpb24gPSBnZXRPcHRpb25zWzBdO1xuICAgICAgICBpZiAodGljay5heGlzID09IDEpIHsgIC8vIHJpZ2h0LXNpZGUgeS1heGlzXG4gICAgICAgICAgeCA9IGFyZWEueCArIGFyZWEudztcbiAgICAgICAgICBzZ24gPSAtMTtcbiAgICAgICAgICBwcmVjX2F4aXMgPSAneTInO1xuICAgICAgICAgIGdldEF4aXNPcHRpb24gPSBnZXRPcHRpb25zWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbEZvbnRTaXplJyk7XG4gICAgICAgIHkgPSBhcmVhLnkgKyB0aWNrLnBvcyAqIGFyZWEuaDtcblxuICAgICAgICAvKiBUaWNrIG1hcmtzIGFyZSBjdXJyZW50bHkgY2xpcHBlZCwgc28gZG9uJ3QgYm90aGVyIGRyYXdpbmcgdGhlbS5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oaGFsZlVwKHgpLCBoYWxmRG93bih5KSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGhhbGZVcCh4IC0gc2duICogdGhpcy5hdHRyXygnYXhpc1RpY2tTaXplJykpLCBoYWxmRG93bih5KSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICovXG5cbiAgICAgICAgbGFiZWwgPSBtYWtlRGl2KHRpY2subGFiZWwsICd5JywgbnVtX2F4ZXMgPT0gMiA/IHByZWNfYXhpcyA6IG51bGwpO1xuICAgICAgICB2YXIgdG9wID0gKHkgLSBmb250U2l6ZSAvIDIpO1xuICAgICAgICBpZiAodG9wIDwgMCkgdG9wID0gMDtcblxuICAgICAgICBpZiAodG9wICsgZm9udFNpemUgKyAzID4gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB0aGVzZSB3aXRoIGNzcyBjbGFzc2VzP1xuICAgICAgICBpZiAodGljay5heGlzID09PSAwKSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IChhcmVhLnggLSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpIC0gZ2V0QXhpc09wdGlvbignYXhpc1RpY2tTaXplJykpICsgJ3B4JztcbiAgICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKHRpY2suYXhpcyA9PSAxKSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUubGVmdCA9IChhcmVhLnggKyBhcmVhLncgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXhpc09wdGlvbignYXhpc1RpY2tTaXplJykpICsgJ3B4JztcbiAgICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwuc3R5bGUud2lkdGggPSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpICsgJ3B4JztcbiAgICAgICAgY29udGFpbmVyRGl2LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgdGhpcy55bGFiZWxzXy5wdXNoKGxhYmVsKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaGUgbG93ZXN0IHRpY2sgb24gdGhlIHktYXhpcyBvZnRlbiBvdmVybGFwcyB3aXRoIHRoZSBsZWZ0bW9zdFxuICAgICAgLy8gdGljayBvbiB0aGUgeC1heGlzLiBTaGlmdCB0aGUgYm90dG9tIHRpY2sgdXAgYSBsaXR0bGUgYml0IHRvXG4gICAgICAvLyBjb21wZW5zYXRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgIHZhciBib3R0b21UaWNrID0gdGhpcy55bGFiZWxzX1swXTtcbiAgICAgIC8vIEludGVyZXN0ZWQgaW4gdGhlIHkyIGF4aXMgYWxzbz9cbiAgICAgIHZhciBmb250U2l6ZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCAneScpO1xuICAgICAgdmFyIGJvdHRvbSA9IHBhcnNlSW50KGJvdHRvbVRpY2suc3R5bGUudG9wLCAxMCkgKyBmb250U2l6ZTtcbiAgICAgIGlmIChib3R0b20gPiBjYW52YXNIZWlnaHQgLSBmb250U2l6ZSkge1xuICAgICAgICBib3R0b21UaWNrLnN0eWxlLnRvcCA9IChwYXJzZUludChib3R0b21UaWNrLnN0eWxlLnRvcCwgMTApIC1cbiAgICAgICAgICAgIGZvbnRTaXplIC8gMikgKyAncHgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYXcgYSB2ZXJ0aWNhbCBsaW5lIG9uIHRoZSBsZWZ0IHRvIHNlcGFyYXRlIHRoZSBjaGFydCBmcm9tIHRoZSBsYWJlbHMuXG4gICAgdmFyIGF4aXNYO1xuICAgIGlmIChnLmdldE9wdGlvbignZHJhd0F4ZXNBdFplcm8nKSkge1xuICAgICAgdmFyIHIgPSBnLnRvUGVyY2VudFhDb29yZCgwKTtcbiAgICAgIGlmIChyID4gMSB8fCByIDwgMCB8fCBpc05hTihyKSkgciA9IDA7XG4gICAgICBheGlzWCA9IGhhbGZVcChhcmVhLnggKyByICogYXJlYS53KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1ggPSBoYWxmVXAoYXJlYS54KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZUNvbG9yJywgJ3knKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVXaWR0aCcsICd5Jyk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGF4aXNYLCBoYWxmRG93bihhcmVhLnkpKTtcbiAgICBjb250ZXh0LmxpbmVUbyhheGlzWCwgaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBhIHNlY29uZGFyeSB5LWF4aXMsIGRyYXcgYSB2ZXJ0aWNhbCBsaW5lIGZvciB0aGF0LCB0b28uXG4gICAgaWYgKGcubnVtQXhlcygpID09IDIpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lQ29sb3InLCAneTInKTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZVdpZHRoJywgJ3kyJyk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8oaGFsZkRvd24oYXJlYS54ICsgYXJlYS53KSwgaGFsZkRvd24oYXJlYS55KSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhoYWxmRG93bihhcmVhLnggKyBhcmVhLncpLCBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSkge1xuICAgIGlmIChsYXlvdXQueHRpY2tzKSB7XG4gICAgICB2YXIgZ2V0QXhpc09wdGlvbiA9IG1ha2VPcHRpb25HZXR0ZXIoJ3gnKTtcbiAgICAgIGxheW91dC54dGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgICAgaWYgKHRpY2subGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAgLy8gdGhpcyB0aWNrIG9ubHkgaGFzIGEgZ3JpZCBsaW5lLlxuICAgICAgICB4ID0gYXJlYS54ICsgdGljay5wb3MgKiBhcmVhLnc7XG4gICAgICAgIHkgPSBhcmVhLnkgKyBhcmVhLmg7XG5cbiAgICAgICAgLyogVGljayBtYXJrcyBhcmUgY3VycmVudGx5IGNsaXBwZWQsIHNvIGRvbid0IGJvdGhlciBkcmF3aW5nIHRoZW0uXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcCh4KSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhoYWxmVXAoeCksIGhhbGZEb3duKHkgKyB0aGlzLmF0dHJfKCdheGlzVGlja1NpemUnKSkpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAqL1xuXG4gICAgICAgIGxhYmVsID0gbWFrZURpdih0aWNrLmxhYmVsLCAneCcpO1xuICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgbGFiZWwuc3R5bGUudG9wID0gKHkgKyBnZXRBeGlzT3B0aW9uKCdheGlzVGlja1NpemUnKSkgKyAncHgnO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gKHggLSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpLzIpO1xuICAgICAgICBpZiAobGVmdCArIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgPiBjYW52YXNXaWR0aCkge1xuICAgICAgICAgIGxlZnQgPSBjYW52YXNXaWR0aCAtIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJyk7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSArICdweCc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMueGxhYmVsc18ucHVzaChsYWJlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZUNvbG9yJywgJ3gnKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVXaWR0aCcsICd4Jyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB2YXIgYXhpc1k7XG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdkcmF3QXhlc0F0WmVybycpKSB7XG4gICAgICB2YXIgciA9IGcudG9QZXJjZW50WUNvb3JkKDAsIDApO1xuICAgICAgaWYgKHIgPiAxIHx8IHIgPCAwKSByID0gMTtcbiAgICAgIGF4aXNZID0gaGFsZkRvd24oYXJlYS55ICsgciAqIGFyZWEuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNZID0gaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKTtcbiAgICB9XG4gICAgY29udGV4dC5tb3ZlVG8oaGFsZlVwKGFyZWEueCksIGF4aXNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhoYWxmVXAoYXJlYS54ICsgYXJlYS53KSwgYXhpc1kpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIGNvbnRleHQucmVzdG9yZSgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXhlcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n\n\n// TODO(danvk): move chart label options out of dygraphs and into the plugin.\n// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.\n\nvar chart_labels = function() {\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nchart_labels.prototype.toString = function() {\n  return \"ChartLabels Plugin\";\n};\n\nchart_labels.prototype.activate = function(g) {\n  return {\n    layout: this.layout,\n    // clearChart: this.clearChart,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// QUESTION: should there be a plugin-utils.js?\nvar createDivInRect = function(r) {\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  div.style.left = r.x + 'px';\n  div.style.top = r.y + 'px';\n  div.style.width = r.w + 'px';\n  div.style.height = r.h + 'px';\n  return div;\n};\n\n// Detach and null out any existing nodes.\nchart_labels.prototype.detachLabels_ = function() {\n  var els = [ this.title_div_,\n              this.xlabel_div_,\n              this.ylabel_div_,\n              this.y2label_div_ ];\n  for (var i = 0; i < els.length; i++) {\n    var el = els[i];\n    if (!el) continue;\n    if (el.parentNode) el.parentNode.removeChild(el);\n  }\n\n  this.title_div_ = null;\n  this.xlabel_div_ = null;\n  this.ylabel_div_ = null;\n  this.y2label_div_ = null;\n};\n\nvar createRotatedDiv = function(g, box, axis, classes, html) {\n  // TODO(danvk): is this outer div actually necessary?\n  var div = document.createElement(\"div\");\n  div.style.position = 'absolute';\n  if (axis == 1) {\n    // NOTE: this is cheating. Should be positioned relative to the box.\n    div.style.left = '0px';\n  } else {\n    div.style.left = box.x + 'px';\n  }\n  div.style.top = box.y + 'px';\n  div.style.width = box.w + 'px';\n  div.style.height = box.h + 'px';\n  div.style.fontSize = (g.getOption('yLabelWidth') - 2) + 'px';\n\n  var inner_div = document.createElement(\"div\");\n  inner_div.style.position = 'absolute';\n  inner_div.style.width = box.h + 'px';\n  inner_div.style.height = box.w + 'px';\n  inner_div.style.top = (box.h / 2 - box.w / 2) + 'px';\n  inner_div.style.left = (box.w / 2 - box.h / 2) + 'px';\n  // TODO: combine inner_div and class_div.\n  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');\n\n  var class_div = document.createElement(\"div\");\n  class_div.className = classes;\n  class_div.innerHTML = html;\n\n  inner_div.appendChild(class_div);\n  div.appendChild(inner_div);\n  return div;\n};\n\nchart_labels.prototype.layout = function(e) {\n  this.detachLabels_();\n\n  var g = e.dygraph;\n  var div = e.chart_div;\n  if (g.getOption('title')) {\n    // QUESTION: should this return an absolutely-positioned div instead?\n    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));\n    this.title_div_ = createDivInRect(title_rect);\n    this.title_div_.style.fontSize = (g.getOption('titleHeight') - 8) + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-title';\n    class_div.innerHTML = g.getOption('title');\n    this.title_div_.appendChild(class_div);\n    div.appendChild(this.title_div_);\n  }\n\n  if (g.getOption('xlabel')) {\n    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));\n    this.xlabel_div_ = createDivInRect(x_rect);\n    this.xlabel_div_.style.fontSize = (g.getOption('xLabelHeight') - 2) + 'px';\n\n    var class_div = document.createElement(\"div\");\n    class_div.className = 'dygraph-label dygraph-xlabel';\n    class_div.innerHTML = g.getOption('xlabel');\n    this.xlabel_div_.appendChild(class_div);\n    div.appendChild(this.xlabel_div_);\n  }\n\n  if (g.getOption('ylabel')) {\n    // It would make sense to shift the chart here to make room for the y-axis\n    // label, but the default yAxisLabelWidth is large enough that this results\n    // in overly-padded charts. The y-axis label should fit fine. If it\n    // doesn't, the yAxisLabelWidth option can be increased.\n    var y_rect = e.reserveSpaceLeft(0);\n\n    this.ylabel_div_ = createRotatedDiv(\n        g, y_rect,\n        1,  // primary (left) y-axis\n        'dygraph-label dygraph-ylabel',\n        g.getOption('ylabel'));\n    div.appendChild(this.ylabel_div_);\n  }\n\n  if (g.getOption('y2label') && g.numAxes() == 2) {\n    // same logic applies here as for ylabel.\n    var y2_rect = e.reserveSpaceRight(0);\n    this.y2label_div_ = createRotatedDiv(\n        g, y2_rect,\n        2,  // secondary (right) y-axis\n        'dygraph-label dygraph-y2label',\n        g.getOption('y2label'));\n    div.appendChild(this.y2label_div_);\n  }\n};\n\nchart_labels.prototype.didDrawChart = function(e) {\n  var g = e.dygraph;\n  if (this.title_div_) {\n    this.title_div_.children[0].innerHTML = g.getOption('title');\n  }\n  if (this.xlabel_div_) {\n    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');\n  }\n  if (this.ylabel_div_) {\n    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');\n  }\n  if (this.y2label_div_) {\n    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');\n  }\n};\n\nchart_labels.prototype.clearChart = function() {\n};\n\nchart_labels.prototype.destroy = function() {\n  this.detachLabels_();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (chart_labels);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvY2hhcnQtbGFiZWxzLmpzPzBhNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gVE9ETyhkYW52ayk6IG1vdmUgY2hhcnQgbGFiZWwgb3B0aW9ucyBvdXQgb2YgZHlncmFwaHMgYW5kIGludG8gdGhlIHBsdWdpbi5cbi8vIFRPRE8oZGFudmspOiBvbmx5IHRlYXIgZG93biAmIHJlYnVpbGQgdGhlIERJVnMgd2hlbiBpdCdzIG5lY2Vzc2FyeS5cblxudmFyIGNoYXJ0X2xhYmVscyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRpdGxlX2Rpdl8gPSBudWxsO1xuICB0aGlzLnhsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55bGFiZWxfZGl2XyA9IG51bGw7XG4gIHRoaXMueTJsYWJlbF9kaXZfID0gbnVsbDtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQ2hhcnRMYWJlbHMgUGx1Z2luXCI7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIGxheW91dDogdGhpcy5sYXlvdXQsXG4gICAgLy8gY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIGRpZERyYXdDaGFydDogdGhpcy5kaWREcmF3Q2hhcnRcbiAgfTtcbn07XG5cbi8vIFFVRVNUSU9OOiBzaG91bGQgdGhlcmUgYmUgYSBwbHVnaW4tdXRpbHMuanM/XG52YXIgY3JlYXRlRGl2SW5SZWN0ID0gZnVuY3Rpb24ocikge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gci54ICsgJ3B4JztcbiAgZGl2LnN0eWxlLnRvcCA9IHIueSArICdweCc7XG4gIGRpdi5zdHlsZS53aWR0aCA9IHIudyArICdweCc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSByLmggKyAncHgnO1xuICByZXR1cm4gZGl2O1xufTtcblxuLy8gRGV0YWNoIGFuZCBudWxsIG91dCBhbnkgZXhpc3Rpbmcgbm9kZXMuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRldGFjaExhYmVsc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVscyA9IFsgdGhpcy50aXRsZV9kaXZfLFxuICAgICAgICAgICAgICB0aGlzLnhsYWJlbF9kaXZfLFxuICAgICAgICAgICAgICB0aGlzLnlsYWJlbF9kaXZfLFxuICAgICAgICAgICAgICB0aGlzLnkybGFiZWxfZGl2XyBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGVsc1tpXTtcbiAgICBpZiAoIWVsKSBjb250aW51ZTtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cblxuICB0aGlzLnRpdGxlX2Rpdl8gPSBudWxsO1xuICB0aGlzLnhsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55bGFiZWxfZGl2XyA9IG51bGw7XG4gIHRoaXMueTJsYWJlbF9kaXZfID0gbnVsbDtcbn07XG5cbnZhciBjcmVhdGVSb3RhdGVkRGl2ID0gZnVuY3Rpb24oZywgYm94LCBheGlzLCBjbGFzc2VzLCBodG1sKSB7XG4gIC8vIFRPRE8oZGFudmspOiBpcyB0aGlzIG91dGVyIGRpdiBhY3R1YWxseSBuZWNlc3Nhcnk/XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBpZiAoYXhpcyA9PSAxKSB7XG4gICAgLy8gTk9URTogdGhpcyBpcyBjaGVhdGluZy4gU2hvdWxkIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIGJveC5cbiAgICBkaXYuc3R5bGUubGVmdCA9ICcwcHgnO1xuICB9IGVsc2Uge1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gYm94LnggKyAncHgnO1xuICB9XG4gIGRpdi5zdHlsZS50b3AgPSBib3gueSArICdweCc7XG4gIGRpdi5zdHlsZS53aWR0aCA9IGJveC53ICsgJ3B4JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9IGJveC5oICsgJ3B4JztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gKGcuZ2V0T3B0aW9uKCd5TGFiZWxXaWR0aCcpIC0gMikgKyAncHgnO1xuXG4gIHZhciBpbm5lcl9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBpbm5lcl9kaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBpbm5lcl9kaXYuc3R5bGUud2lkdGggPSBib3guaCArICdweCc7XG4gIGlubmVyX2Rpdi5zdHlsZS5oZWlnaHQgPSBib3gudyArICdweCc7XG4gIGlubmVyX2Rpdi5zdHlsZS50b3AgPSAoYm94LmggLyAyIC0gYm94LncgLyAyKSArICdweCc7XG4gIGlubmVyX2Rpdi5zdHlsZS5sZWZ0ID0gKGJveC53IC8gMiAtIGJveC5oIC8gMikgKyAncHgnO1xuICAvLyBUT0RPOiBjb21iaW5lIGlubmVyX2RpdiBhbmQgY2xhc3NfZGl2LlxuICBpbm5lcl9kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtbGFiZWwtcm90YXRlLScgKyAoYXhpcyA9PSAxID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG5cbiAgdmFyIGNsYXNzX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNsYXNzX2Rpdi5jbGFzc05hbWUgPSBjbGFzc2VzO1xuICBjbGFzc19kaXYuaW5uZXJIVE1MID0gaHRtbDtcblxuICBpbm5lcl9kaXYuYXBwZW5kQ2hpbGQoY2xhc3NfZGl2KTtcbiAgZGl2LmFwcGVuZENoaWxkKGlubmVyX2Rpdik7XG4gIHJldHVybiBkaXY7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHNfKCk7XG5cbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIHZhciBkaXYgPSBlLmNoYXJ0X2RpdjtcbiAgaWYgKGcuZ2V0T3B0aW9uKCd0aXRsZScpKSB7XG4gICAgLy8gUVVFU1RJT046IHNob3VsZCB0aGlzIHJldHVybiBhbiBhYnNvbHV0ZWx5LXBvc2l0aW9uZWQgZGl2IGluc3RlYWQ/XG4gICAgdmFyIHRpdGxlX3JlY3QgPSBlLnJlc2VydmVTcGFjZVRvcChnLmdldE9wdGlvbigndGl0bGVIZWlnaHQnKSk7XG4gICAgdGhpcy50aXRsZV9kaXZfID0gY3JlYXRlRGl2SW5SZWN0KHRpdGxlX3JlY3QpO1xuICAgIHRoaXMudGl0bGVfZGl2Xy5zdHlsZS5mb250U2l6ZSA9IChnLmdldE9wdGlvbigndGl0bGVIZWlnaHQnKSAtIDgpICsgJ3B4JztcblxuICAgIHZhciBjbGFzc19kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNsYXNzX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1sYWJlbCBkeWdyYXBoLXRpdGxlJztcbiAgICBjbGFzc19kaXYuaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3RpdGxlJyk7XG4gICAgdGhpcy50aXRsZV9kaXZfLmFwcGVuZENoaWxkKGNsYXNzX2Rpdik7XG4gICAgZGl2LmFwcGVuZENoaWxkKHRoaXMudGl0bGVfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3hsYWJlbCcpKSB7XG4gICAgdmFyIHhfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlQm90dG9tKGcuZ2V0T3B0aW9uKCd4TGFiZWxIZWlnaHQnKSk7XG4gICAgdGhpcy54bGFiZWxfZGl2XyA9IGNyZWF0ZURpdkluUmVjdCh4X3JlY3QpO1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uc3R5bGUuZm9udFNpemUgPSAoZy5nZXRPcHRpb24oJ3hMYWJlbEhlaWdodCcpIC0gMikgKyAncHgnO1xuXG4gICAgdmFyIGNsYXNzX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY2xhc3NfZGl2LmNsYXNzTmFtZSA9ICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteGxhYmVsJztcbiAgICBjbGFzc19kaXYuaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3hsYWJlbCcpO1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uYXBwZW5kQ2hpbGQoY2xhc3NfZGl2KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy54bGFiZWxfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3lsYWJlbCcpKSB7XG4gICAgLy8gSXQgd291bGQgbWFrZSBzZW5zZSB0byBzaGlmdCB0aGUgY2hhcnQgaGVyZSB0byBtYWtlIHJvb20gZm9yIHRoZSB5LWF4aXNcbiAgICAvLyBsYWJlbCwgYnV0IHRoZSBkZWZhdWx0IHlBeGlzTGFiZWxXaWR0aCBpcyBsYXJnZSBlbm91Z2ggdGhhdCB0aGlzIHJlc3VsdHNcbiAgICAvLyBpbiBvdmVybHktcGFkZGVkIGNoYXJ0cy4gVGhlIHktYXhpcyBsYWJlbCBzaG91bGQgZml0IGZpbmUuIElmIGl0XG4gICAgLy8gZG9lc24ndCwgdGhlIHlBeGlzTGFiZWxXaWR0aCBvcHRpb24gY2FuIGJlIGluY3JlYXNlZC5cbiAgICB2YXIgeV9yZWN0ID0gZS5yZXNlcnZlU3BhY2VMZWZ0KDApO1xuXG4gICAgdGhpcy55bGFiZWxfZGl2XyA9IGNyZWF0ZVJvdGF0ZWREaXYoXG4gICAgICAgIGcsIHlfcmVjdCxcbiAgICAgICAgMSwgIC8vIHByaW1hcnkgKGxlZnQpIHktYXhpc1xuICAgICAgICAnZHlncmFwaC1sYWJlbCBkeWdyYXBoLXlsYWJlbCcsXG4gICAgICAgIGcuZ2V0T3B0aW9uKCd5bGFiZWwnKSk7XG4gICAgZGl2LmFwcGVuZENoaWxkKHRoaXMueWxhYmVsX2Rpdl8pO1xuICB9XG5cbiAgaWYgKGcuZ2V0T3B0aW9uKCd5MmxhYmVsJykgJiYgZy5udW1BeGVzKCkgPT0gMikge1xuICAgIC8vIHNhbWUgbG9naWMgYXBwbGllcyBoZXJlIGFzIGZvciB5bGFiZWwuXG4gICAgdmFyIHkyX3JlY3QgPSBlLnJlc2VydmVTcGFjZVJpZ2h0KDApO1xuICAgIHRoaXMueTJsYWJlbF9kaXZfID0gY3JlYXRlUm90YXRlZERpdihcbiAgICAgICAgZywgeTJfcmVjdCxcbiAgICAgICAgMiwgIC8vIHNlY29uZGFyeSAocmlnaHQpIHktYXhpc1xuICAgICAgICAnZHlncmFwaC1sYWJlbCBkeWdyYXBoLXkybGFiZWwnLFxuICAgICAgICBnLmdldE9wdGlvbigneTJsYWJlbCcpKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy55MmxhYmVsX2Rpdl8pO1xuICB9XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRpZERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIGlmICh0aGlzLnRpdGxlX2Rpdl8pIHtcbiAgICB0aGlzLnRpdGxlX2Rpdl8uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3RpdGxlJyk7XG4gIH1cbiAgaWYgKHRoaXMueGxhYmVsX2Rpdl8pIHtcbiAgICB0aGlzLnhsYWJlbF9kaXZfLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IGcuZ2V0T3B0aW9uKCd4bGFiZWwnKTtcbiAgfVxuICBpZiAodGhpcy55bGFiZWxfZGl2Xykge1xuICAgIHRoaXMueWxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3lsYWJlbCcpO1xuICB9XG4gIGlmICh0aGlzLnkybGFiZWxfZGl2Xykge1xuICAgIHRoaXMueTJsYWJlbF9kaXZfLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IGcuZ2V0T3B0aW9uKCd5MmxhYmVsJyk7XG4gIH1cbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuY2xlYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzXygpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2hhcnRfbGFiZWxzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\n\nCurrent bits of jankiness:\n- Direct layout access\n- Direct area access\n\n*/\n\n\n\n/**\n * Draws the gridlines, i.e. the gray horizontal & vertical lines running the\n * length of the chart.\n *\n * @constructor\n */\nvar grid = function() {\n};\n\ngrid.prototype.toString = function() {\n  return \"Gridline Plugin\";\n};\n\ngrid.prototype.activate = function(g) {\n  return {\n    willDrawChart: this.willDrawChart\n  };\n};\n\ngrid.prototype.willDrawChart = function(e) {\n  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to\n  // half-integers. This prevents them from drawing in two rows/cols.\n  var g = e.dygraph;\n  var ctx = e.drawingContext;\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area;\n\n  function halfUp(x)  { return Math.round(x) + 0.5; }\n  function halfDown(y){ return Math.round(y) - 0.5; }\n\n  var x, y, i, ticks;\n  if (g.getOptionForAxis('drawGrid', 'y')) {\n    var axes = [\"y\", \"y2\"];\n    var strokeStyles = [], lineWidths = [], drawGrid = [], stroking = [], strokePattern = [];\n    for (var i = 0; i < axes.length; i++) {\n      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);\n      if (drawGrid[i]) {\n        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);\n        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);\n        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);\n        stroking[i] = strokePattern[i] && (strokePattern[i].length >= 2);\n      }\n    }\n    ticks = layout.yticks;\n    ctx.save();\n    // draw grids for the different y axes\n    ticks.forEach(tick => {\n      if (!tick.has_tick) return;\n      var axis = tick.axis;\n      if (drawGrid[axis]) {\n        ctx.save();\n        if (stroking[axis]) {\n          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);\n        }\n        ctx.strokeStyle = strokeStyles[axis];\n        ctx.lineWidth = lineWidths[axis];\n\n        x = halfUp(area.x);\n        y = halfDown(area.y + tick.pos * area.h);\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + area.w, y);\n        ctx.stroke();\n\n        ctx.restore();\n      }\n    });\n    ctx.restore();\n  }\n\n  // draw grid for x axis\n  if (g.getOptionForAxis('drawGrid', 'x')) {\n    ticks = layout.xticks;\n    ctx.save();\n    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');\n    var stroking = strokePattern && (strokePattern.length >= 2);\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n    }\n    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');\n    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');\n    ticks.forEach(tick => {\n      if (!tick.has_tick) return;\n      x = halfUp(area.x + tick.pos * area.w);\n      y = halfDown(area.y + area.h);\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x, area.y);\n      ctx.closePath();\n      ctx.stroke();\n    });\n    if (stroking) {\n      if (ctx.setLineDash) ctx.setLineDash([]);\n    }\n    ctx.restore();\n  }\n};\n\ngrid.prototype.destroy = function() {\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (grid);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvZ3JpZC5qcz9iMTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuLypcblxuQ3VycmVudCBiaXRzIG9mIGphbmtpbmVzczpcbi0gRGlyZWN0IGxheW91dCBhY2Nlc3Ncbi0gRGlyZWN0IGFyZWEgYWNjZXNzXG5cbiovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIERyYXdzIHRoZSBncmlkbGluZXMsIGkuZS4gdGhlIGdyYXkgaG9yaXpvbnRhbCAmIHZlcnRpY2FsIGxpbmVzIHJ1bm5pbmcgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGNoYXJ0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgZ3JpZCA9IGZ1bmN0aW9uKCkge1xufTtcblxuZ3JpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiR3JpZGxpbmUgUGx1Z2luXCI7XG59O1xuXG5ncmlkLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWxsRHJhd0NoYXJ0OiB0aGlzLndpbGxEcmF3Q2hhcnRcbiAgfTtcbn07XG5cbmdyaWQucHJvdG90eXBlLndpbGxEcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIERyYXcgdGhlIG5ldyBYL1kgZ3JpZC4gTGluZXMgYXBwZWFyIGNyaXNwZXIgd2hlbiBwaXhlbHMgYXJlIHJvdW5kZWQgdG9cbiAgLy8gaGFsZi1pbnRlZ2Vycy4gVGhpcyBwcmV2ZW50cyB0aGVtIGZyb20gZHJhd2luZyBpbiB0d28gcm93cy9jb2xzLlxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBsYXlvdXQgPSBnLmxheW91dF87XG4gIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG5cbiAgZnVuY3Rpb24gaGFsZlVwKHgpICB7IHJldHVybiBNYXRoLnJvdW5kKHgpICsgMC41OyB9XG4gIGZ1bmN0aW9uIGhhbGZEb3duKHkpeyByZXR1cm4gTWF0aC5yb3VuZCh5KSAtIDAuNTsgfVxuXG4gIHZhciB4LCB5LCBpLCB0aWNrcztcbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0dyaWQnLCAneScpKSB7XG4gICAgdmFyIGF4ZXMgPSBbXCJ5XCIsIFwieTJcIl07XG4gICAgdmFyIHN0cm9rZVN0eWxlcyA9IFtdLCBsaW5lV2lkdGhzID0gW10sIGRyYXdHcmlkID0gW10sIHN0cm9raW5nID0gW10sIHN0cm9rZVBhdHRlcm4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRyYXdHcmlkW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsIGF4ZXNbaV0pO1xuICAgICAgaWYgKGRyYXdHcmlkW2ldKSB7XG4gICAgICAgIHN0cm9rZVN0eWxlc1tpXSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVDb2xvcicsIGF4ZXNbaV0pO1xuICAgICAgICBsaW5lV2lkdGhzW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgYXhlc1tpXSk7XG4gICAgICAgIHN0cm9rZVBhdHRlcm5baV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lUGF0dGVybicsIGF4ZXNbaV0pO1xuICAgICAgICBzdHJva2luZ1tpXSA9IHN0cm9rZVBhdHRlcm5baV0gJiYgKHN0cm9rZVBhdHRlcm5baV0ubGVuZ3RoID49IDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aWNrcyA9IGxheW91dC55dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICAvLyBkcmF3IGdyaWRzIGZvciB0aGUgZGlmZmVyZW50IHkgYXhlc1xuICAgIHRpY2tzLmZvckVhY2godGljayA9PiB7XG4gICAgICBpZiAoIXRpY2suaGFzX3RpY2spIHJldHVybjtcbiAgICAgIHZhciBheGlzID0gdGljay5heGlzO1xuICAgICAgaWYgKGRyYXdHcmlkW2F4aXNdKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmIChzdHJva2luZ1theGlzXSkge1xuICAgICAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChzdHJva2VQYXR0ZXJuW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZXNbYXhpc107XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGhzW2F4aXNdO1xuXG4gICAgICAgIHggPSBoYWxmVXAoYXJlYS54KTtcbiAgICAgICAgeSA9IGhhbGZEb3duKGFyZWEueSArIHRpY2sucG9zICogYXJlYS5oKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyBhcmVhLncsIHkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLy8gZHJhdyBncmlkIGZvciB4IGF4aXNcbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0dyaWQnLCAneCcpKSB7XG4gICAgdGlja3MgPSBsYXlvdXQueHRpY2tzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdmFyIHN0cm9rZVBhdHRlcm4gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lUGF0dGVybicsICd4Jyk7XG4gICAgdmFyIHN0cm9raW5nID0gc3Ryb2tlUGF0dGVybiAmJiAoc3Ryb2tlUGF0dGVybi5sZW5ndGggPj0gMik7XG4gICAgaWYgKHN0cm9raW5nKSB7XG4gICAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goc3Ryb2tlUGF0dGVybik7XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVDb2xvcicsICd4Jyk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVXaWR0aCcsICd4Jyk7XG4gICAgdGlja3MuZm9yRWFjaCh0aWNrID0+IHtcbiAgICAgIGlmICghdGljay5oYXNfdGljaykgcmV0dXJuO1xuICAgICAgeCA9IGhhbGZVcChhcmVhLnggKyB0aWNrLnBvcyAqIGFyZWEudyk7XG4gICAgICB5ID0gaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIGFyZWEueSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSk7XG4gICAgaWYgKHN0cm9raW5nKSB7XG4gICAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goW10pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuXG5ncmlkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBncmlkO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\n\n\n\n\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\nvar Legend = function() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false;  // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function() {\n  return \"Legend Plugin\";\n};\n\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\nLegend.prototype.activate = function(g) {\n  var div;\n\n  var userLabelsDiv = g.getOption('labelsDiv');\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof(userLabelsDiv) == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\";\n    // TODO(danvk): come up with a cleaner way to expose this.\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10;  // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n};\n\n// Needed for dashed lines.\nvar calculateEmWidthInDiv = function(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth=sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function(e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');\n    // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n    var leftLegend = points[0].x * area.w + 50;\n    var topLegend  = points[0].y * area.h - 50;\n\n    // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n    if ((leftLegend + labelsDivWidth + 1) > area.w) {\n      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    e.dygraph.graphDiv.appendChild(this.legend_div_);\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  this.legend_div_.innerHTML = html;\n  this.legend_div_.style.display = '';\n};\n\nLegend.prototype.deselect = function(e) {\n  var legendMode = e.dygraph.getOption('legend');\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  }\n\n  // Have to do this every time, since styles might have changed.\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function(e) {\n  this.deselect(e);\n};\n\n// Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes.\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\nLegend.prototype.predraw = function(e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return;\n\n  // TODO(danvk): only use real APIs for this.\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  var area = e.dygraph.getArea();\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\nLegend.prototype.destroy = function() {\n  this.legend_div_ = null;\n};\n\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\nLegend.generateLegendHTML = function(g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    series: []\n  };\n\n  var labelToSeries = {};\n  var labels = g.getLabels();\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof(x) !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if ((pt.yval === 0 && !showZeros) || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ \"R\"](seriesData, {yHTML});\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = (g.getOption('legendFormatter') || Legend.defaultFormatter);\n  return formatter.call(g, data);\n}\n\nLegend.defaultFormatter = function(data) {\n  var g = data.dygraph;\n\n  // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof(data.x) === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n\n      if (html !== '') html += (sepLines ? '<br/>' : ' ');\n      html += `<span style='font-weight: bold; color: ${series.color};'>${series.dashHTML} ${series.labelHTML}</span>`;\n    }\n    return html;\n  }\n\n  html = data.xHTML + ':';\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += `<span${cls}> <b><span style='color: ${series.color};'>${series.labelHTML}</span></b>:&#160;${series.yHTML}</span>`;\n  }\n  return html;\n};\n\n\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return `<div class=\"dygraph-legend-line\" style=\"border-bottom-color: ${color};\"></div>`;\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0, segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop;\n\n  // Compute the length of the pixels including the first segment twice, \n  // since we repeat it.\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i%strokePattern.length];\n  }\n\n  // See if we can loop the pattern by itself at least twice.\n  loop = Math.floor(oneEmWidth/(strokePixelLength-strokePattern[0]));\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/oneEmWidth;\n    }\n    // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i]/strokePixelLength;\n    }\n    // For the scaled patterns we do redraw the first segment.\n    segmentLoop = normalizedPattern.length+1;\n  }\n\n  // Now make the pattern.\n  var dash = \"\";\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i+=2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i%normalizedPattern.length];\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i+1)%normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n      dash += `<div class=\"dygraph-legend-dash\" style=\"margin-right: ${marginRight}em; padding-left: ${paddingLeft}em;\"></div>`;\n    }\n  }\n  return dash;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Legend);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvbGVnZW5kLmpzPzI2NDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXG4vKlxuQ3VycmVudCBiaXRzIG9mIGphbmtpbmVzczpcbi0gVXNlcyB0d28gcHJpdmF0ZSBBUElzOlxuICAgIDEuIER5Z3JhcGgub3B0aW9uc1ZpZXdGb3JBeGlzX1xuICAgIDIuIGR5Z3JhcGgucGxvdHRlcl8uYXJlYVxuLSBSZWdpc3RlcnMgZm9yIGEgXCJwcmVkcmF3XCIgZXZlbnQsIHdoaWNoIHNob3VsZCBiZSByZW5hbWVkLlxuLSBJIGNhbGwgY2FsY3VsYXRlRW1XaWR0aEluRGl2IG1vcmUgb2Z0ZW4gdGhhbiBuZWVkZWQuXG4qL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vZHlncmFwaC11dGlscyc7XG5cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBsZWdlbmQsIHdoaWNoIGFwcGVhcnMgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgY2hhcnQuXG4gKiBUaGUgbGVnZW5kIGNhbiBiZSBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBvciBnZW5lcmF0ZWQgZGl2LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTGVnZW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBudWxsO1xuICB0aGlzLmlzX2dlbmVyYXRlZF9kaXZfID0gZmFsc2U7ICAvLyBkbyB3ZSBvd24gdGhpcyBkaXYsIG9yIHdhcyBpdCB1c2VyLXNwZWNpZmllZD9cbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiTGVnZW5kIFBsdWdpblwiO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGNhbGxlZCBkdXJpbmcgdGhlIGR5Z3JhcGggY29uc3RydWN0b3IsIGFmdGVyIG9wdGlvbnMgaGF2ZSBiZWVuIHNldFxuICogYnV0IGJlZm9yZSB0aGUgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogUHJvcGVyIHRhc2tzIHRvIGRvIGhlcmUgaW5jbHVkZTpcbiAqIC0gUmVhZGluZyB5b3VyIG93biBvcHRpb25zXG4gKiAtIERPTSBtYW5pcHVsYXRpb25cbiAqIC0gUmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzXG4gKlxuICogQHBhcmFtIHtEeWdyYXBofSBnIEdyYXBoIGluc3RhbmNlLlxuICogQHJldHVybiB7b2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKGV2KT59IE1hcHBpbmcgb2YgZXZlbnQgbmFtZXMgdG8gY2FsbGJhY2tzLlxuICovXG5MZWdlbmQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICB2YXIgZGl2O1xuXG4gIHZhciB1c2VyTGFiZWxzRGl2ID0gZy5nZXRPcHRpb24oJ2xhYmVsc0RpdicpO1xuICBpZiAodXNlckxhYmVsc0RpdiAmJiBudWxsICE9PSB1c2VyTGFiZWxzRGl2KSB7XG4gICAgaWYgKHR5cGVvZih1c2VyTGFiZWxzRGl2KSA9PSBcInN0cmluZ1wiIHx8IHVzZXJMYWJlbHNEaXYgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVzZXJMYWJlbHNEaXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYgPSB1c2VyTGFiZWxzRGl2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcImR5Z3JhcGgtbGVnZW5kXCI7XG4gICAgLy8gVE9ETyhkYW52ayk6IGNvbWUgdXAgd2l0aCBhIGNsZWFuZXIgd2F5IHRvIGV4cG9zZSB0aGlzLlxuICAgIGcuZ3JhcGhEaXYuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLmlzX2dlbmVyYXRlZF9kaXZfID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBkaXY7XG4gIHRoaXMub25lX2VtX3dpZHRoXyA9IDEwOyAgLy8ganVzdCBhIGd1ZXNzLCB3aWxsIGJlIHVwZGF0ZWQuXG5cbiAgcmV0dXJuIHtcbiAgICBzZWxlY3Q6IHRoaXMuc2VsZWN0LFxuICAgIGRlc2VsZWN0OiB0aGlzLmRlc2VsZWN0LFxuICAgIC8vIFRPRE8oZGFudmspOiByZXRoaW5rIHRoZSBuYW1lIFwicHJlZHJhd1wiIGJlZm9yZSB3ZSBjb21taXQgdG8gaXQgaW4gYW55IEFQSS5cbiAgICBwcmVkcmF3OiB0aGlzLnByZWRyYXcsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gTmVlZGVkIGZvciBkYXNoZWQgbGluZXMuXG52YXIgY2FsY3VsYXRlRW1XaWR0aEluRGl2ID0gZnVuY3Rpb24oZGl2KSB7XG4gIHZhciBzaXplU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgc2l6ZVNwYW4uc2V0QXR0cmlidXRlKCdzdHlsZScsICdtYXJnaW46IDA7IHBhZGRpbmc6IDAgMCAwIDFlbTsgYm9yZGVyOiAwOycpO1xuICBkaXYuYXBwZW5kQ2hpbGQoc2l6ZVNwYW4pO1xuICB2YXIgb25lRW1XaWR0aD1zaXplU3Bhbi5vZmZzZXRXaWR0aDtcbiAgZGl2LnJlbW92ZUNoaWxkKHNpemVTcGFuKTtcbiAgcmV0dXJuIG9uZUVtV2lkdGg7XG59O1xuXG52YXIgZXNjYXBlSFRNTCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgeFZhbHVlID0gZS5zZWxlY3RlZFg7XG4gIHZhciBwb2ludHMgPSBlLnNlbGVjdGVkUG9pbnRzO1xuICB2YXIgcm93ID0gZS5zZWxlY3RlZFJvdztcblxuICB2YXIgbGVnZW5kTW9kZSA9IGUuZHlncmFwaC5nZXRPcHRpb24oJ2xlZ2VuZCcpO1xuICBpZiAobGVnZW5kTW9kZSA9PT0gJ25ldmVyJykge1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobGVnZW5kTW9kZSA9PT0gJ2ZvbGxvdycpIHtcbiAgICAvLyBjcmVhdGUgZmxvYXRpbmcgbGVnZW5kIGRpdlxuICAgIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG4gICAgdmFyIGxhYmVsc0RpdldpZHRoID0gdGhpcy5sZWdlbmRfZGl2Xy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgeUF4aXNMYWJlbFdpZHRoID0gZS5keWdyYXBoLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgJ3knKTtcbiAgICAvLyBkZXRlcm1pbmUgZmxvYXRpbmcgW2xlZnQsIHRvcF0gY29vcmRpbmF0ZXMgb2YgdGhlIGxlZ2VuZCBkaXZcbiAgICAvLyB3aXRoaW4gdGhlIHBsb3R0ZXJfIGFyZWFcbiAgICAvLyBvZmZzZXQgNTAgcHggdG8gdGhlIHJpZ2h0IGFuZCBkb3duIGZyb20gdGhlIGZpcnN0IHNlbGVjdGlvbiBwb2ludFxuICAgIC8vIDUwIHB4IGlzIGd1ZXNzIGJhc2VkIG9uIG1vdXNlIGN1cnNvciBzaXplXG4gICAgdmFyIGxlZnRMZWdlbmQgPSBwb2ludHNbMF0ueCAqIGFyZWEudyArIDUwO1xuICAgIHZhciB0b3BMZWdlbmQgID0gcG9pbnRzWzBdLnkgKiBhcmVhLmggLSA1MDtcblxuICAgIC8vIGlmIGxlZ2VuZCBmbG9hdHMgdG8gZW5kIG9mIHRoZSBjaGFydCBhcmVhLCBpdCBmbGlwcyB0byB0aGUgb3RoZXJcbiAgICAvLyBzaWRlIG9mIHRoZSBzZWxlY3Rpb24gcG9pbnRcbiAgICBpZiAoKGxlZnRMZWdlbmQgKyBsYWJlbHNEaXZXaWR0aCArIDEpID4gYXJlYS53KSB7XG4gICAgICBsZWZ0TGVnZW5kID0gbGVmdExlZ2VuZCAtIDIgKiA1MCAtIGxhYmVsc0RpdldpZHRoIC0gKHlBeGlzTGFiZWxXaWR0aCAtIGFyZWEueCk7XG4gICAgfVxuXG4gICAgZS5keWdyYXBoLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMubGVnZW5kX2Rpdl8pO1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUubGVmdCA9IHlBeGlzTGFiZWxXaWR0aCArIGxlZnRMZWdlbmQgKyBcInB4XCI7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS50b3AgPSB0b3BMZWdlbmQgKyBcInB4XCI7XG4gIH1cblxuICB2YXIgaHRtbCA9IExlZ2VuZC5nZW5lcmF0ZUxlZ2VuZEhUTUwoZS5keWdyYXBoLCB4VmFsdWUsIHBvaW50cywgdGhpcy5vbmVfZW1fd2lkdGhfLCByb3cpO1xuICB0aGlzLmxlZ2VuZF9kaXZfLmlubmVySFRNTCA9IGh0bWw7XG4gIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9ICcnO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGxlZ2VuZE1vZGUgPSBlLmR5Z3JhcGguZ2V0T3B0aW9uKCdsZWdlbmQnKTtcbiAgaWYgKGxlZ2VuZE1vZGUgIT09ICdhbHdheXMnKSB7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cblxuICAvLyBIYXZlIHRvIGRvIHRoaXMgZXZlcnkgdGltZSwgc2luY2Ugc3R5bGVzIG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgdmFyIG9uZUVtV2lkdGggPSBjYWxjdWxhdGVFbVdpZHRoSW5EaXYodGhpcy5sZWdlbmRfZGl2Xyk7XG4gIHRoaXMub25lX2VtX3dpZHRoXyA9IG9uZUVtV2lkdGg7XG5cbiAgdmFyIGh0bWwgPSBMZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MKGUuZHlncmFwaCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9uZUVtV2lkdGgsIG51bGwpO1xuICB0aGlzLmxlZ2VuZF9kaXZfLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLmRpZERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXNlbGVjdChlKTtcbn07XG5cbi8vIFJpZ2h0IGVkZ2Ugc2hvdWxkIGJlIGZsdXNoIHdpdGggdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0aW5nIGFyZWEgKHdoaWNoXG4vLyBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBkaXYsIGlmIHdlIGhhdmUgdHdvIHktYXhlcy5cbi8vIFRPRE8oZGFudmspOiBpcyBhbnkgb2YgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBDb3VsZCBqdXN0IHNldCBcInJpZ2h0XCIgaW4gXCJhY3RpdmF0ZVwiLlxuLyoqXG4gKiBQb3NpdGlvbiB0aGUgbGFiZWxzIGRpdiBzbyB0aGF0OlxuICogLSBpdHMgcmlnaHQgZWRnZSBpcyBmbHVzaCB3aXRoIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydGluZyBhcmVhXG4gKiAtIGl0cyB0b3AgZWRnZSBpcyBmbHVzaCB3aXRoIHRoZSB0b3AgZWRnZSBvZiB0aGUgY2hhcnRpbmcgYXJlYVxuICogQHByaXZhdGVcbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5wcmVkcmF3ID0gZnVuY3Rpb24oZSkge1xuICAvLyBEb24ndCB0b3VjaCBhIHVzZXItc3BlY2lmaWVkIGxhYmVsc0Rpdi5cbiAgaWYgKCF0aGlzLmlzX2dlbmVyYXRlZF9kaXZfKSByZXR1cm47XG5cbiAgLy8gVE9ETyhkYW52ayk6IG9ubHkgdXNlIHJlYWwgQVBJcyBmb3IgdGhpcy5cbiAgZS5keWdyYXBoLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMubGVnZW5kX2Rpdl8pO1xuICB2YXIgYXJlYSA9IGUuZHlncmFwaC5nZXRBcmVhKCk7XG4gIHZhciBsYWJlbHNEaXZXaWR0aCA9IHRoaXMubGVnZW5kX2Rpdl8ub2Zmc2V0V2lkdGg7XG4gIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUubGVmdCA9IGFyZWEueCArIGFyZWEudyAtIGxhYmVsc0RpdldpZHRoIC0gMSArIFwicHhcIjtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS50b3AgPSBhcmVhLnkgKyBcInB4XCI7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGR5Z3JhcGguZGVzdHJveSgpIGlzIGNhbGxlZC5cbiAqIFlvdSBzaG91bGQgbnVsbCBvdXQgYW55IHJlZmVyZW5jZXMgYW5kIGRldGFjaCBhbnkgRE9NIGVsZW1lbnRzLlxuICovXG5MZWdlbmQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sZWdlbmRfZGl2XyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBIVE1MIGZvciB0aGUgbGVnZW5kIHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhlXG4gKiBjaGFydC4gSWYgbm8gc2VsZWN0ZWQgcG9pbnRzIGFyZSBzcGVjaWZpZWQsIGEgZGVmYXVsdCBsZWdlbmQgaXMgcmV0dXJuZWRcbiAqICh0aGlzIG1heSBqdXN0IGJlIHRoZSBlbXB0eSBzdHJpbmcpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHgtdmFsdWUgb2YgdGhlIHNlbGVjdGVkIHBvaW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxfcG9pbnRzIExpc3Qgb2Ygc2VsZWN0ZWQgcG9pbnRzIGZvciB0aGUgZ2l2ZW5cbiAqICAgeC12YWx1ZS4gU2hvdWxkIGhhdmUgcHJvcGVydGllcyBsaWtlICduYW1lJywgJ3l2YWwnIGFuZCAnY2FudmFzeScuXG4gKiBAcGFyYW0ge251bWJlcn0gb25lRW1XaWR0aCBUaGUgcGl4ZWwgd2lkdGggZm9yIDFlbSBpbiB0aGUgbGVnZW5kLiBPbmx5XG4gKiAgIHJlbGV2YW50IHdoZW4gZGlzcGxheWluZyBhIGxlZ2VuZCB3aXRoIG5vIHNlbGVjdGlvbiAoaS5lLiB7bGVnZW5kOlxuICogICAnYWx3YXlzJ30pIGFuZCB3aXRoIGRhc2hlZCBsaW5lcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgVGhlIHNlbGVjdGVkIHJvdyBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbkxlZ2VuZC5nZW5lcmF0ZUxlZ2VuZEhUTUwgPSBmdW5jdGlvbihnLCB4LCBzZWxfcG9pbnRzLCBvbmVFbVdpZHRoLCByb3cpIHtcbiAgLy8gRGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIHRvIHBhc3MgdG8gbGVnZW5kRm9ybWF0dGVyXG4gIHZhciBkYXRhID0ge1xuICAgIGR5Z3JhcGg6IGcsXG4gICAgeDogeCxcbiAgICBzZXJpZXM6IFtdXG4gIH07XG5cbiAgdmFyIGxhYmVsVG9TZXJpZXMgPSB7fTtcbiAgdmFyIGxhYmVscyA9IGcuZ2V0TGFiZWxzKCk7XG4gIGlmIChsYWJlbHMpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlcmllcyA9IGcuZ2V0UHJvcGVydGllc0ZvclNlcmllcyhsYWJlbHNbaV0pO1xuICAgICAgdmFyIHN0cm9rZVBhdHRlcm4gPSBnLmdldE9wdGlvbignc3Ryb2tlUGF0dGVybicsIGxhYmVsc1tpXSk7XG4gICAgICB2YXIgc2VyaWVzRGF0YSA9IHtcbiAgICAgICAgZGFzaEhUTUw6IGdlbmVyYXRlTGVnZW5kRGFzaEhUTUwoc3Ryb2tlUGF0dGVybiwgc2VyaWVzLmNvbG9yLCBvbmVFbVdpZHRoKSxcbiAgICAgICAgbGFiZWw6IGxhYmVsc1tpXSxcbiAgICAgICAgbGFiZWxIVE1MOiBlc2NhcGVIVE1MKGxhYmVsc1tpXSksXG4gICAgICAgIGlzVmlzaWJsZTogc2VyaWVzLnZpc2libGUsXG4gICAgICAgIGNvbG9yOiBzZXJpZXMuY29sb3JcbiAgICAgIH07XG5cbiAgICAgIGRhdGEuc2VyaWVzLnB1c2goc2VyaWVzRGF0YSk7XG4gICAgICBsYWJlbFRvU2VyaWVzW2xhYmVsc1tpXV0gPSBzZXJpZXNEYXRhO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YoeCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHhPcHRWaWV3ID0gZy5vcHRpb25zVmlld0ZvckF4aXNfKCd4Jyk7XG4gICAgdmFyIHh2ZiA9IHhPcHRWaWV3KCd2YWx1ZUZvcm1hdHRlcicpO1xuICAgIGRhdGEueEhUTUwgPSB4dmYuY2FsbChnLCB4LCB4T3B0VmlldywgbGFiZWxzWzBdLCBnLCByb3csIDApO1xuXG4gICAgdmFyIHlPcHRWaWV3cyA9IFtdO1xuICAgIHZhciBudW1fYXhlcyA9IGcubnVtQXhlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2F4ZXM7IGkrKykge1xuICAgICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZSB0aGlzIHVzZSBvZiBhIHByaXZhdGUgQVBJXG4gICAgICB5T3B0Vmlld3NbaV0gPSBnLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3knICsgKGkgPyAxICsgaSA6ICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHNob3daZXJvcyA9IGcuZ2V0T3B0aW9uKCdsYWJlbHNTaG93WmVyb1ZhbHVlcycpO1xuICAgIHZhciBoaWdobGlnaHRTZXJpZXMgPSBnLmdldEhpZ2hsaWdodFNlcmllcygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWxfcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSBzZWxfcG9pbnRzW2ldO1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSBsYWJlbFRvU2VyaWVzW3B0Lm5hbWVdO1xuICAgICAgc2VyaWVzRGF0YS55ID0gcHQueXZhbDtcblxuICAgICAgaWYgKChwdC55dmFsID09PSAwICYmICFzaG93WmVyb3MpIHx8IGlzTmFOKHB0LmNhbnZhc3kpKSB7XG4gICAgICAgIHNlcmllc0RhdGEuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzID0gZy5nZXRQcm9wZXJ0aWVzRm9yU2VyaWVzKHB0Lm5hbWUpO1xuICAgICAgdmFyIHlPcHRWaWV3ID0geU9wdFZpZXdzW3Nlcmllcy5heGlzIC0gMV07XG4gICAgICB2YXIgZm10RnVuYyA9IHlPcHRWaWV3KCd2YWx1ZUZvcm1hdHRlcicpO1xuICAgICAgdmFyIHlIVE1MID0gZm10RnVuYy5jYWxsKGcsIHB0Lnl2YWwsIHlPcHRWaWV3LCBwdC5uYW1lLCBnLCByb3csIGxhYmVscy5pbmRleE9mKHB0Lm5hbWUpKTtcblxuICAgICAgdXRpbHMudXBkYXRlKHNlcmllc0RhdGEsIHt5SFRNTH0pO1xuXG4gICAgICBpZiAocHQubmFtZSA9PSBoaWdobGlnaHRTZXJpZXMpIHtcbiAgICAgICAgc2VyaWVzRGF0YS5pc0hpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZm9ybWF0dGVyID0gKGcuZ2V0T3B0aW9uKCdsZWdlbmRGb3JtYXR0ZXInKSB8fCBMZWdlbmQuZGVmYXVsdEZvcm1hdHRlcik7XG4gIHJldHVybiBmb3JtYXR0ZXIuY2FsbChnLCBkYXRhKTtcbn1cblxuTGVnZW5kLmRlZmF1bHRGb3JtYXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBnID0gZGF0YS5keWdyYXBoO1xuXG4gIC8vIFRPRE8oZGFudmspOiBkZXByZWNhdGUgdGhpcyBvcHRpb24gaW4gcGxhY2Ugb2Yge2xlZ2VuZDogJ25ldmVyJ31cbiAgLy8gWFhYIHNob3VsZCB0aGlzIGxvZ2ljIGJlIGluIHRoZSBmb3JtYXR0ZXI/XG4gIGlmIChnLmdldE9wdGlvbignc2hvd0xhYmVsc09uSGlnaGxpZ2h0JykgIT09IHRydWUpIHJldHVybiAnJztcblxuICB2YXIgc2VwTGluZXMgPSBnLmdldE9wdGlvbignbGFiZWxzU2VwYXJhdGVMaW5lcycpO1xuICB2YXIgaHRtbDtcblxuICBpZiAodHlwZW9mKGRhdGEueCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETzogdGhpcyBjaGVjayBpcyBkdXBsaWNhdGVkIGluIGdlbmVyYXRlTGVnZW5kSFRNTC4gUHV0IGl0IGluIG9uZSBwbGFjZS5cbiAgICBpZiAoZy5nZXRPcHRpb24oJ2xlZ2VuZCcpICE9ICdhbHdheXMnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaHRtbCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZXJpZXMgPSBkYXRhLnNlcmllc1tpXTtcbiAgICAgIGlmICghc2VyaWVzLmlzVmlzaWJsZSkgY29udGludWU7XG5cbiAgICAgIGlmIChodG1sICE9PSAnJykgaHRtbCArPSAoc2VwTGluZXMgPyAnPGJyLz4nIDogJyAnKTtcbiAgICAgIGh0bWwgKz0gYDxzcGFuIHN0eWxlPSdmb250LXdlaWdodDogYm9sZDsgY29sb3I6ICR7c2VyaWVzLmNvbG9yfTsnPiR7c2VyaWVzLmRhc2hIVE1MfSAke3Nlcmllcy5sYWJlbEhUTUx9PC9zcGFuPmA7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgaHRtbCA9IGRhdGEueEhUTUwgKyAnOic7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VyaWVzID0gZGF0YS5zZXJpZXNbaV07XG4gICAgaWYgKCFzZXJpZXMuaXNWaXNpYmxlKSBjb250aW51ZTtcbiAgICBpZiAoc2VwTGluZXMpIGh0bWwgKz0gJzxicj4nO1xuICAgIHZhciBjbHMgPSBzZXJpZXMuaXNIaWdobGlnaHRlZCA/ICcgY2xhc3M9XCJoaWdobGlnaHRcIicgOiAnJztcbiAgICBodG1sICs9IGA8c3BhbiR7Y2xzfT4gPGI+PHNwYW4gc3R5bGU9J2NvbG9yOiAke3Nlcmllcy5jb2xvcn07Jz4ke3Nlcmllcy5sYWJlbEhUTUx9PC9zcGFuPjwvYj46JiMxNjA7JHtzZXJpZXMueUhUTUx9PC9zcGFuPmA7XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5cbi8qKlxuICogR2VuZXJhdGVzIGh0bWwgZm9yIHRoZSBcImRhc2hcIiBkaXNwbGF5ZWQgb24gdGhlIGxlZ2VuZCB3aGVuIHVzaW5nIFwibGVnZW5kOiBhbHdheXNcIi5cbiAqIEluIHBhcnRpY3VsYXIsIHRoaXMgd29ya3MgZm9yIGRhc2hlZCBsaW5lcyB3aXRoIGFueSBzdHJva2UgcGF0dGVybi4gSXQgd2lsbFxuICogdHJ5IHRvIHNjYWxlIHRoZSBwYXR0ZXJuIHRvIGZpdCBpbiAxZW0gd2lkdGguIE9yIGlmIHNtYWxsIGVub3VnaCByZXBlYXQgdGhlXG4gKiBwYXR0ZXJuIGZvciAxZW0gd2lkdGguXG4gKlxuICogQHBhcmFtIHN0cm9rZVBhdHRlcm4gVGhlIHBhdHRlcm5cbiAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHNlcmllcy5cbiAqIEBwYXJhbSBvbmVFbVdpZHRoIFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgMWVtIGluIHRoZSBsZWdlbmQuXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBUT0RPKGRhbnZrKTogY2FjaGUgdGhlIHJlc3VsdHMgb2YgdGhpc1xuZnVuY3Rpb24gZ2VuZXJhdGVMZWdlbmREYXNoSFRNTChzdHJva2VQYXR0ZXJuLCBjb2xvciwgb25lRW1XaWR0aCkge1xuICAvLyBFYXN5LCBjb21tb24gY2FzZTogYSBzb2xpZCBsaW5lXG4gIGlmICghc3Ryb2tlUGF0dGVybiB8fCBzdHJva2VQYXR0ZXJuLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiZHlncmFwaC1sZWdlbmQtbGluZVwiIHN0eWxlPVwiYm9yZGVyLWJvdHRvbS1jb2xvcjogJHtjb2xvcn07XCI+PC9kaXY+YDtcbiAgfVxuXG4gIHZhciBpLCBqLCBwYWRkaW5nTGVmdCwgbWFyZ2luUmlnaHQ7XG4gIHZhciBzdHJva2VQaXhlbExlbmd0aCA9IDAsIHNlZ21lbnRMb29wID0gMDtcbiAgdmFyIG5vcm1hbGl6ZWRQYXR0ZXJuID0gW107XG4gIHZhciBsb29wO1xuXG4gIC8vIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgcGl4ZWxzIGluY2x1ZGluZyB0aGUgZmlyc3Qgc2VnbWVudCB0d2ljZSwgXG4gIC8vIHNpbmNlIHdlIHJlcGVhdCBpdC5cbiAgZm9yIChpID0gMDsgaSA8PSBzdHJva2VQYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Ryb2tlUGl4ZWxMZW5ndGggKz0gc3Ryb2tlUGF0dGVybltpJXN0cm9rZVBhdHRlcm4ubGVuZ3RoXTtcbiAgfVxuXG4gIC8vIFNlZSBpZiB3ZSBjYW4gbG9vcCB0aGUgcGF0dGVybiBieSBpdHNlbGYgYXQgbGVhc3QgdHdpY2UuXG4gIGxvb3AgPSBNYXRoLmZsb29yKG9uZUVtV2lkdGgvKHN0cm9rZVBpeGVsTGVuZ3RoLXN0cm9rZVBhdHRlcm5bMF0pKTtcbiAgaWYgKGxvb3AgPiAxKSB7XG4gICAgLy8gVGhpcyBwYXR0ZXJuIGZpdHMgYXQgbGVhc3QgdHdvIHRpbWVzLCBubyBzY2FsaW5nIGp1c3QgY29udmVydCB0byBlbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFBhdHRlcm5baV0gPSBzdHJva2VQYXR0ZXJuW2ldL29uZUVtV2lkdGg7XG4gICAgfVxuICAgIC8vIFNpbmNlIHdlIGFyZSByZXBlYXRpbmcgdGhlIHBhdHRlcm4sIHdlIGRvbid0IHdvcnJ5IGFib3V0IHJlcGVhdGluZyB0aGVcbiAgICAvLyBmaXJzdCBzZWdtZW50IGluIG9uZSBkcmF3LlxuICAgIHNlZ21lbnRMb29wID0gbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBwYXR0ZXJuIGRvZXNuJ3QgZml0IGluIHRoZSBsZWdlbmQgd2Ugc2NhbGUgaXQgdG8gZml0LlxuICAgIGxvb3AgPSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJva2VQYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkUGF0dGVybltpXSA9IHN0cm9rZVBhdHRlcm5baV0vc3Ryb2tlUGl4ZWxMZW5ndGg7XG4gICAgfVxuICAgIC8vIEZvciB0aGUgc2NhbGVkIHBhdHRlcm5zIHdlIGRvIHJlZHJhdyB0aGUgZmlyc3Qgc2VnbWVudC5cbiAgICBzZWdtZW50TG9vcCA9IG5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aCsxO1xuICB9XG5cbiAgLy8gTm93IG1ha2UgdGhlIHBhdHRlcm4uXG4gIHZhciBkYXNoID0gXCJcIjtcbiAgZm9yIChqID0gMDsgaiA8IGxvb3A7IGorKykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdtZW50TG9vcDsgaSs9Mikge1xuICAgICAgLy8gVGhlIHBhZGRpbmcgaXMgdGhlIGRyYXduIHNlZ21lbnQuXG4gICAgICBwYWRkaW5nTGVmdCA9IG5vcm1hbGl6ZWRQYXR0ZXJuW2klbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIGlmIChpIDwgc3Ryb2tlUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIG1hcmdpbiBpcyB0aGUgc3BhY2Ugc2VnbWVudC5cbiAgICAgICAgbWFyZ2luUmlnaHQgPSBub3JtYWxpemVkUGF0dGVyblsoaSsxKSVub3JtYWxpemVkUGF0dGVybi5sZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJlcGVhdGVkIGZpcnN0IHNlZ21lbnQgaGFzIG5vIHJpZ2h0IG1hcmdpbi5cbiAgICAgICAgbWFyZ2luUmlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgZGFzaCArPSBgPGRpdiBjbGFzcz1cImR5Z3JhcGgtbGVnZW5kLWRhc2hcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogJHttYXJnaW5SaWdodH1lbTsgcGFkZGluZy1sZWZ0OiAke3BhZGRpbmdMZWZ0fWVtO1wiPjwvZGl2PmA7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXNoO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTGVnZW5kO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _iframe_tarp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);\n/**\n * @license\n * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n/*global Dygraph:false,TouchEvent:false */\n\n/**\n * @fileoverview This file contains the RangeSelector plugin used to provide\n * a timeline range selector widget for dygraphs.\n */\n\n/*global Dygraph:false */\n\n\n\n\n\n\nvar rangeSelector = function() {\n  this.hasTouchInterface_ = typeof(TouchEvent) != 'undefined';\n  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);\n  this.interfaceCreated_ = false;\n};\n\nrangeSelector.prototype.toString = function() {\n  return \"RangeSelector Plugin\";\n};\n\nrangeSelector.prototype.activate = function(dygraph) {\n  this.dygraph_ = dygraph;\n  if (this.getOption_('showRangeSelector')) {\n    this.createInterface_();\n  }\n  return {\n    layout: this.reserveSpace_,\n    predraw: this.renderStaticLayer_,\n    didDrawChart: this.renderInteractiveLayer_\n  };\n};\n\nrangeSelector.prototype.destroy = function() {\n  this.bgcanvas_ = null;\n  this.fgcanvas_ = null;\n  this.leftZoomHandle_ = null;\n  this.rightZoomHandle_ = null;\n};\n\n//------------------------------------------------------------------\n// Private methods\n//------------------------------------------------------------------\n\nrangeSelector.prototype.getOption_ = function(name, opt_series) {\n  return this.dygraph_.getOption(name, opt_series);\n};\n\nrangeSelector.prototype.setDefaultOption_ = function(name, value) {\n  this.dygraph_.attrs_[name] = value;\n};\n\n/**\n * @private\n * Creates the range selector elements and adds them to the graph.\n */\nrangeSelector.prototype.createInterface_ = function() {\n  this.createCanvases_();\n  this.createZoomHandles_();\n  this.initInteraction_();\n\n  // Range selector and animatedZooms have a bad interaction. See issue 359.\n  if (this.getOption_('animatedZooms')) {\n    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');\n    this.dygraph_.updateOptions({animatedZooms: false}, true);\n  }\n\n  this.interfaceCreated_ = true;\n  this.addToGraph_();\n};\n\n/**\n * @private\n * Adds the range selector to the graph.\n */\nrangeSelector.prototype.addToGraph_ = function() {\n  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;\n  graphDiv.appendChild(this.bgcanvas_);\n  graphDiv.appendChild(this.fgcanvas_);\n  graphDiv.appendChild(this.leftZoomHandle_);\n  graphDiv.appendChild(this.rightZoomHandle_);\n};\n\n/**\n * @private\n * Removes the range selector from the graph.\n */\nrangeSelector.prototype.removeFromGraph_ = function() {\n  var graphDiv = this.graphDiv_;\n  graphDiv.removeChild(this.bgcanvas_);\n  graphDiv.removeChild(this.fgcanvas_);\n  graphDiv.removeChild(this.leftZoomHandle_);\n  graphDiv.removeChild(this.rightZoomHandle_);\n  this.graphDiv_ = null;\n};\n\n/**\n * @private\n * Called by Layout to allow range selector to reserve its space.\n */\nrangeSelector.prototype.reserveSpace_ = function(e) {\n  if (this.getOption_('showRangeSelector')) {\n    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);\n  }\n};\n\n/**\n * @private\n * Renders the static portion of the range selector at the predraw stage.\n */\nrangeSelector.prototype.renderStaticLayer_ = function() {\n  if (!this.updateVisibility_()) {\n    return;\n  }\n  this.resize_();\n  this.drawStaticLayer_();\n};\n\n/**\n * @private\n * Renders the interactive portion of the range selector after the chart has been drawn.\n */\nrangeSelector.prototype.renderInteractiveLayer_ = function() {\n  if (!this.updateVisibility_() || this.isChangingRange_) {\n    return;\n  }\n  this.placeZoomHandles_();\n  this.drawInteractiveLayer_();\n};\n\n/**\n * @private\n * Check to see if the range selector is enabled/disabled and update visibility accordingly.\n */\nrangeSelector.prototype.updateVisibility_ = function() {\n  var enabled = this.getOption_('showRangeSelector');\n  if (enabled) {\n    if (!this.interfaceCreated_) {\n      this.createInterface_();\n    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {\n      this.addToGraph_();\n    }\n  } else if (this.graphDiv_) {\n    this.removeFromGraph_();\n    var dygraph = this.dygraph_;\n    setTimeout(function() { dygraph.width_ = 0; dygraph.resize(); }, 1);\n  }\n  return enabled;\n};\n\n/**\n * @private\n * Resizes the range selector.\n */\nrangeSelector.prototype.resize_ = function() {\n  function setElementRect(canvas, context, rect, pixelRatioOption) {\n    var canvasScale = pixelRatioOption || _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* getContextPixelRatio */ \"y\"](context);\n\n    canvas.style.top = rect.y + 'px';\n    canvas.style.left = rect.x + 'px';\n    canvas.width = rect.w * canvasScale;\n    canvas.height = rect.h * canvasScale;\n    canvas.style.width = rect.w + 'px';\n    canvas.style.height = rect.h + 'px';\n\n    if(canvasScale != 1) {\n      context.scale(canvasScale, canvasScale);\n    }\n  }\n\n  var plotArea = this.dygraph_.layout_.getPlotArea();\n\n  var xAxisLabelHeight = 0;\n  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {\n    xAxisLabelHeight = this.getOption_('xAxisHeight') || (this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize'));\n  }\n  this.canvasRect_ = {\n    x: plotArea.x,\n    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,\n    w: plotArea.w,\n    h: this.getOption_('rangeSelectorHeight')\n  };\n\n  var pixelRatioOption = this.dygraph_.getNumericOption('pixelRatio');\n  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_, pixelRatioOption);\n};\n\n/**\n * @private\n * Creates the background and foreground canvases.\n */\nrangeSelector.prototype.createCanvases_ = function() {\n  this.bgcanvas_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* createCanvas */ \"m\"]();\n  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';\n  this.bgcanvas_.style.position = 'absolute';\n  this.bgcanvas_.style.zIndex = 9;\n  this.bgcanvas_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* getContext */ \"x\"](this.bgcanvas_);\n\n  this.fgcanvas_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* createCanvas */ \"m\"]();\n  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';\n  this.fgcanvas_.style.position = 'absolute';\n  this.fgcanvas_.style.zIndex = 9;\n  this.fgcanvas_.style.cursor = 'default';\n  this.fgcanvas_ctx_ = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* getContext */ \"x\"](this.fgcanvas_);\n};\n\n/**\n * @private\n * Creates the zoom handle elements.\n */\nrangeSelector.prototype.createZoomHandles_ = function() {\n  var img = new Image();\n  img.className = 'dygraph-rangesel-zoomhandle';\n  img.style.position = 'absolute';\n  img.style.zIndex = 10;\n  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.\n  img.style.cursor = 'col-resize';\n  // TODO: change image to more options\n  img.width = 9;\n  img.height = 16;\n  img.src = 'data:image/png;base64,' +\n'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' +\n'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' +\n'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' +\n'6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' +\n'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';\n\n  if (this.isMobileDevice_) {\n    img.width *= 2;\n    img.height *= 2;\n  }\n\n  this.leftZoomHandle_ = img;\n  this.rightZoomHandle_ = img.cloneNode(false);\n};\n\n/**\n * @private\n * Sets up the interaction for the range selector.\n */\nrangeSelector.prototype.initInteraction_ = function() {\n  var self = this;\n  var topElem = document;\n  var clientXLast = 0;\n  var handle = null;\n  var isZooming = false;\n  var isPanning = false;\n  var dynamic = !this.isMobileDevice_;\n\n  // We cover iframes during mouse interactions. See comments in\n  // dygraph-utils.js for more info on why this is a good idea.\n  var tarp = new _iframe_tarp__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]();\n\n  // functions, defined below.  Defining them this way (rather than with\n  // \"function foo() {...}\" makes JSHint happy.\n  var toXDataWindow, onZoomStart, onZoom, onZoomEnd, doZoom, isMouseInPanZone,\n      onPanStart, onPan, onPanEnd, doPan, onCanvasHover;\n\n  // Touch event functions\n  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;\n\n  toXDataWindow = function(zoomHandleStatus) {\n    var xDataLimits = self.dygraph_.xAxisExtremes();\n    var fact = (xDataLimits[1] - xDataLimits[0])/self.canvasRect_.w;\n    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x)*fact;\n    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x)*fact;\n    return [xDataMin, xDataMax];\n  };\n\n  onZoomStart = function(e) {\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n    isZooming = true;\n    clientXLast = e.clientX;\n    handle = e.target ? e.target : e.srcElement;\n    if (e.type === 'mousedown' || e.type === 'dragstart') {\n      // These events are removed manually.\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* addEvent */ \"i\"](topElem, 'mousemove', onZoom);\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* addEvent */ \"i\"](topElem, 'mouseup', onZoomEnd);\n    }\n    self.fgcanvas_.style.cursor = 'col-resize';\n    tarp.cover();\n    return true;\n  };\n\n  onZoom = function(e) {\n    if (!isZooming) {\n      return false;\n    }\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move handle.\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var newPos;\n    if (handle == self.leftZoomHandle_) {\n      newPos = zoomHandleStatus.leftHandlePos + delX;\n      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);\n      newPos = Math.max(newPos, self.canvasRect_.x);\n    } else {\n      newPos = zoomHandleStatus.rightHandlePos + delX;\n      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);\n      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);\n    }\n    var halfHandleWidth = handle.width/2;\n    handle.style.left = (newPos - halfHandleWidth) + 'px';\n    self.drawInteractiveLayer_();\n\n    // Zoom on the fly.\n    if (dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  onZoomEnd = function(e) {\n    if (!isZooming) {\n      return false;\n    }\n    isZooming = false;\n    tarp.uncover();\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ \"O\"](topElem, 'mousemove', onZoom);\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ \"O\"](topElem, 'mouseup', onZoomEnd);\n    self.fgcanvas_.style.cursor = 'default';\n\n    // If on a slower device, zoom now.\n    if (!dynamic) {\n      doZoom();\n    }\n    return true;\n  };\n\n  doZoom = function() {\n    try {\n      var zoomHandleStatus = self.getZoomHandleStatus_();\n      self.isChangingRange_ = true;\n      if (!zoomHandleStatus.isZoomed) {\n        self.dygraph_.resetZoom();\n      } else {\n        var xDataWindow = toXDataWindow(zoomHandleStatus);\n        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);\n      }\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  isMouseInPanZone = function(e) {\n    var rect = self.leftZoomHandle_.getBoundingClientRect();\n    var leftHandleClientX = rect.left + rect.width/2;\n    rect = self.rightZoomHandle_.getBoundingClientRect();\n    var rightHandleClientX = rect.left + rect.width/2;\n    return (e.clientX > leftHandleClientX && e.clientX < rightHandleClientX);\n  };\n\n  onPanStart = function(e) {\n    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {\n      _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n      isPanning = true;\n      clientXLast = e.clientX;\n      if (e.type === 'mousedown') {\n        // These events are removed manually.\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* addEvent */ \"i\"](topElem, 'mousemove', onPan);\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* addEvent */ \"i\"](topElem, 'mouseup', onPanEnd);\n      }\n      return true;\n    }\n    return false;\n  };\n\n  onPan = function(e) {\n    if (!isPanning) {\n      return false;\n    }\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n\n    var delX = e.clientX - clientXLast;\n    if (Math.abs(delX) < 4) {\n      return true;\n    }\n    clientXLast = e.clientX;\n\n    // Move range view\n    var zoomHandleStatus = self.getZoomHandleStatus_();\n    var leftHandlePos = zoomHandleStatus.leftHandlePos;\n    var rightHandlePos = zoomHandleStatus.rightHandlePos;\n    var rangeSize = rightHandlePos - leftHandlePos;\n    if (leftHandlePos + delX <= self.canvasRect_.x) {\n      leftHandlePos = self.canvasRect_.x;\n      rightHandlePos = leftHandlePos + rangeSize;\n    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {\n      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;\n      leftHandlePos = rightHandlePos - rangeSize;\n    } else {\n      leftHandlePos += delX;\n      rightHandlePos += delX;\n    }\n    var halfHandleWidth = self.leftZoomHandle_.width/2;\n    self.leftZoomHandle_.style.left = (leftHandlePos - halfHandleWidth) + 'px';\n    self.rightZoomHandle_.style.left = (rightHandlePos - halfHandleWidth) + 'px';\n    self.drawInteractiveLayer_();\n\n    // Do pan on the fly.\n    if (dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  onPanEnd = function(e) {\n    if (!isPanning) {\n      return false;\n    }\n    isPanning = false;\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ \"O\"](topElem, 'mousemove', onPan);\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* removeEvent */ \"O\"](topElem, 'mouseup', onPanEnd);\n    // If on a slower device, do pan now.\n    if (!dynamic) {\n      doPan();\n    }\n    return true;\n  };\n\n  doPan = function() {\n    try {\n      self.isChangingRange_ = true;\n      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());\n      self.dygraph_.drawGraph_(false);\n    } finally {\n      self.isChangingRange_ = false;\n    }\n  };\n\n  onCanvasHover = function(e) {\n    if (isZooming || isPanning) {\n      return;\n    }\n    var cursor = isMouseInPanZone(e) ? 'move' : 'default';\n    if (cursor != self.fgcanvas_.style.cursor) {\n      self.fgcanvas_.style.cursor = cursor;\n    }\n  };\n\n  onZoomHandleTouchEvent = function(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onZoomStart(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onZoom(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n      }\n    } else {\n      onZoomEnd(e);\n    }\n  };\n\n  onCanvasTouchEvent = function(e) {\n    if (e.type == 'touchstart' && e.targetTouches.length == 1) {\n      if (onPanStart(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n      }\n    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {\n      if (onPan(e.targetTouches[0])) {\n        _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* cancelEvent */ \"k\"](e);\n      }\n    } else {\n      onPanEnd(e);\n    }\n  };\n\n  addTouchEvents = function(elem, fn) {\n    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\n    for (var i = 0; i < types.length; i++) {\n      self.dygraph_.addAndTrackEvent(elem, types[i], fn);\n    }\n  };\n\n  this.setDefaultOption_('interactionModel', _dygraph_interaction_model__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].dragIsPanInteractionModel);\n  this.setDefaultOption_('panEdgeFraction', 0.0001);\n\n  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';\n  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);\n  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);\n\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);\n  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);\n\n  // Touch events\n  if (this.hasTouchInterface_) {\n    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);\n    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);\n  }\n};\n\n/**\n * @private\n * Draws the static layer in the background canvas.\n */\nrangeSelector.prototype.drawStaticLayer_ = function() {\n  var ctx = this.bgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  try {\n    this.drawMiniPlot_();\n  } catch(ex) {\n    console.warn(ex);\n  }\n\n  var margin = 0.5;\n  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');\n  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');\n  ctx.beginPath();\n  ctx.moveTo(margin, margin);\n  ctx.lineTo(margin, this.canvasRect_.h-margin);\n  ctx.lineTo(this.canvasRect_.w-margin, this.canvasRect_.h-margin);\n  ctx.lineTo(this.canvasRect_.w-margin, margin);\n  ctx.stroke();\n};\n\n\n/**\n * @private\n * Draws the mini plot in the background canvas.\n */\nrangeSelector.prototype.drawMiniPlot_ = function() {\n  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');\n  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');\n  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');\n  if (!fillStyle && !strokeStyle) {\n    return;\n  }\n\n  var stepPlot = this.getOption_('stepPlot');\n\n  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();\n  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;\n\n  // Draw the mini plot.\n  var ctx = this.bgcanvas_ctx_;\n  var margin = 0.5;\n\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);\n  var xFact = (this.canvasRect_.w - margin)/xRange;\n  var yFact = (this.canvasRect_.h - margin)/yRange;\n  var canvasWidth = this.canvasRect_.w - margin;\n  var canvasHeight = this.canvasRect_.h - margin;\n\n  var prevX = null, prevY = null;\n\n  ctx.beginPath();\n  ctx.moveTo(margin, canvasHeight);\n  for (var i = 0; i < combinedSeriesData.data.length; i++) {\n    var dataPoint = combinedSeriesData.data[i];\n    var x = ((dataPoint[0] !== null) ? ((dataPoint[0] - xExtremes[0])*xFact) : NaN);\n    var y = ((dataPoint[1] !== null) ? (canvasHeight - (dataPoint[1] - combinedSeriesData.yMin)*yFact) : NaN);\n\n    // Skip points that don't change the x-value. Overly fine-grained points\n    // can cause major slowdowns with the ctx.fill() call below.\n    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {\n      continue;\n    }\n\n    if (isFinite(x) && isFinite(y)) {\n      if(prevX === null) {\n        ctx.lineTo(x, canvasHeight);\n      }\n      else if (stepPlot) {\n        ctx.lineTo(x, prevY);\n      }\n      ctx.lineTo(x, y);\n      prevX = x;\n      prevY = y;\n    }\n    else {\n      if(prevX !== null) {\n        if (stepPlot) {\n          ctx.lineTo(x, prevY);\n          ctx.lineTo(x, canvasHeight);\n        }\n        else {\n          ctx.lineTo(prevX, canvasHeight);\n        }\n      }\n      prevX = prevY = null;\n    }\n  }\n  ctx.lineTo(canvasWidth, canvasHeight);\n  ctx.closePath();\n\n  if (fillStyle) {\n    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);\n    if (fillGradientStyle) {\n      lingrad.addColorStop(0, fillGradientStyle);\n    }\n    lingrad.addColorStop(1, fillStyle);\n    this.bgcanvas_ctx_.fillStyle = lingrad;\n    ctx.fill();\n  }\n\n  if (strokeStyle) {\n    this.bgcanvas_ctx_.strokeStyle = strokeStyle;\n    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Computes and returns the combined series data along with min/max for the mini plot.\n * The combined series consists of averaged values for all series.\n * When series have error bars, the error bars are ignored.\n * @return {Object} An object containing combined series array, ymin, ymax.\n */\nrangeSelector.prototype.computeCombinedSeriesAndLimits_ = function() {\n  var g = this.dygraph_;\n  var logscale = this.getOption_('logscale');\n  var i;\n\n  // Select series to combine. By default, all series are combined.\n  var numColumns = g.numColumns();\n  var labels = g.getLabels();\n  var includeSeries = new Array(numColumns);\n  var anySet = false;\n  var visibility = g.visibility();\n  var inclusion = [];\n\n  for (i = 1; i < numColumns; i++) {\n    var include = this.getOption_('showInRangeSelector', labels[i]);\n    inclusion.push(include);\n    if (include !== null) anySet = true;  // it's set explicitly for this series\n  }\n\n  if (anySet) {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = inclusion[i - 1];\n    }\n  } else {\n    for (i = 1; i < numColumns; i++) {\n      includeSeries[i] = visibility[i - 1];\n    }\n  }\n\n  // Create a combined series (average of selected series values).\n  // TODO(danvk): short-circuit if there's only one series.\n  var rolledSeries = [];\n  var dataHandler = g.dataHandler_;\n  var options = g.attributes_;\n  for (i = 1; i < g.numColumns(); i++) {\n    if (!includeSeries[i]) continue;\n    var series = dataHandler.extractSeries(g.rawData_, i, options);\n    if (g.rollPeriod() > 1) {\n      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);\n    }\n\n    rolledSeries.push(series);\n  }\n\n  var combinedSeries = [];\n  for (i = 0; i < rolledSeries[0].length; i++) {\n    var sum = 0;\n    var count = 0;\n    for (var j = 0; j < rolledSeries.length; j++) {\n      var y = rolledSeries[j][i][1];\n      if (y === null || isNaN(y)) continue;\n      count++;\n      sum += y;\n    }\n    combinedSeries.push([rolledSeries[0][i][0], sum / count]);\n  }\n\n  // Compute the y range.\n  var yMin = Number.MAX_VALUE;\n  var yMax = -Number.MAX_VALUE;\n  for (i = 0; i < combinedSeries.length; i++) {\n    var yVal = combinedSeries[i][1];\n    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {\n      yMin = Math.min(yMin, yVal);\n      yMax = Math.max(yMax, yVal);\n    }\n  }\n\n  // Convert Y data to log scale if needed.\n  // Also, expand the Y range to compress the mini plot a little.\n  var extraPercent = 0.25;\n  if (logscale) {\n    yMax = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](yMax);\n    yMax += yMax*extraPercent;\n    yMin = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](yMin);\n    for (i = 0; i < combinedSeries.length; i++) {\n      combinedSeries[i][1] = _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* log10 */ \"H\"](combinedSeries[i][1]);\n    }\n  } else {\n    var yExtra;\n    var yRange = yMax - yMin;\n    if (yRange <= Number.MIN_VALUE) {\n      yExtra = yMax*extraPercent;\n    } else {\n      yExtra = yRange*extraPercent;\n    }\n    yMax += yExtra;\n    yMin -= yExtra;\n  }\n\n  return {data: combinedSeries, yMin: yMin, yMax: yMax};\n};\n\n/**\n * @private\n * Places the zoom handles in the proper position based on the current X data window.\n */\nrangeSelector.prototype.placeZoomHandles_ = function() {\n  var xExtremes = this.dygraph_.xAxisExtremes();\n  var xWindowLimits = this.dygraph_.xAxisRange();\n  var xRange = xExtremes[1] - xExtremes[0];\n  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0])/xRange);\n  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1])/xRange);\n  var leftCoord = this.canvasRect_.x + this.canvasRect_.w*leftPercent;\n  var rightCoord = this.canvasRect_.x + this.canvasRect_.w*(1 - rightPercent);\n  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height)/2);\n  var halfHandleWidth = this.leftZoomHandle_.width/2;\n  this.leftZoomHandle_.style.left = (leftCoord - halfHandleWidth) + 'px';\n  this.leftZoomHandle_.style.top = handleTop + 'px';\n  this.rightZoomHandle_.style.left = (rightCoord - halfHandleWidth) + 'px';\n  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;\n\n  this.leftZoomHandle_.style.visibility = 'visible';\n  this.rightZoomHandle_.style.visibility = 'visible';\n};\n\n/**\n * @private\n * Draws the interactive layer in the foreground canvas.\n */\nrangeSelector.prototype.drawInteractiveLayer_ = function() {\n  var ctx = this.fgcanvas_ctx_;\n  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);\n  var margin = 1;\n  var width = this.canvasRect_.w - margin;\n  var height = this.canvasRect_.h - margin;\n  var zoomHandleStatus = this.getZoomHandleStatus_();\n\n  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');\n  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');\n  if (!zoomHandleStatus.isZoomed) {\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(margin, height);\n    ctx.lineTo(width, height);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  } else {\n    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);\n    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);\n\n    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';\n    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);\n    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);\n\n    ctx.beginPath();\n    ctx.moveTo(margin, margin);\n    ctx.lineTo(leftHandleCanvasPos, margin);\n    ctx.lineTo(leftHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, height);\n    ctx.lineTo(rightHandleCanvasPos, margin);\n    ctx.lineTo(width, margin);\n    ctx.stroke();\n  }\n};\n\n/**\n * @private\n * Returns the current zoom handle position information.\n * @return {Object} The zoom handle status.\n */\nrangeSelector.prototype.getZoomHandleStatus_ = function() {\n  var halfHandleWidth = this.leftZoomHandle_.width/2;\n  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;\n  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;\n  return {\n      leftHandlePos: leftHandlePos,\n      rightHandlePos: rightHandlePos,\n      isZoomed: (leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x+this.canvasRect_.w)\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (rangeSelector);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL3BsdWdpbnMvcmFuZ2Utc2VsZWN0b3IuanM/OWM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBQYXVsIEZlbGl4IChwYXVsLmVyaWMuZmVsaXhAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlLFRvdWNoRXZlbnQ6ZmFsc2UgKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyB0aGUgUmFuZ2VTZWxlY3RvciBwbHVnaW4gdXNlZCB0byBwcm92aWRlXG4gKiBhIHRpbWVsaW5lIHJhbmdlIHNlbGVjdG9yIHdpZGdldCBmb3IgZHlncmFwaHMuXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4uL2lmcmFtZS10YXJwJztcblxudmFyIHJhbmdlU2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYXNUb3VjaEludGVyZmFjZV8gPSB0eXBlb2YoVG91Y2hFdmVudCkgIT0gJ3VuZGVmaW5lZCc7XG4gIHRoaXMuaXNNb2JpbGVEZXZpY2VfID0gL21vYmlsZXxhbmRyb2lkL2dpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pO1xuICB0aGlzLmludGVyZmFjZUNyZWF0ZWRfID0gZmFsc2U7XG59O1xuXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJSYW5nZVNlbGVjdG9yIFBsdWdpblwiO1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICBpZiAodGhpcy5nZXRPcHRpb25fKCdzaG93UmFuZ2VTZWxlY3RvcicpKSB7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IHRoaXMucmVzZXJ2ZVNwYWNlXyxcbiAgICBwcmVkcmF3OiB0aGlzLnJlbmRlclN0YXRpY0xheWVyXyxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYXllcl9cbiAgfTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSBudWxsO1xuICB0aGlzLmZnY2FudmFzXyA9IG51bGw7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gbnVsbDtcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfID0gbnVsbDtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIG1ldGhvZHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldE9wdGlvbl8gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzKSB7XG4gIHJldHVybiB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzKTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNldERlZmF1bHRPcHRpb25fID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5keWdyYXBoXy5hdHRyc19bbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIHJhbmdlIHNlbGVjdG9yIGVsZW1lbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGdyYXBoLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlQ2FudmFzZXNfKCk7XG4gIHRoaXMuY3JlYXRlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuaW5pdEludGVyYWN0aW9uXygpO1xuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIGFuZCBhbmltYXRlZFpvb21zIGhhdmUgYSBiYWQgaW50ZXJhY3Rpb24uIFNlZSBpc3N1ZSAzNTkuXG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ2FuaW1hdGVkWm9vbXMnKSkge1xuICAgIGNvbnNvbGUud2FybignQW5pbWF0ZWQgem9vbXMgYW5kIHJhbmdlIHNlbGVjdG9yIGFyZSBub3QgY29tcGF0aWJsZTsgZGlzYWJsaW5nIGFuaW1hdGVkWm9vbXMuJyk7XG4gICAgdGhpcy5keWdyYXBoXy51cGRhdGVPcHRpb25zKHthbmltYXRlZFpvb21zOiBmYWxzZX0sIHRydWUpO1xuICB9XG5cbiAgdGhpcy5pbnRlcmZhY2VDcmVhdGVkXyA9IHRydWU7XG4gIHRoaXMuYWRkVG9HcmFwaF8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFkZHMgdGhlIHJhbmdlIHNlbGVjdG9yIHRvIHRoZSBncmFwaC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl8gPSB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2O1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmJnY2FudmFzXyk7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuZmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8pO1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVtb3ZlcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgZnJvbSB0aGUgZ3JhcGguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbW92ZUZyb21HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl87XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMuYmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5mZ2NhbnZhc18pO1xuICBncmFwaERpdi5yZW1vdmVDaGlsZCh0aGlzLmxlZnRab29tSGFuZGxlXyk7XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMucmlnaHRab29tSGFuZGxlXyk7XG4gIHRoaXMuZ3JhcGhEaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENhbGxlZCBieSBMYXlvdXQgdG8gYWxsb3cgcmFuZ2Ugc2VsZWN0b3IgdG8gcmVzZXJ2ZSBpdHMgc3BhY2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlc2VydmVTcGFjZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ3Nob3dSYW5nZVNlbGVjdG9yJykpIHtcbiAgICBlLnJlc2VydmVTcGFjZUJvdHRvbSh0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JIZWlnaHQnKSArIDQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBzdGF0aWMgcG9ydGlvbiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgYXQgdGhlIHByZWRyYXcgc3RhZ2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlclN0YXRpY0xheWVyXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudXBkYXRlVmlzaWJpbGl0eV8oKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlc2l6ZV8oKTtcbiAgdGhpcy5kcmF3U3RhdGljTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBpbnRlcmFjdGl2ZSBwb3J0aW9uIG9mIHRoZSByYW5nZSBzZWxlY3RvciBhZnRlciB0aGUgY2hhcnQgaGFzIGJlZW4gZHJhd24uXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlckludGVyYWN0aXZlTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy51cGRhdGVWaXNpYmlsaXR5XygpIHx8IHRoaXMuaXNDaGFuZ2luZ1JhbmdlXykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnBsYWNlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIHJhbmdlIHNlbGVjdG9yIGlzIGVuYWJsZWQvZGlzYWJsZWQgYW5kIHVwZGF0ZSB2aXNpYmlsaXR5IGFjY29yZGluZ2x5LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS51cGRhdGVWaXNpYmlsaXR5XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5hYmxlZCA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd1JhbmdlU2VsZWN0b3InKTtcbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJmYWNlQ3JlYXRlZF8pIHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJmYWNlXygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhEaXZfIHx8ICF0aGlzLmdyYXBoRGl2Xy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmFkZFRvR3JhcGhfKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuZ3JhcGhEaXZfKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tR3JhcGhfKCk7XG4gICAgdmFyIGR5Z3JhcGggPSB0aGlzLmR5Z3JhcGhfO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGR5Z3JhcGgud2lkdGhfID0gMDsgZHlncmFwaC5yZXNpemUoKTsgfSwgMSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXNpemVzIHRoZSByYW5nZSBzZWxlY3Rvci5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVzaXplXyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzZXRFbGVtZW50UmVjdChjYW52YXMsIGNvbnRleHQsIHJlY3QsIHBpeGVsUmF0aW9PcHRpb24pIHtcbiAgICB2YXIgY2FudmFzU2NhbGUgPSBwaXhlbFJhdGlvT3B0aW9uIHx8IHV0aWxzLmdldENvbnRleHRQaXhlbFJhdGlvKGNvbnRleHQpO1xuXG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IHJlY3QueSArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSByZWN0LnggKyAncHgnO1xuICAgIGNhbnZhcy53aWR0aCA9IHJlY3QudyAqIGNhbnZhc1NjYWxlO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmggKiBjYW52YXNTY2FsZTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSByZWN0LncgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSByZWN0LmggKyAncHgnO1xuXG4gICAgaWYoY2FudmFzU2NhbGUgIT0gMSkge1xuICAgICAgY29udGV4dC5zY2FsZShjYW52YXNTY2FsZSwgY2FudmFzU2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbG90QXJlYSA9IHRoaXMuZHlncmFwaF8ubGF5b3V0Xy5nZXRQbG90QXJlYSgpO1xuXG4gIHZhciB4QXhpc0xhYmVsSGVpZ2h0ID0gMDtcbiAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgeEF4aXNMYWJlbEhlaWdodCA9IHRoaXMuZ2V0T3B0aW9uXygneEF4aXNIZWlnaHQnKSB8fCAodGhpcy5nZXRPcHRpb25fKCdheGlzTGFiZWxGb250U2l6ZScpICsgMiAqIHRoaXMuZ2V0T3B0aW9uXygnYXhpc1RpY2tTaXplJykpO1xuICB9XG4gIHRoaXMuY2FudmFzUmVjdF8gPSB7XG4gICAgeDogcGxvdEFyZWEueCxcbiAgICB5OiBwbG90QXJlYS55ICsgcGxvdEFyZWEuaCArIHhBeGlzTGFiZWxIZWlnaHQgKyA0LFxuICAgIHc6IHBsb3RBcmVhLncsXG4gICAgaDogdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9ySGVpZ2h0JylcbiAgfTtcblxuICB2YXIgcGl4ZWxSYXRpb09wdGlvbiA9IHRoaXMuZHlncmFwaF8uZ2V0TnVtZXJpY09wdGlvbigncGl4ZWxSYXRpbycpO1xuICBzZXRFbGVtZW50UmVjdCh0aGlzLmJnY2FudmFzXywgdGhpcy5iZ2NhbnZhc19jdHhfLCB0aGlzLmNhbnZhc1JlY3RfLCBwaXhlbFJhdGlvT3B0aW9uKTtcbiAgc2V0RWxlbWVudFJlY3QodGhpcy5mZ2NhbnZhc18sIHRoaXMuZmdjYW52YXNfY3R4XywgdGhpcy5jYW52YXNSZWN0XywgcGl4ZWxSYXRpb09wdGlvbik7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDcmVhdGVzIHRoZSBiYWNrZ3JvdW5kIGFuZCBmb3JlZ3JvdW5kIGNhbnZhc2VzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVDYW52YXNlc18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5iZ2NhbnZhc18uY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcmFuZ2VzZWwtYmdjYW52YXMnO1xuICB0aGlzLmJnY2FudmFzXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRoaXMuYmdjYW52YXNfLnN0eWxlLnpJbmRleCA9IDk7XG4gIHRoaXMuYmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5iZ2NhbnZhc18pO1xuXG4gIHRoaXMuZmdjYW52YXNfID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIHRoaXMuZmdjYW52YXNfLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJhbmdlc2VsLWZnY2FudmFzJztcbiAgdGhpcy5mZ2NhbnZhc18uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS56SW5kZXggPSA5O1xuICB0aGlzLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gIHRoaXMuZmdjYW52YXNfY3R4XyA9IHV0aWxzLmdldENvbnRleHQodGhpcy5mZ2NhbnZhc18pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ3JlYXRlcyB0aGUgem9vbSBoYW5kbGUgZWxlbWVudHMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZVpvb21IYW5kbGVzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5jbGFzc05hbWUgPSAnZHlncmFwaC1yYW5nZXNlbC16b29taGFuZGxlJztcbiAgaW1nLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgaW1nLnN0eWxlLnpJbmRleCA9IDEwO1xuICBpbWcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBJbml0aWFsbHkgaGlkZGVuIHNvIHRoZXkgZG9uJ3Qgc2hvdyB1cCBpbiB0aGUgd3JvbmcgcGxhY2UuXG4gIGltZy5zdHlsZS5jdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gIC8vIFRPRE86IGNoYW5nZSBpbWFnZSB0byBtb3JlIG9wdGlvbnNcbiAgaW1nLndpZHRoID0gOTtcbiAgaW1nLmhlaWdodCA9IDE2O1xuICBpbWcuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICtcbidpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBUUNBWUFBQURFU0ZWREFBQUFBWE5TUjBJQXJzNGM2UUFBQUFaaVMwZEVBTkFBJyArXG4nendEUDRaN0tlZ0FBQUFsd1NGbHpBQUFPeEFBQURzUUJsU3NPR3dBQUFBZDBTVTFGQjlzSEd3MGNNcWR0MVV3QUFBQVpkRVZZZEVOdicgK1xuJ2JXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFhRWxFUVZRb3orM1NzUkZBUUJDRjRaOVdKTThLQ0RWd293bmwnICtcbic2WVhzVG1DVXN5S0drWnpjbDd6a3ozWUxreXBnQW5yZUZtREVwSGtJd1ZPTWZwZGk5Q0VFTjJuR3BGZHdEMDN5RXFEdE9nQ2F1bjdzJyArXG4ncVNUREgzMkkxcFFBMlBiOXNaZWNBeGM1cjNJQWIyMWQ2ODc4eHNBQUFBQUFTVVZPUks1Q1lJST0nO1xuXG4gIGlmICh0aGlzLmlzTW9iaWxlRGV2aWNlXykge1xuICAgIGltZy53aWR0aCAqPSAyO1xuICAgIGltZy5oZWlnaHQgKj0gMjtcbiAgfVxuXG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gaW1nO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8gPSBpbWcuY2xvbmVOb2RlKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFNldHMgdXAgdGhlIGludGVyYWN0aW9uIGZvciB0aGUgcmFuZ2Ugc2VsZWN0b3IuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmluaXRJbnRlcmFjdGlvbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG9wRWxlbSA9IGRvY3VtZW50O1xuICB2YXIgY2xpZW50WExhc3QgPSAwO1xuICB2YXIgaGFuZGxlID0gbnVsbDtcbiAgdmFyIGlzWm9vbWluZyA9IGZhbHNlO1xuICB2YXIgaXNQYW5uaW5nID0gZmFsc2U7XG4gIHZhciBkeW5hbWljID0gIXRoaXMuaXNNb2JpbGVEZXZpY2VfO1xuXG4gIC8vIFdlIGNvdmVyIGlmcmFtZXMgZHVyaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2VlIGNvbW1lbnRzIGluXG4gIC8vIGR5Z3JhcGgtdXRpbHMuanMgZm9yIG1vcmUgaW5mbyBvbiB3aHkgdGhpcyBpcyBhIGdvb2QgaWRlYS5cbiAgdmFyIHRhcnAgPSBuZXcgSUZyYW1lVGFycCgpO1xuXG4gIC8vIGZ1bmN0aW9ucywgZGVmaW5lZCBiZWxvdy4gIERlZmluaW5nIHRoZW0gdGhpcyB3YXkgKHJhdGhlciB0aGFuIHdpdGhcbiAgLy8gXCJmdW5jdGlvbiBmb28oKSB7Li4ufVwiIG1ha2VzIEpTSGludCBoYXBweS5cbiAgdmFyIHRvWERhdGFXaW5kb3csIG9uWm9vbVN0YXJ0LCBvblpvb20sIG9uWm9vbUVuZCwgZG9ab29tLCBpc01vdXNlSW5QYW5ab25lLFxuICAgICAgb25QYW5TdGFydCwgb25QYW4sIG9uUGFuRW5kLCBkb1Bhbiwgb25DYW52YXNIb3ZlcjtcblxuICAvLyBUb3VjaCBldmVudCBmdW5jdGlvbnNcbiAgdmFyIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQsIG9uQ2FudmFzVG91Y2hFdmVudCwgYWRkVG91Y2hFdmVudHM7XG5cbiAgdG9YRGF0YVdpbmRvdyA9IGZ1bmN0aW9uKHpvb21IYW5kbGVTdGF0dXMpIHtcbiAgICB2YXIgeERhdGFMaW1pdHMgPSBzZWxmLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgICB2YXIgZmFjdCA9ICh4RGF0YUxpbWl0c1sxXSAtIHhEYXRhTGltaXRzWzBdKS9zZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgdmFyIHhEYXRhTWluID0geERhdGFMaW1pdHNbMF0gKyAoem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zIC0gc2VsZi5jYW52YXNSZWN0Xy54KSpmYWN0O1xuICAgIHZhciB4RGF0YU1heCA9IHhEYXRhTGltaXRzWzBdICsgKHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgLSBzZWxmLmNhbnZhc1JlY3RfLngpKmZhY3Q7XG4gICAgcmV0dXJuIFt4RGF0YU1pbiwgeERhdGFNYXhdO1xuICB9O1xuXG4gIG9uWm9vbVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgIGlzWm9vbWluZyA9IHRydWU7XG4gICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG4gICAgaGFuZGxlID0gZS50YXJnZXQgPyBlLnRhcmdldCA6IGUuc3JjRWxlbWVudDtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAvLyBUaGVzZSBldmVudHMgYXJlIHJlbW92ZWQgbWFudWFsbHkuXG4gICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25ab29tKTtcbiAgICAgIHV0aWxzLmFkZEV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICB9XG4gICAgc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gJ2NvbC1yZXNpemUnO1xuICAgIHRhcnAuY292ZXIoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblpvb20gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1pvb21pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgaGFuZGxlLlxuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBuZXdQb3M7XG4gICAgaWYgKGhhbmRsZSA9PSBzZWxmLmxlZnRab29tSGFuZGxlXykge1xuICAgICAgbmV3UG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcyAtIGhhbmRsZS53aWR0aCAtIDMpO1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgobmV3UG9zLCBzZWxmLmNhbnZhc1JlY3RfLngpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zICsgZGVsWDtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKG5ld1Bvcywgc2VsZi5jYW52YXNSZWN0Xy54ICsgc2VsZi5jYW52YXNSZWN0Xy53KTtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KG5ld1Bvcywgem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zICsgaGFuZGxlLndpZHRoICsgMyk7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBoYW5kbGUud2lkdGgvMjtcbiAgICBoYW5kbGUuc3R5bGUubGVmdCA9IChuZXdQb3MgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgICBzZWxmLmRyYXdJbnRlcmFjdGl2ZUxheWVyXygpO1xuXG4gICAgLy8gWm9vbSBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1pvb20oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgb25ab29tRW5kID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNab29taW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzWm9vbWluZyA9IGZhbHNlO1xuICAgIHRhcnAudW5jb3ZlcigpO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZW1vdmUnLCBvblpvb20pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25ab29tRW5kKTtcbiAgICBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAvLyBJZiBvbiBhIHNsb3dlciBkZXZpY2UsIHpvb20gbm93LlxuICAgIGlmICghZHluYW1pYykge1xuICAgICAgZG9ab29tKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvWm9vbSA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBpZiAoIXpvb21IYW5kbGVTdGF0dXMuaXNab29tZWQpIHtcbiAgICAgICAgc2VsZi5keWdyYXBoXy5yZXNldFpvb20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4RGF0YVdpbmRvdyA9IHRvWERhdGFXaW5kb3coem9vbUhhbmRsZVN0YXR1cyk7XG4gICAgICAgIHNlbGYuZHlncmFwaF8uZG9ab29tWERhdGVzXyh4RGF0YVdpbmRvd1swXSwgeERhdGFXaW5kb3dbMV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgaXNNb3VzZUluUGFuWm9uZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcmVjdCA9IHNlbGYubGVmdFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBsZWZ0SGFuZGxlQ2xpZW50WCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGgvMjtcbiAgICByZWN0ID0gc2VsZi5yaWdodFpvb21IYW5kbGVfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByaWdodEhhbmRsZUNsaWVudFggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoLzI7XG4gICAgcmV0dXJuIChlLmNsaWVudFggPiBsZWZ0SGFuZGxlQ2xpZW50WCAmJiBlLmNsaWVudFggPCByaWdodEhhbmRsZUNsaWVudFgpO1xuICB9O1xuXG4gIG9uUGFuU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcgJiYgaXNNb3VzZUluUGFuWm9uZShlKSAmJiBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkuaXNab29tZWQpIHtcbiAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSByZW1vdmVkIG1hbnVhbGx5LlxuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uUGFuRW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgb25QYW4gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG5cbiAgICB2YXIgZGVsWCA9IGUuY2xpZW50WCAtIGNsaWVudFhMYXN0O1xuICAgIGlmIChNYXRoLmFicyhkZWxYKSA8IDQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcblxuICAgIC8vIE1vdmUgcmFuZ2Ugdmlld1xuICAgIHZhciB6b29tSGFuZGxlU3RhdHVzID0gc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpO1xuICAgIHZhciBsZWZ0SGFuZGxlUG9zID0gem9vbUhhbmRsZVN0YXR1cy5sZWZ0SGFuZGxlUG9zO1xuICAgIHZhciByaWdodEhhbmRsZVBvcyA9IHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3M7XG4gICAgdmFyIHJhbmdlU2l6ZSA9IHJpZ2h0SGFuZGxlUG9zIC0gbGVmdEhhbmRsZVBvcztcbiAgICBpZiAobGVmdEhhbmRsZVBvcyArIGRlbFggPD0gc2VsZi5jYW52YXNSZWN0Xy54KSB7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gc2VsZi5jYW52YXNSZWN0Xy54O1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBsZWZ0SGFuZGxlUG9zICsgcmFuZ2VTaXplO1xuICAgIH0gZWxzZSBpZiAocmlnaHRIYW5kbGVQb3MgKyBkZWxYID49IHNlbGYuY2FudmFzUmVjdF8ueCArIHNlbGYuY2FudmFzUmVjdF8udykge1xuICAgICAgcmlnaHRIYW5kbGVQb3MgPSBzZWxmLmNhbnZhc1JlY3RfLnggKyBzZWxmLmNhbnZhc1JlY3RfLnc7XG4gICAgICBsZWZ0SGFuZGxlUG9zID0gcmlnaHRIYW5kbGVQb3MgLSByYW5nZVNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRIYW5kbGVQb3MgKz0gZGVsWDtcbiAgICAgIHJpZ2h0SGFuZGxlUG9zICs9IGRlbFg7XG4gICAgfVxuICAgIHZhciBoYWxmSGFuZGxlV2lkdGggPSBzZWxmLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICAgIHNlbGYubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdEhhbmRsZVBvcyAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICAgIHNlbGYucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0SGFuZGxlUG9zIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gICAgc2VsZi5kcmF3SW50ZXJhY3RpdmVMYXllcl8oKTtcblxuICAgIC8vIERvIHBhbiBvbiB0aGUgZmx5LlxuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBkb1BhbigpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBvblBhbkVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzUGFubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25QYW4pO1xuICAgIHV0aWxzLnJlbW92ZUV2ZW50KHRvcEVsZW0sICdtb3VzZXVwJywgb25QYW5FbmQpO1xuICAgIC8vIElmIG9uIGEgc2xvd2VyIGRldmljZSwgZG8gcGFuIG5vdy5cbiAgICBpZiAoIWR5bmFtaWMpIHtcbiAgICAgIGRvUGFuKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGRvUGFuID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IHRydWU7XG4gICAgICBzZWxmLmR5Z3JhcGhfLmRhdGVXaW5kb3dfID0gdG9YRGF0YVdpbmRvdyhzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCkpO1xuICAgICAgc2VsZi5keWdyYXBoXy5kcmF3R3JhcGhfKGZhbHNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzSG92ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGlzWm9vbWluZyB8fCBpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnNvciA9IGlzTW91c2VJblBhblpvbmUoZSkgPyAnbW92ZScgOiAnZGVmYXVsdCc7XG4gICAgaWYgKGN1cnNvciAhPSBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IpIHtcbiAgICAgIHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG4gIH07XG5cbiAgb25ab29tSGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblpvb21TdGFydChlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uWm9vbShlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblpvb21FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIG9uQ2FudmFzVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblBhblN0YXJ0KGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ3RvdWNobW92ZScgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25QYW4oZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25QYW5FbmQoZSk7XG4gICAgfVxuICB9O1xuXG4gIGFkZFRvdWNoRXZlbnRzID0gZnVuY3Rpb24oZWxlbSwgZm4pIHtcbiAgICB2YXIgdHlwZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJywgJ3RvdWNoY2FuY2VsJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KGVsZW0sIHR5cGVzW2ldLCBmbik7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ2ludGVyYWN0aW9uTW9kZWwnLCBEeWdyYXBoSW50ZXJhY3Rpb24uZHJhZ0lzUGFuSW50ZXJhY3Rpb25Nb2RlbCk7XG4gIHRoaXMuc2V0RGVmYXVsdE9wdGlvbl8oJ3BhbkVkZ2VGcmFjdGlvbicsIDAuMDAwMSk7XG5cbiAgdmFyIGRyYWdTdGFydEV2ZW50ID0gd2luZG93Lm9wZXJhID8gJ21vdXNlZG93bicgOiAnZHJhZ3N0YXJ0JztcbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubGVmdFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5yaWdodFpvb21IYW5kbGVfLCBkcmFnU3RhcnRFdmVudCwgb25ab29tU3RhcnQpO1xuXG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLmZnY2FudmFzXywgJ21vdXNlZG93bicsIG9uUGFuU3RhcnQpO1xuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5mZ2NhbnZhc18sICdtb3VzZW1vdmUnLCBvbkNhbnZhc0hvdmVyKTtcblxuICAvLyBUb3VjaCBldmVudHNcbiAgaWYgKHRoaXMuaGFzVG91Y2hJbnRlcmZhY2VfKSB7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5sZWZ0Wm9vbUhhbmRsZV8sIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQpO1xuICAgIGFkZFRvdWNoRXZlbnRzKHRoaXMucmlnaHRab29tSGFuZGxlXywgb25ab29tSGFuZGxlVG91Y2hFdmVudCk7XG4gICAgYWRkVG91Y2hFdmVudHModGhpcy5mZ2NhbnZhc18sIG9uQ2FudmFzVG91Y2hFdmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBzdGF0aWMgbGF5ZXIgaW4gdGhlIGJhY2tncm91bmQgY2FudmFzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5kcmF3U3RhdGljTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdHggPSB0aGlzLmJnY2FudmFzX2N0eF87XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNSZWN0Xy53LCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICB0cnkge1xuICAgIHRoaXMuZHJhd01pbmlQbG90XygpO1xuICB9IGNhdGNoKGV4KSB7XG4gICAgY29uc29sZS53YXJuKGV4KTtcbiAgfVxuXG4gIHZhciBtYXJnaW4gPSAwLjU7XG4gIHRoaXMuYmdjYW52YXNfY3R4Xy5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckJhY2tncm91bmRTdHJva2VDb2xvcicpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8obWFyZ2luLCBtYXJnaW4pO1xuICBjdHgubGluZVRvKG1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgdGhpcy5jYW52YXNSZWN0Xy5oLW1hcmdpbik7XG4gIGN0eC5saW5lVG8odGhpcy5jYW52YXNSZWN0Xy53LW1hcmdpbiwgbWFyZ2luKTtcbiAgY3R4LnN0cm9rZSgpO1xufTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEcmF3cyB0aGUgbWluaSBwbG90IGluIHRoZSBiYWNrZ3JvdW5kIGNhbnZhcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZHJhd01pbmlQbG90XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsbFN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdEZpbGxDb2xvcicpO1xuICB2YXIgZmlsbEdyYWRpZW50U3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3InKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdFN0cm9rZUNvbG9yJyk7XG4gIGlmICghZmlsbFN0eWxlICYmICFzdHJva2VTdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdGVwUGxvdCA9IHRoaXMuZ2V0T3B0aW9uXygnc3RlcFBsb3QnKTtcblxuICB2YXIgY29tYmluZWRTZXJpZXNEYXRhID0gdGhpcy5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfKCk7XG4gIHZhciB5UmFuZ2UgPSBjb21iaW5lZFNlcmllc0RhdGEueU1heCAtIGNvbWJpbmVkU2VyaWVzRGF0YS55TWluO1xuXG4gIC8vIERyYXcgdGhlIG1pbmkgcGxvdC5cbiAgdmFyIGN0eCA9IHRoaXMuYmdjYW52YXNfY3R4XztcbiAgdmFyIG1hcmdpbiA9IDAuNTtcblxuICB2YXIgeEV4dHJlbWVzID0gdGhpcy5keWdyYXBoXy54QXhpc0V4dHJlbWVzKCk7XG4gIHZhciB4UmFuZ2UgPSBNYXRoLm1heCh4RXh0cmVtZXNbMV0gLSB4RXh0cmVtZXNbMF0sIDEuZS0zMCk7XG4gIHZhciB4RmFjdCA9ICh0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW4pL3hSYW5nZTtcbiAgdmFyIHlGYWN0ID0gKHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbikveVJhbmdlO1xuICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhc1JlY3RfLncgLSBtYXJnaW47XG4gIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc1JlY3RfLmggLSBtYXJnaW47XG5cbiAgdmFyIHByZXZYID0gbnVsbCwgcHJldlkgPSBudWxsO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhtYXJnaW4sIGNhbnZhc0hlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluZWRTZXJpZXNEYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0YVBvaW50ID0gY29tYmluZWRTZXJpZXNEYXRhLmRhdGFbaV07XG4gICAgdmFyIHggPSAoKGRhdGFQb2ludFswXSAhPT0gbnVsbCkgPyAoKGRhdGFQb2ludFswXSAtIHhFeHRyZW1lc1swXSkqeEZhY3QpIDogTmFOKTtcbiAgICB2YXIgeSA9ICgoZGF0YVBvaW50WzFdICE9PSBudWxsKSA/IChjYW52YXNIZWlnaHQgLSAoZGF0YVBvaW50WzFdIC0gY29tYmluZWRTZXJpZXNEYXRhLnlNaW4pKnlGYWN0KSA6IE5hTik7XG5cbiAgICAvLyBTa2lwIHBvaW50cyB0aGF0IGRvbid0IGNoYW5nZSB0aGUgeC12YWx1ZS4gT3Zlcmx5IGZpbmUtZ3JhaW5lZCBwb2ludHNcbiAgICAvLyBjYW4gY2F1c2UgbWFqb3Igc2xvd2Rvd25zIHdpdGggdGhlIGN0eC5maWxsKCkgY2FsbCBiZWxvdy5cbiAgICBpZiAoIXN0ZXBQbG90ICYmIHByZXZYICE9PSBudWxsICYmIE1hdGgucm91bmQoeCkgPT0gTWF0aC5yb3VuZChwcmV2WCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSkge1xuICAgICAgaWYocHJldlggPT09IG51bGwpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBjYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCBwcmV2WSk7XG4gICAgICB9XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKHByZXZYICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgcHJldlkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHgubGluZVRvKHByZXZYLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2WCA9IHByZXZZID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChmaWxsU3R5bGUpIHtcbiAgICB2YXIgbGluZ3JhZCA9IHRoaXMuYmdjYW52YXNfY3R4Xy5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBjYW52YXNIZWlnaHQpO1xuICAgIGlmIChmaWxsR3JhZGllbnRTdHlsZSkge1xuICAgICAgbGluZ3JhZC5hZGRDb2xvclN0b3AoMCwgZmlsbEdyYWRpZW50U3R5bGUpO1xuICAgIH1cbiAgICBsaW5ncmFkLmFkZENvbG9yU3RvcCgxLCBmaWxsU3R5bGUpO1xuICAgIHRoaXMuYmdjYW52YXNfY3R4Xy5maWxsU3R5bGUgPSBsaW5ncmFkO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cblxuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8uc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8ubGluZVdpZHRoID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdExpbmVXaWR0aCcpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGNvbWJpbmVkIHNlcmllcyBkYXRhIGFsb25nIHdpdGggbWluL21heCBmb3IgdGhlIG1pbmkgcGxvdC5cbiAqIFRoZSBjb21iaW5lZCBzZXJpZXMgY29uc2lzdHMgb2YgYXZlcmFnZWQgdmFsdWVzIGZvciBhbGwgc2VyaWVzLlxuICogV2hlbiBzZXJpZXMgaGF2ZSBlcnJvciBiYXJzLCB0aGUgZXJyb3IgYmFycyBhcmUgaWdub3JlZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tYmluZWQgc2VyaWVzIGFycmF5LCB5bWluLCB5bWF4LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jb21wdXRlQ29tYmluZWRTZXJpZXNBbmRMaW1pdHNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnID0gdGhpcy5keWdyYXBoXztcbiAgdmFyIGxvZ3NjYWxlID0gdGhpcy5nZXRPcHRpb25fKCdsb2dzY2FsZScpO1xuICB2YXIgaTtcblxuICAvLyBTZWxlY3Qgc2VyaWVzIHRvIGNvbWJpbmUuIEJ5IGRlZmF1bHQsIGFsbCBzZXJpZXMgYXJlIGNvbWJpbmVkLlxuICB2YXIgbnVtQ29sdW1ucyA9IGcubnVtQ29sdW1ucygpO1xuICB2YXIgbGFiZWxzID0gZy5nZXRMYWJlbHMoKTtcbiAgdmFyIGluY2x1ZGVTZXJpZXMgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gIHZhciBhbnlTZXQgPSBmYWxzZTtcbiAgdmFyIHZpc2liaWxpdHkgPSBnLnZpc2liaWxpdHkoKTtcbiAgdmFyIGluY2x1c2lvbiA9IFtdO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICB2YXIgaW5jbHVkZSA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd0luUmFuZ2VTZWxlY3RvcicsIGxhYmVsc1tpXSk7XG4gICAgaW5jbHVzaW9uLnB1c2goaW5jbHVkZSk7XG4gICAgaWYgKGluY2x1ZGUgIT09IG51bGwpIGFueVNldCA9IHRydWU7ICAvLyBpdCdzIHNldCBleHBsaWNpdGx5IGZvciB0aGlzIHNlcmllc1xuICB9XG5cbiAgaWYgKGFueVNldCkge1xuICAgIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICAgIGluY2x1ZGVTZXJpZXNbaV0gPSBpbmNsdXNpb25baSAtIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnVtQ29sdW1uczsgaSsrKSB7XG4gICAgICBpbmNsdWRlU2VyaWVzW2ldID0gdmlzaWJpbGl0eVtpIC0gMV07XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgY29tYmluZWQgc2VyaWVzIChhdmVyYWdlIG9mIHNlbGVjdGVkIHNlcmllcyB2YWx1ZXMpLlxuICAvLyBUT0RPKGRhbnZrKTogc2hvcnQtY2lyY3VpdCBpZiB0aGVyZSdzIG9ubHkgb25lIHNlcmllcy5cbiAgdmFyIHJvbGxlZFNlcmllcyA9IFtdO1xuICB2YXIgZGF0YUhhbmRsZXIgPSBnLmRhdGFIYW5kbGVyXztcbiAgdmFyIG9wdGlvbnMgPSBnLmF0dHJpYnV0ZXNfO1xuICBmb3IgKGkgPSAxOyBpIDwgZy5udW1Db2x1bW5zKCk7IGkrKykge1xuICAgIGlmICghaW5jbHVkZVNlcmllc1tpXSkgY29udGludWU7XG4gICAgdmFyIHNlcmllcyA9IGRhdGFIYW5kbGVyLmV4dHJhY3RTZXJpZXMoZy5yYXdEYXRhXywgaSwgb3B0aW9ucyk7XG4gICAgaWYgKGcucm9sbFBlcmlvZCgpID4gMSkge1xuICAgICAgc2VyaWVzID0gZGF0YUhhbmRsZXIucm9sbGluZ0F2ZXJhZ2Uoc2VyaWVzLCBnLnJvbGxQZXJpb2QoKSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcm9sbGVkU2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIHZhciBjb21iaW5lZFNlcmllcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm9sbGVkU2VyaWVzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvbGxlZFNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHkgPSByb2xsZWRTZXJpZXNbal1baV1bMV07XG4gICAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSkgY29udGludWU7XG4gICAgICBjb3VudCsrO1xuICAgICAgc3VtICs9IHk7XG4gICAgfVxuICAgIGNvbWJpbmVkU2VyaWVzLnB1c2goW3JvbGxlZFNlcmllc1swXVtpXVswXSwgc3VtIC8gY291bnRdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHkgcmFuZ2UuXG4gIHZhciB5TWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIHlNYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHlWYWwgPSBjb21iaW5lZFNlcmllc1tpXVsxXTtcbiAgICBpZiAoeVZhbCAhPT0gbnVsbCAmJiBpc0Zpbml0ZSh5VmFsKSAmJiAoIWxvZ3NjYWxlIHx8IHlWYWwgPiAwKSkge1xuICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHlWYWwpO1xuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHlWYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgWSBkYXRhIHRvIGxvZyBzY2FsZSBpZiBuZWVkZWQuXG4gIC8vIEFsc28sIGV4cGFuZCB0aGUgWSByYW5nZSB0byBjb21wcmVzcyB0aGUgbWluaSBwbG90IGEgbGl0dGxlLlxuICB2YXIgZXh0cmFQZXJjZW50ID0gMC4yNTtcbiAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgeU1heCA9IHV0aWxzLmxvZzEwKHlNYXgpO1xuICAgIHlNYXggKz0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgeU1pbiA9IHV0aWxzLmxvZzEwKHlNaW4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21iaW5lZFNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tYmluZWRTZXJpZXNbaV1bMV0gPSB1dGlscy5sb2cxMChjb21iaW5lZFNlcmllc1tpXVsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB5RXh0cmE7XG4gICAgdmFyIHlSYW5nZSA9IHlNYXggLSB5TWluO1xuICAgIGlmICh5UmFuZ2UgPD0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgeUV4dHJhID0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlFeHRyYSA9IHlSYW5nZSpleHRyYVBlcmNlbnQ7XG4gICAgfVxuICAgIHlNYXggKz0geUV4dHJhO1xuICAgIHlNaW4gLT0geUV4dHJhO1xuICB9XG5cbiAgcmV0dXJuIHtkYXRhOiBjb21iaW5lZFNlcmllcywgeU1pbjogeU1pbiwgeU1heDogeU1heH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQbGFjZXMgdGhlIHpvb20gaGFuZGxlcyBpbiB0aGUgcHJvcGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IFggZGF0YSB3aW5kb3cuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnBsYWNlWm9vbUhhbmRsZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4RXh0cmVtZXMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgdmFyIHhXaW5kb3dMaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIHhSYW5nZSA9IHhFeHRyZW1lc1sxXSAtIHhFeHRyZW1lc1swXTtcbiAgdmFyIGxlZnRQZXJjZW50ID0gTWF0aC5tYXgoMCwgKHhXaW5kb3dMaW1pdHNbMF0gLSB4RXh0cmVtZXNbMF0pL3hSYW5nZSk7XG4gIHZhciByaWdodFBlcmNlbnQgPSBNYXRoLm1heCgwLCAoeEV4dHJlbWVzWzFdIC0geFdpbmRvd0xpbWl0c1sxXSkveFJhbmdlKTtcbiAgdmFyIGxlZnRDb29yZCA9IHRoaXMuY2FudmFzUmVjdF8ueCArIHRoaXMuY2FudmFzUmVjdF8udypsZWZ0UGVyY2VudDtcbiAgdmFyIHJpZ2h0Q29vcmQgPSB0aGlzLmNhbnZhc1JlY3RfLnggKyB0aGlzLmNhbnZhc1JlY3RfLncqKDEgLSByaWdodFBlcmNlbnQpO1xuICB2YXIgaGFuZGxlVG9wID0gTWF0aC5tYXgodGhpcy5jYW52YXNSZWN0Xy55LCB0aGlzLmNhbnZhc1JlY3RfLnkgKyAodGhpcy5jYW52YXNSZWN0Xy5oIC0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uaGVpZ2h0KS8yKTtcbiAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdENvb3JkIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IGhhbmRsZVRvcCArICdweCc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0Q29vcmQgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcDtcblxuICB0aGlzLmxlZnRab29tSGFuZGxlXy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBpbiB0aGUgZm9yZWdyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdJbnRlcmFjdGl2ZUxheWVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3R4ID0gdGhpcy5mZ2NhbnZhc19jdHhfO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzUmVjdF8udywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcbiAgdmFyIG1hcmdpbiA9IDE7XG4gIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbjtcbiAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbjtcbiAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSB0aGlzLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG5cbiAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJyk7XG4gIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGlmICghem9vbUhhbmRsZVN0YXR1cy5pc1pvb21lZCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKG1hcmdpbiwgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8od2lkdGgsIG1hcmdpbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZWZ0SGFuZGxlQ2FudmFzUG9zID0gTWF0aC5tYXgobWFyZ2luLCB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgLSB0aGlzLmNhbnZhc1JlY3RfLngpO1xuICAgIHZhciByaWdodEhhbmRsZUNhbnZhc1BvcyA9IE1hdGgubWluKHdpZHRoLCB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gdGhpcy5jYW52YXNSZWN0Xy54KTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNDAsIDI0MCwgMjQwLCAnICsgdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQWxwaGEnKS50b1N0cmluZygpICsgJyknO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBsZWZ0SGFuZGxlQ2FudmFzUG9zLCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICAgIGN0eC5maWxsUmVjdChyaWdodEhhbmRsZUNhbnZhc1BvcywgMCwgdGhpcy5jYW52YXNSZWN0Xy53IC0gcmlnaHRIYW5kbGVDYW52YXNQb3MsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhtYXJnaW4sIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0SGFuZGxlQ2FudmFzUG9zLCBtYXJnaW4pO1xuICAgIGN0eC5saW5lVG8obGVmdEhhbmRsZUNhbnZhc1BvcywgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHJpZ2h0SGFuZGxlQ2FudmFzUG9zLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8ocmlnaHRIYW5kbGVDYW52YXNQb3MsIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyh3aWR0aCwgbWFyZ2luKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBoYW5kbGUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB6b29tIGhhbmRsZSBzdGF0dXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldFpvb21IYW5kbGVTdGF0dXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmSGFuZGxlV2lkdGggPSB0aGlzLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICB2YXIgbGVmdEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCkgKyBoYWxmSGFuZGxlV2lkdGg7XG4gIHZhciByaWdodEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQpICsgaGFsZkhhbmRsZVdpZHRoO1xuICByZXR1cm4ge1xuICAgICAgbGVmdEhhbmRsZVBvczogbGVmdEhhbmRsZVBvcyxcbiAgICAgIHJpZ2h0SGFuZGxlUG9zOiByaWdodEhhbmRsZVBvcyxcbiAgICAgIGlzWm9vbWVkOiAobGVmdEhhbmRsZVBvcyAtIDEgPiB0aGlzLmNhbnZhc1JlY3RfLnggfHwgcmlnaHRIYW5kbGVQb3MgKyAxIDwgdGhpcy5jYW52YXNSZWN0Xy54K3RoaXMuY2FudmFzUmVjdF8udylcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJhbmdlU2VsZWN0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n\n\nvar OPTIONS_REFERENCE = null;\n\n// For \"production\" code, this gets removed by uglifyjs.\nif (typeof(process) !== 'undefined') {\nif (false) { var labels, op, k, cats, i, valid_cats, flds, warn; }\n}\n\n/* unused harmony default export */ var _unused_webpack_default_export = (OPTIONS_REFERENCE);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2R5Z3JhcGgtb3B0aW9ucy1yZWZlcmVuY2UuanM/OTZjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgT1BUSU9OU19SRUZFUkVOQ0UgPSBudWxsO1xuXG4vLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG5pZiAodHlwZW9mKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJykge1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuXG4vLyBOT1RFOiBpbiBhZGRpdGlvbiB0byBwYXJzaW5nIGFzIEpTLCB0aGlzIHNuaXBwZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdmFsaWRcbi8vIEpTT04uIFRoaXMgYXNzdW1wdGlvbiBjYW5ub3QgYmUgY2hlY2tlZCBpbiBKUywgYnV0IGl0IHdpbGwgYmUgY2hlY2tlZCB3aGVuXG4vLyBkb2N1bWVudGF0aW9uIGlzIGdlbmVyYXRlZCBieSB0aGUgZ2VuZXJhdGUtZG9jdW1lbnRhdGlvbi5weSBzY3JpcHQuIEZvciB0aGVcbi8vIG1vc3QgcGFydCwgdGhpcyBqdXN0IG1lYW5zIHRoYXQgeW91IHNob3VsZCBhbHdheXMgdXNlIGRvdWJsZSBxdW90ZXMuXG5PUFRJT05TX1JFRkVSRU5DRSA9ICAvLyA8SlNPTj5cbntcbiAgXCJ4VmFsdWVQYXJzZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInBhcnNlRmxvYXQoKSBvciBEYXRlLnBhcnNlKCkqXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oc3RyKSAtPiBudW1iZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB3aGljaCBwYXJzZXMgeC12YWx1ZXMgKGkuZS4gdGhlIGRlcGVuZGVudCBzZXJpZXMpLiBNdXN0IHJldHVybiBhIG51bWJlciwgZXZlbiB3aGVuIHRoZSB2YWx1ZXMgYXJlIGRhdGVzLiBJbiB0aGlzIGNhc2UsIG1pbGxpcyBzaW5jZSBlcG9jaCBhcmUgdXNlZC4gVGhpcyBpcyB1c2VkIHByaW1hcmlseSBmb3IgcGFyc2luZyBDU1YgZGF0YS4gKj1EeWdyYXBocyBpcyBzbGlnaHRseSBtb3JlIGFjY2VwdGluZyBpbiB0aGUgZGF0ZXMgd2hpY2ggaXQgd2lsbCBwYXJzZS4gU2VlIGNvZGUgZm9yIGRldGFpbHMuXCJcbiAgfSxcbiAgXCJzdGFja2VkR3JhcGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBzZXQsIHN0YWNrIHNlcmllcyBvbiB0b3Agb2Ygb25lIGFub3RoZXIgcmF0aGVyIHRoYW4gZHJhd2luZyB0aGVtIGluZGVwZW5kZW50bHkuIFRoZSBmaXJzdCBzZXJpZXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBkYXRhIHdpbGwgd2luZCB1cCBvbiB0b3Agb2YgdGhlIGNoYXJ0IGFuZCB0aGUgbGFzdCB3aWxsIGJlIG9uIGJvdHRvbS4gTmFOIHZhbHVlcyBhcmUgZHJhd24gYXMgd2hpdGUgYXJlYXMgd2l0aG91dCBhIGxpbmUgb24gdG9wLCBzZWUgc3RhY2tlZEdyYXBoTmFORmlsbCBmb3IgZGV0YWlscy5cIlxuICB9LFxuICBcInN0YWNrZWRHcmFwaE5hTkZpbGxcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImFsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb250cm9scyBoYW5kbGluZyBvZiBOYU4gdmFsdWVzIGluc2lkZSBhIHN0YWNrZWQgZ3JhcGguIE5hTiB2YWx1ZXMgYXJlIGludGVycG9sYXRlZC9leHRlbmRlZCBmb3Igc3RhY2tpbmcgcHVycG9zZXMsIGJ1dCB0aGUgYWN0dWFsIHBvaW50IHZhbHVlIHJlbWFpbnMgTmFOIGluIHRoZSBsZWdlbmQgZGlzcGxheS4gVmFsaWQgb3B0aW9uIHZhbHVlcyBhcmUgXFxcImFsbFxcXCIgKGludGVycG9sYXRlIGludGVybmFsbHksIHJlcGVhdCBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHZhbHVlIGFzIG5lZWRlZCksIFxcXCJpbnNpZGVcXFwiIChpbnRlcnBvbGF0ZSBpbnRlcm5hbGx5IG9ubHksIHVzZSB6ZXJvIG91dHNpZGUgbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCB2YWx1ZSksIGFuZCBcXFwibm9uZVxcXCIgKHRyZWF0IE5hTiBhcyB6ZXJvIGV2ZXJ5d2hlcmUpLlwiXG4gIH0sXG4gIFwicG9pbnRTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc2l6ZSBvZiB0aGUgZG90IHRvIGRyYXcgb24gZWFjaCBwb2ludCBpbiBwaXhlbHMgKHNlZSBkcmF3UG9pbnRzKS4gQSBkb3QgaXMgYWx3YXlzIGRyYXduIHdoZW4gYSBwb2ludCBpcyBcXFwiaXNvbGF0ZWRcXFwiLCBpLmUuIHRoZXJlIGlzIGEgbWlzc2luZyBwb2ludCBvbiBlaXRoZXIgc2lkZSBvZiBpdC4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBzaXplIG9mIHRob3NlIGRvdHMuXCJcbiAgfSxcbiAgXCJkcmF3UG9pbnRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBhIHNtYWxsIGRvdCBhdCBlYWNoIHBvaW50LCBpbiBhZGRpdGlvbiB0byBhIGxpbmUgZ29pbmcgdGhyb3VnaCB0aGUgcG9pbnQuIFRoaXMgbWFrZXMgdGhlIGluZGl2aWR1YWwgZGF0YSBwb2ludHMgZWFzaWVyIHRvIHNlZSwgYnV0IGNhbiBpbmNyZWFzZSB2aXN1YWwgY2x1dHRlciBpbiB0aGUgY2hhcnQuIFRoZSBzbWFsbCBkb3QgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBjdXN0b20gcmVuZGVyaW5nIGJ5IHN1cHBseWluZyBhIDxhIGhyZWY9JyNkcmF3UG9pbnRDYWxsYmFjayc+ZHJhd1BvaW50Q2FsbGJhY2s8L2E+LlwiXG4gIH0sXG4gIFwiZHJhd0dhcEVkZ2VQb2ludHNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IHBvaW50cyBhdCB0aGUgZWRnZXMgb2YgZ2FwcyBpbiB0aGUgZGF0YS4gVGhpcyBpbXByb3ZlcyB2aXNpYmlsaXR5IG9mIHNtYWxsIGRhdGEgc2VnbWVudHMgb3Igb3RoZXIgZGF0YSBpcnJlZ3VsYXJpdGllcy5cIlxuICB9LFxuICBcImRyYXdQb2ludENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZywgc2VyaWVzTmFtZSwgY2FudmFzQ29udGV4dCwgY3gsIGN5LCBjb2xvciwgcG9pbnRTaXplKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZ1wiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJzZXJpZXNOYW1lXCIgLCBcInRoZSBuYW1lIG9mIHRoZSBzZXJpZXNcIiBdLFxuICAgICAgWyBcImNhbnZhc0NvbnRleHRcIiAsIFwidGhlIGNhbnZhcyB0byBkcmF3IG9uXCIgXSxcbiAgICAgIFsgXCJjeFwiICwgXCJjZW50ZXIgeCBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjeVwiICwgXCJjZW50ZXIgeSBjb29yZGluYXRlXCIgXSxcbiAgICAgIFsgXCJjb2xvclwiICwgXCJzZXJpZXMgY29sb3JcIiBdLFxuICAgICAgWyBcInBvaW50U2l6ZVwiICwgXCJ0aGUgcmFkaXVzIG9mIHRoZSBpbWFnZS5cIiBdLFxuICAgICAgWyBcImlkeFwiICwgXCJ0aGUgcm93LWluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGUgZGF0YS5cIl1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgY3VzdG9tIGl0ZW0gd2hlbiBkcmF3UG9pbnRzIGlzIGVuYWJsZWQuIERlZmF1bHQgaXMgYSBzbWFsbCBkb3QgbWF0Y2hpbmcgdGhlIHNlcmllcyBjb2xvci4gVGhpcyBtZXRob2Qgc2hvdWxkIGNvbnN0cmFpbiBkcmF3aW5nIHRvIHdpdGhpbiBwb2ludFNpemUgcGl4ZWxzIGZyb20gKGN4LCBjeSkuICBBbHNvIHNlZSA8YSBocmVmPScjZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2snPmRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrPC9hPlwiXG4gIH0sXG4gIFwiaGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIzMjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQsIGluIHBpeGVscywgb2YgdGhlIGNoYXJ0LiBJZiB0aGUgY29udGFpbmVyIGRpdiBoYXMgYmVlbiBleHBsaWNpdGx5IHNpemVkLCB0aGlzIHdpbGwgYmUgaWdub3JlZC5cIlxuICB9LFxuICBcInpvb21DYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihtaW5EYXRlLCBtYXhEYXRlLCB5UmFuZ2VzKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwibWluRGF0ZVwiICwgXCJtaWxsaXNlY29uZHMgc2luY2UgZXBvY2hcIiBdLFxuICAgICAgWyBcIm1heERhdGVcIiAsIFwibWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLlwiIF0sXG4gICAgICBbIFwieVJhbmdlc1wiICwgXCJpcyBhbiBhcnJheSBvZiBbYm90dG9tLCB0b3BdIHBhaXJzLCBvbmUgZm9yIGVhY2ggeS1heGlzLlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgem9vbSB3aW5kb3cgaXMgY2hhbmdlZCAoZWl0aGVyIGJ5IHpvb21pbmcgaW4gb3Igb3V0KS4gV2hlbiBhbmltYXRlZFpvb21zIGlzIHNldCwgem9vbUNhbGxiYWNrIGlzIGNhbGxlZCBvbmNlIGF0IHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24gKGl0IHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgaW50ZXJtZWRpYXRlIGZyYW1lcykuXCJcbiAgfSxcbiAgXCJwb2ludENsaWNrQ2FsbGJhY2tcIjoge1xuICAgIFwic25pcHBldFwiOiBcImZ1bmN0aW9uKGUsIHBvaW50KXs8YnI+Jm5ic3A7Jm5ic3A7YWxlcnQocG9pbnQpOzxicj59XCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiLCBcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGUsIHBvaW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZVwiICwgXCJ0aGUgZXZlbnQgb2JqZWN0IGZvciB0aGUgY2xpY2tcIiBdLFxuICAgICAgWyBcInBvaW50XCIgLCBcInRoZSBwb2ludCB0aGF0IHdhcyBjbGlja2VkIFNlZSA8YSBocmVmPScjcG9pbnRfcHJvcGVydGllcyc+UG9pbnQgcHJvcGVydGllczwvYT4gZm9yIGRldGFpbHNcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRhIHBvaW50IGlzIGNsaWNrZWQuIGFuZCB0aGUgcG9pbnQgdGhhdCB3YXMgY2xpY2tlZC5cIlxuICB9LFxuICBcImNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoc2VlIGRlc2NyaXB0aW9uKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImV4YW1wbGVcIjogXCJyZWRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBwZXItc2VyaWVzIGNvbG9yIGRlZmluaXRpb24uIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCwgYW5kIG92ZXJyaWRlcywgdGhlIGNvbG9ycyBvcHRpb24uXCJcbiAgfSxcbiAgXCJjb2xvcnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihzZWUgZGVzY3JpcHRpb24pXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5PHN0cmluZz5cIixcbiAgICBcImV4YW1wbGVcIjogXCJbJ3JlZCcsICcjMDBGRjAwJ11cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGlzdCBvZiBjb2xvcnMgZm9yIHRoZSBkYXRhIHNlcmllcy4gVGhlc2UgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIsIGV0Yy4gSWYgbm90IHNwZWNpZmllZCwgZXF1YWxseS1zcGFjZWQgcG9pbnRzIGFyb3VuZCBhIGNvbG9yIHdoZWVsIGFyZSB1c2VkLiBPdmVycmlkZGVuIGJ5IHRoZSAnY29sb3InIG9wdGlvbi5cIlxuICB9LFxuICBcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVc3VhbGx5LCB3aGVuIER5Z3JhcGhzIGVuY291bnRlcnMgYSBtaXNzaW5nIHZhbHVlIGluIGEgZGF0YSBzZXJpZXMsIGl0IGludGVycHJldHMgdGhpcyBhcyBhIGdhcCBhbmQgZHJhd3MgaXQgYXMgc3VjaC4gSWYsIGluc3RlYWQsIHRoZSBtaXNzaW5nIHZhbHVlcyByZXByZXNlbnRzIGFuIHgtdmFsdWUgZm9yIHdoaWNoIG9ubHkgYSBkaWZmZXJlbnQgc2VyaWVzIGhhcyBkYXRhLCB0aGVuIHlvdSdsbCB3YW50IHRvIGNvbm5lY3QgdGhlIGRvdHMgYnkgc2V0dGluZyB0aGlzIHRvIHRydWUuIFRvIGV4cGxpY2l0bHkgaW5jbHVkZSBhIGdhcCB3aXRoIHRoaXMgb3B0aW9uIHNldCwgdXNlIGEgdmFsdWUgb2YgTmFOLlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZXZlbnQsIHgsIHBvaW50cywgcm93LCBzZXJpZXNOYW1lKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgdGhpcyBjYWxsYmFjayBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIGEgbmV3IHBvaW50IGlzIGhpZ2hsaWdodGVkLlwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbXCJldmVudFwiLCBcInRoZSBKYXZhU2NyaXB0IG1vdXNlbW92ZSBldmVudFwiXSxcbiAgICAgIFtcInhcIiwgXCJ0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBoaWdobGlnaHRlZCBwb2ludHNcIl0sXG4gICAgICBbXCJwb2ludHNcIiwgXCJhbiBhcnJheSBvZiBoaWdobGlnaHRlZCBwb2ludHM6IDxjb2RlPlsge25hbWU6ICdzZXJpZXMnLCB5dmFsOiB5LXZhbHVlfSwgJmhlbGxpcDsgXTwvY29kZT5cIl0sXG4gICAgICBbXCJyb3dcIiwgXCJpbnRlZ2VyIGluZGV4IG9mIHRoZSBoaWdobGlnaHRlZCByb3cgaW4gdGhlIGRhdGEgdGFibGUsIHN0YXJ0aW5nIGZyb20gMFwiXSxcbiAgICAgIFtcInNlcmllc05hbWVcIiwgXCJuYW1lIG9mIHRoZSBoaWdobGlnaHRlZCBzZXJpZXMsIG9ubHkgcHJlc2VudCBpZiBoaWdobGlnaHRTZXJpZXNPcHRzIGlzIHNldC5cIl1cbiAgICBdXG4gIH0sXG4gIFwiZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihnLCBzZXJpZXNOYW1lLCBjYW52YXNDb250ZXh0LCBjeCwgY3ksIGNvbG9yLCBwb2ludFNpemUpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJnXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcInNlcmllc05hbWVcIiAsIFwidGhlIG5hbWUgb2YgdGhlIHNlcmllc1wiIF0sXG4gICAgICBbIFwiY2FudmFzQ29udGV4dFwiICwgXCJ0aGUgY2FudmFzIHRvIGRyYXcgb25cIiBdLFxuICAgICAgWyBcImN4XCIgLCBcImNlbnRlciB4IGNvb3JkaW5hdGVcIiBdLFxuICAgICAgWyBcImN5XCIgLCBcImNlbnRlciB5IGNvb3JkaW5hdGVcIiBdLFxuICAgICAgWyBcImNvbG9yXCIgLCBcInNlcmllcyBjb2xvclwiIF0sXG4gICAgICBbIFwicG9pbnRTaXplXCIgLCBcInRoZSByYWRpdXMgb2YgdGhlIGltYWdlLlwiIF0sXG4gICAgICBbIFwiaWR4XCIgLCBcInRoZSByb3ctaW5kZXggb2YgdGhlIHBvaW50IGluIHRoZSBkYXRhLlwiXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgYSBjdXN0b20gaXRlbSB3aGVuIGEgcG9pbnQgaXMgaGlnaGxpZ2h0ZWQuICBEZWZhdWx0IGlzIGEgc21hbGwgZG90IG1hdGNoaW5nIHRoZSBzZXJpZXMgY29sb3IuIFRoaXMgbWV0aG9kIHNob3VsZCBjb25zdHJhaW4gZHJhd2luZyB0byB3aXRoaW4gcG9pbnRTaXplIHBpeGVscyBmcm9tIChjeCwgY3kpIEFsc28gc2VlIDxhIGhyZWY9JyNkcmF3UG9pbnRDYWxsYmFjayc+ZHJhd1BvaW50Q2FsbGJhY2s8L2E+XCJcbiAgfSxcbiAgXCJoaWdobGlnaHRTZXJpZXNPcHRzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiT2JqZWN0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCB0aGUgb3B0aW9ucyBmcm9tIHRoaXMgb2JqZWN0IGFyZSBhcHBsaWVkIHRvIHRoZSB0aW1lc2VyaWVzIGNsb3Nlc3QgdG8gdGhlIG1vdXNlIHBvaW50ZXIgZm9yIGludGVyYWN0aXZlIGhpZ2hsaWdodGluZy4gU2VlIGFsc28gJ2hpZ2hsaWdodENhbGxiYWNrJy4gRXhhbXBsZTogaGlnaGxpZ2h0U2VyaWVzT3B0czogeyBzdHJva2VXaWR0aDogMyB9LlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZEFscGhhXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGYWRlIHRoZSBiYWNrZ3JvdW5kIHdoaWxlIGhpZ2hsaWdodGluZyBzZXJpZXMuIDE9ZnVsbHkgdmlzaWJsZSBiYWNrZ3JvdW5kIChkaXNhYmxlIGZhZGluZyksIDA9aGlkZGRlbiBiYWNrZ3JvdW5kIChzaG93IGhpZ2hsaWdodGVkIHNlcmllcyBvbmx5KS5cIlxuICB9LFxuICBcImhpZ2hsaWdodFNlcmllc0JhY2tncm91bmRDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldHMgdGhlIGJhY2tncm91bmQgY29sb3IgdXNlZCB0byBmYWRlIG91dCB0aGUgc2VyaWVzIGluIGNvbmp1bmN0aW9uIHdpdGggJ2hpZ2hsaWdodFNlcmllc0JhY2tncm91bmRBbHBoYScuXCJcbiAgfSxcbiAgXCJpbmNsdWRlWmVyb1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVc3VhbGx5LCBkeWdyYXBocyB3aWxsIHVzZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgcGx1cyBzb21lIHBhZGRpbmcgdG8gc2V0IHRoZSByYW5nZSBvZiB0aGUgeS1heGlzLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSB5LWF4aXMgd2lsbCBhbHdheXMgaW5jbHVkZSB6ZXJvLCB0eXBpY2FsbHkgYXMgdGhlIGxvd2VzdCB2YWx1ZS4gVGhpcyBjYW4gYmUgdXNlZCB0byBhdm9pZCBleGFnZ2VyYXRpbmcgdGhlIHZhcmlhbmNlIGluIHRoZSBkYXRhXCJcbiAgfSxcbiAgXCJyb2xsUGVyaW9kXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiLCBcIlJvbGxpbmcgQXZlcmFnZXNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlciAmZ3Q7PSAxXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk51bWJlciBvZiBkYXlzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSBkYXRhLiBEaXNjdXNzZWQgZXh0ZW5zaXZlbHkgYWJvdmUuXCJcbiAgfSxcbiAgXCJ1bmhpZ2hsaWdodENhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGV2ZW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZXZlbnRcIiAsIFwidGhlIG1vdXNlIGV2ZW50XCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCB0aGlzIGNhbGxiYWNrIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHVzZXIgc3RvcHMgaGlnaGxpZ2h0aW5nIGFueSBwb2ludCBieSBtb3VzaW5nIG91dCBvZiB0aGUgZ3JhcGguXCJcbiAgfSxcbiAgXCJheGlzVGlja1NpemVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjMuMFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNpemUgb2YgdGhlIGxpbmUgdG8gZGlzcGxheSBuZXh0IHRvIGVhY2ggdGljayBtYXJrIG9uIHgtIG9yIHktYXhlcy5cIlxuICB9LFxuICBcImxhYmVsc1NlcGFyYXRlTGluZXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHV0IDxjb2RlPiZsdDtici8mZ3Q7PC9jb2RlPiBiZXR3ZWVuIGxpbmVzIGluIHRoZSBsYWJlbCBzdHJpbmcuIE9mdGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCA8c3Ryb25nPmxhYmVsc0Rpdjwvc3Ryb25nPi5cIlxuICB9LFxuICBcInZhbHVlRm9ybWF0dGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJEZXBlbmRzIG9uIHRoZSB0eXBlIG9mIHlvdXIgZGF0YS5cIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIiwgXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24obnVtIG9yIG1pbGxpcywgb3B0cywgc2VyaWVzTmFtZSwgZHlncmFwaCwgcm93LCBjb2wpXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBjdXN0b20gZGlzcGxheSBmb3JtYXQgZm9yIHRoZSB2YWx1ZXMgZGlzcGxheWVkIG9uIG1vdXNlb3Zlci4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIHZhbHVlcyB0aGF0IGFwcGVhciBvbiB0aWNrIG1hcmtzIG5leHQgdG8gdGhlIGF4ZXMuIFRvIGZvcm1hdCB0aG9zZSwgc2VlIGF4aXNMYWJlbEZvcm1hdHRlci4gVGhpcyBpcyB1c3VhbGx5IHNldCBvbiBhIDxhIGhyZWY9J3Blci1heGlzLmh0bWwnPnBlci1heGlzPC9hPiBiYXNpcy4gLlwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbXCJudW1fb3JfbWlsbGlzXCIsIFwiVGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZC4gVGhpcyBpcyBhbHdheXMgYSBudW1iZXIuIEZvciBkYXRlIGF4ZXMsIGl0J3MgbWlsbGlzIHNpbmNlIGVwb2NoLiBZb3UgY2FuIGNhbGwgbmV3IERhdGUobWlsbGlzKSB0byBnZXQgYSBEYXRlIG9iamVjdC5cIl0sXG4gICAgICBbXCJvcHRzXCIsIFwiVGhpcyBpcyBhIGZ1bmN0aW9uIHlvdSBjYW4gY2FsbCB0byBhY2Nlc3MgdmFyaW91cyBvcHRpb25zIChlLmcuIG9wdHMoJ2xhYmVsc0tNQicpKS4gSXQgcmV0dXJucyBwZXItYXhpcyB2YWx1ZXMgZm9yIHRoZSBvcHRpb24gd2hlbiBhdmFpbGFibGUuXCJdLFxuICAgICAgW1wic2VyaWVzTmFtZVwiLCBcIlRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgZnJvbSB3aGljaCB0aGUgcG9pbnQgY2FtZSwgZS5nLiAnWCcsICdZJywgJ0EnLCBldGMuXCJdLFxuICAgICAgW1wiZHlncmFwaFwiLCBcIlRoZSBkeWdyYXBoIG9iamVjdCBmb3Igd2hpY2ggdGhlIGZvcm1hdHRpbmcgaXMgYmVpbmcgZG9uZVwiXSxcbiAgICAgIFtcInJvd1wiLCBcIlRoZSByb3cgb2YgdGhlIGRhdGEgZnJvbSB3aGljaCB0aGlzIHBvaW50IGNvbWVzLiBnLmdldFZhbHVlKHJvdywgMCkgd2lsbCByZXR1cm4gdGhlIHgtdmFsdWUgZm9yIHRoaXMgcG9pbnQuXCJdLFxuICAgICAgW1wiY29sXCIsIFwiVGhlIGNvbHVtbiBvZiB0aGUgZGF0YSBmcm9tIHdoaWNoIHRoaXMgcG9pbnQgY29tZXMuIGcuZ2V0VmFsdWUocm93LCBjb2wpIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCB5LXZhbHVlIGZvciB0aGlzIHBvaW50LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgZnVsbCBjb25maWRlbmNlIGludGVydmFsIGZvciB0aGUgcG9pbnQsIG9yIGFjY2VzcyB1bi1yb2xsZWQgdmFsdWVzIGZvciB0aGUgcG9pbnQuXCJdXG4gICAgXVxuICB9LFxuICBcImFubm90YXRpb25Nb3VzZU92ZXJIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oYW5ub3RhdGlvbiwgcG9pbnQsIGR5Z3JhcGgsIGV2ZW50KVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgbW91c2VzIG92ZXIgYW4gYW5ub3RhdGlvbi5cIlxuICB9LFxuICBcImFubm90YXRpb25Nb3VzZU91dEhhbmRsZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBbm5vdGF0aW9uc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihhbm5vdGF0aW9uLCBwb2ludCwgZHlncmFwaCwgZXZlbnQpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJhbm5vdGF0aW9uXCIgLCBcInRoZSBhbm5vdGF0aW9uIGxlZnRcIiBdLFxuICAgICAgWyBcInBvaW50XCIgLCBcInRoZSBwb2ludCBhc3NvY2lhdGVkIHdpdGggdGhlIGFubm90YXRpb25cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwiZXZlbnRcIiAsIFwidGhlIG1vdXNlIGV2ZW50XCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBtb3VzZXMgb3V0IG9mIGFuIGFubm90YXRpb24uXCJcbiAgfSxcbiAgXCJhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oYW5ub3RhdGlvbiwgcG9pbnQsIGR5Z3JhcGgsIGV2ZW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiYW5ub3RhdGlvblwiICwgXCJ0aGUgYW5ub3RhdGlvbiBsZWZ0XCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbm5vdGF0aW9uXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGFubm90YXRpb24uXCJcbiAgfSxcbiAgXCJhbm5vdGF0aW9uRGJsQ2xpY2tIYW5kbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oYW5ub3RhdGlvbiwgcG9pbnQsIGR5Z3JhcGgsIGV2ZW50KVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiYW5ub3RhdGlvblwiICwgXCJ0aGUgYW5ub3RhdGlvbiBsZWZ0XCIgXSxcbiAgICAgIFsgXCJwb2ludFwiICwgXCJ0aGUgcG9pbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbm5vdGF0aW9uXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcImV2ZW50XCIgLCBcInRoZSBtb3VzZSBldmVudFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiZHJhd0NhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGR5Z3JhcGgsIGlzX2luaXRpYWwpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcIlRoZSBncmFwaCBiZWluZyBkcmF3blwiIF0sXG4gICAgICBbIFwiaXNfaW5pdGlhbFwiICwgXCJUcnVlIGlmIHRoaXMgaXMgdGhlIGluaXRpYWwgZHJhdywgZmFsc2UgZm9yIHN1YnNlcXVlbnQgZHJhd3MuXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCB0aGlzIGNhbGxiYWNrIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGR5Z3JhcGggaXMgZHJhd24uIFRoaXMgaW5jbHVkZXMgdGhlIGluaXRpYWwgZHJhdywgYWZ0ZXIgem9vbWluZyBhbmQgcmVwZWF0ZWRseSB3aGlsZSBwYW5uaW5nLlwiXG4gIH0sXG4gIFwibGFiZWxzS01HMlwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGsvTS9HIGZvciBraWxvL01lZ2EvR2lnYSBvbiB5LWF4aXMuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gPGNvZGU+bGFiZWxzS01CPC9jb2RlPiBpbiB0aGF0IGl0IHVzZXMgYmFzZSAyLCBub3QgMTAuXCJcbiAgfSxcbiAgXCJkZWxpbWl0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIixcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDU1YgcGFyc2luZ1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGRlbGltaXRlciB0byBsb29rIGZvciB3aGVuIHNlcGFyYXRpbmcgZmllbGRzIG9mIGEgQ1NWIGZpbGUuIFNldHRpbmcgdGhpcyB0byBhIHRhYiBpcyBub3QgdXN1YWxseSBuZWNlc3NhcnksIHNpbmNlIHRhYi1kZWxpbWl0ZWQgZGF0YSBpcyBhdXRvLWRldGVjdGVkLlwiXG4gIH0sXG4gIFwiYXhpc0xhYmVsRm9udFNpemVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjE0XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2l6ZSBvZiB0aGUgZm9udCAoaW4gcGl4ZWxzKSB0byB1c2UgaW4gdGhlIGF4aXMgbGFiZWxzLCBib3RoIHgtIGFuZCB5LWF4aXMuXCJcbiAgfSxcbiAgXCJ1bmRlcmxheUNhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGNvbnRleHQsIGFyZWEsIGR5Z3JhcGgpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJjb250ZXh0XCIgLCBcInRoZSBjYW52YXMgZHJhd2luZyBjb250ZXh0IG9uIHdoaWNoIHRvIGRyYXdcIiBdLFxuICAgICAgWyBcImFyZWFcIiAsIFwiQW4gb2JqZWN0IHdpdGgge3gseSx3LGh9IHByb3BlcnRpZXMgZGVzY3JpYmluZyB0aGUgZHJhd2luZyBhcmVhLlwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCB0aGlzIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZSB0aGUgY2hhcnQgaXMgZHJhd24uIEl0IGRldGFpbHMgb24gaG93IHRvIHVzZSB0aGlzLlwiXG4gIH0sXG4gIFwid2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjQ4MFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIk92ZXJhbGwgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldpZHRoLCBpbiBwaXhlbHMsIG9mIHRoZSBjaGFydC4gSWYgdGhlIGNvbnRhaW5lciBkaXYgaGFzIGJlZW4gZXhwbGljaXRseSBzaXplZCwgdGhpcyB3aWxsIGJlIGlnbm9yZWQuXCJcbiAgfSxcbiAgXCJwaXhlbFJhdGlvXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoZGV2aWNlUGl4ZWxSYXRpbyAvIGNvbnRleHQuYmFja2luZ1N0b3JlUmF0aW8pXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiT3ZlcmFsbCBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk92ZXJyaWRlcyB0aGUgcGl4ZWwgcmF0aW8gc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBjYW52YXMncyAyZCBjb250ZXh0LiBPcmRpbmFyaWx5LCB0aGlzIGlzIHNldCB0byB0aGUgZGV2aWNlUGl4ZWxSYXRpbyAvIChjb250ZXh0LmJhY2tpbmdTdG9yZVJhdGlvIHx8IDEpLCBzbyBvbiBtb2JpbGUgZGV2aWNlcywgd2hlcmUgdGhlIGRldmljZVBpeGVsUmF0aW8gY2FuIGJlIHNvbWV3aGVyZSBhcm91bmQgMywgcGVyZm9ybWFuY2UgY2FuIGJlIGltcHJvdmVkIGJ5IG92ZXJyaWRpbmcgdGhpcyB2YWx1ZSB0byBzb21ldGhpbmcgbGVzcyBwcmVjaXNlLCBsaWtlIDEsIGF0IHRoZSBleHBlbnNlIG9mIHJlc29sdXRpb24uXCJcbiAgfSxcbiAgXCJpbnRlcmFjdGlvbk1vZGVsXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIuLi5cIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVE9ETyhrb25pZ3NiZXJnKTogZG9jdW1lbnQgdGhpc1wiXG4gIH0sXG4gIFwidGlja2VyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJEeWdyYXBoLmRhdGVUaWNrZXIgb3IgRHlncmFwaC5udW1lcmljVGlja3NcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24obWluLCBtYXgsIHBpeGVscywgb3B0cywgZHlncmFwaCwgdmFscykgLT4gW3t2OiAuLi4sIGxhYmVsOiAuLi59LCAuLi5dXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJtaW5cIiAsIFwiXCIgXSxcbiAgICAgIFsgXCJtYXhcIiAsIFwiXCIgXSxcbiAgICAgIFsgXCJwaXhlbHNcIiAsIFwiXCIgXSxcbiAgICAgIFsgXCJvcHRzXCIgLCBcIlwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJ2YWxzXCIgLCBcIlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGlzIGxldHMgeW91IHNwZWNpZnkgYW4gYXJiaXRyYXJ5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRpY2sgbWFya3Mgb24gYW4gYXhpcy4gVGhlIHRpY2sgbWFya3MgYXJlIGFuIGFycmF5IG9mICh2YWx1ZSwgbGFiZWwpIHBhaXJzLiBUaGUgYnVpbHQtaW4gZnVuY3Rpb25zIGdvIHRvIGdyZWF0IGxlbmd0aHMgdG8gY2hvb3NlIGdvb2QgdGljayBtYXJrcyBzbywgaWYgeW91IHNldCB0aGlzIG9wdGlvbiwgeW91J2xsIG1vc3QgbGlrZWx5IHdhbnQgdG8gY2FsbCBvbmUgb2YgdGhlbSBhbmQgbW9kaWZ5IHRoZSByZXN1bHQuIFNlZSBkeWdyYXBoLXRpY2tlcnMuanMgZm9yIGFuIGV4dGVuc2l2ZSBkaXNjdXNzaW9uLiBUaGlzIGlzIHNldCBvbiBhIDxhIGhyZWY9J3Blci1heGlzLmh0bWwnPnBlci1heGlzPC9hPiBiYXNpcy5cIlxuICB9LFxuICBcInhBeGlzSGVpZ2h0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIobnVsbClcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQsIGluIHBpeGVscywgb2YgdGhlIHgtYXhpcy4gSWYgbm90IHNldCBleHBsaWNpdGx5LCB0aGlzIGlzIGNvbXB1dGVkIGJhc2VkIG9uIGF4aXNMYWJlbEZvbnRTaXplIGFuZCBheGlzVGlja1NpemUuXCJcbiAgfSxcbiAgXCJzaG93TGFiZWxzT25IaWdobGlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiLCBcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZXRoZXIgdG8gc2hvdyB0aGUgbGVnZW5kIHVwb24gbW91c2VvdmVyLlwiXG4gIH0sXG4gIFwiYXhpc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKG5vbmUpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgdG8gZWl0aGVyICd5MScgb3IgJ3kyJyB0byBhc3NpZ24gYSBzZXJpZXMgdG8gYSB5LWF4aXMgKHByaW1hcnkgb3Igc2Vjb25kYXJ5KS4gTXVzdCBiZSBzZXQgcGVyLXNlcmllcy5cIlxuICB9LFxuICBcInBpeGVsc1BlckxhYmVsXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI3MCAoeC1heGlzKSBvciAzMCAoeS1heGVzKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiLCBcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgcGl4ZWxzIHRvIHJlcXVpcmUgYmV0d2VlbiBlYWNoIHgtIGFuZCB5LWxhYmVsLiBMYXJnZXIgdmFsdWVzIHdpbGwgeWllbGQgYSBzcGFyc2VyIGF4aXMgd2l0aCBmZXdlciB0aWNrcy4gVGhpcyBpcyBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJsYWJlbHNEaXZcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiRE9NIGVsZW1lbnQgb3Igc3RyaW5nXCIsXG4gICAgXCJleGFtcGxlXCI6IFwiPGNvZGUgc3R5bGU9J2ZvbnQtc2l6ZTogc21hbGwnPmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb28nKTwvY29kZT5vcjxjb2RlPidmb28nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3cgZGF0YSBsYWJlbHMgaW4gYW4gZXh0ZXJuYWwgZGl2LCByYXRoZXIgdGhhbiBvbiB0aGUgZ3JhcGguICBUaGlzIHZhbHVlIGNhbiBlaXRoZXIgYmUgYSBkaXYgZWxlbWVudCBvciBhIGRpdiBpZC5cIlxuICB9LFxuICBcImZyYWN0aW9uc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDU1YgcGFyc2luZ1wiLCBcIkVycm9yIEJhcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgYXR0ZW1wdCB0byBwYXJzZSBlYWNoIGNlbGwgaW4gdGhlIENTViBmaWxlIGFzIFxcXCJhL2JcXFwiLCB3aGVyZSBhIGFuZCBiIGFyZSBpbnRlZ2Vycy4gVGhlIHJhdGlvIHdpbGwgYmUgcGxvdHRlZC4gVGhpcyBhbGxvd3MgY29tcHV0YXRpb24gb2YgV2lsc29uIGNvbmZpZGVuY2UgaW50ZXJ2YWxzIChzZWUgYmVsb3cpLlwiXG4gIH0sXG4gIFwibG9nc2NhbGVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQgZm9yIHRoZSB5LWF4aXMgb3IgeC1heGlzLCB0aGUgZ3JhcGggc2hvd3MgdGhhdCBheGlzIGluIGxvZyBzY2FsZS4gQW55IHZhbHVlcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyBhcmUgbm90IGRpc3BsYXllZC4gU2hvd2luZyBsb2cgc2NhbGUgd2l0aCByYW5nZXMgdGhhdCBnbyBiZWxvdyB6ZXJvIHdpbGwgcmVzdWx0IGluIGFuIHVudmlld2FibGUgZ3JhcGguXFxuXFxuIE5vdCBjb21wYXRpYmxlIHdpdGggc2hvd1plcm8uIGNvbm5lY3RTZXBhcmF0ZWRQb2ludHMgaXMgaWdub3JlZC4gVGhpcyBpcyBpZ25vcmVkIGZvciBkYXRlLWJhc2VkIHgtYXhlcy5cIlxuICB9LFxuICBcInN0cm9rZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIjAuNSwgMi4wXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbGluZXMgY29ubmVjdGluZyBkYXRhIHBvaW50cy4gVGhpcyBjYW4gYmUgdXNlZCB0byBpbmNyZWFzZSB0aGUgY29udHJhc3Qgb3Igc29tZSBncmFwaHMuXCJcbiAgfSxcbiAgXCJzdHJva2VQYXR0ZXJuXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYXJyYXk8aW50ZWdlcj5cIixcbiAgICBcImV4YW1wbGVcIjogXCJbMTAsIDIsIDUsIDJdXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgY3VzdG9tIHBhdHRlcm4gYXJyYXkgd2hlcmUgdGhlIGV2ZW4gaW5kZXggaXMgYSBkcmF3IGFuZCBvZGQgaXMgYSBzcGFjZSBpbiBwaXhlbHMuIElmIG51bGwgdGhlbiBpdCBkcmF3cyBhIHNvbGlkIGxpbmUuIFRoZSBhcnJheSBzaG91bGQgaGF2ZSBhIGV2ZW4gbGVuZ3RoIGFzIGFueSBvZGQgbGVuZ3RoZWQgYXJyYXkgY291bGQgYmUgZXhwcmVzc2VkIGFzIGEgc21hbGxlciBldmVuIGxlbmd0aCBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBkYXNoZWQgbGluZXMuXCJcbiAgfSxcbiAgXCJzdHJva2VCb3JkZXJXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiMS4wXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgYSBib3JkZXIgYXJvdW5kIGdyYXBoIGxpbmVzIHRvIG1ha2UgY3Jvc3NpbmcgbGluZXMgbW9yZSBlYXNpbHkgZGlzdGluZ3Vpc2hhYmxlLiBVc2VmdWwgZm9yIGdyYXBocyB3aXRoIG1hbnkgbGluZXMuXCJcbiAgfSxcbiAgXCJzdHJva2VCb3JkZXJDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwid2hpdGVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImV4YW1wbGVcIjogXCJyZWQsICNjY2ZmZGRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ29sb3IgZm9yIHRoZSBsaW5lIGJvcmRlciB1c2VkIGlmIHN0cm9rZUJvcmRlcldpZHRoIGlzIHNldC5cIlxuICB9LFxuICBcIndpbHNvbkludGVydmFsXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBcXFwiZnJhY3Rpb25zXFxcIiBvcHRpb24uIEluc3RlYWQgb2YgcGxvdHRpbmcgKy8tIE4gc3RhbmRhcmQgZGV2aWF0aW9ucywgZHlncmFwaHMgd2lsbCBjb21wdXRlIGEgV2lsc29uIGNvbmZpZGVuY2UgaW50ZXJ2YWwgYW5kIHBsb3QgdGhhdC4gVGhpcyBoYXMgbW9yZSByZWFzb25hYmxlIGJlaGF2aW9yIGZvciByYXRpb3MgY2xvc2UgdG8gMCBvciAxLlwiXG4gIH0sXG4gIFwiZmlsbEdyYXBoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdWxkIHRoZSBhcmVhIHVuZGVybmVhdGggdGhlIGdyYXBoIGJlIGZpbGxlZD8gVGhpcyBvcHRpb24gaXMgbm90IGNvbXBhdGlibGUgd2l0aCBlcnJvciBiYXJzLiBUaGlzIG1heSBiZSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItc2VyaWVzPC9hPiBiYXNpcy5cIlxuICB9LFxuICBcImhpZ2hsaWdodENpcmNsZVNpemVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjNcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgZG90IGRyYXduIG92ZXIgaGlnaGxpZ2h0ZWQgcG9pbnRzLlwiXG4gIH0sXG4gIFwiZ3JpZExpbmVDb2xvclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwicmdiKDEyOCwxMjgsMTI4KVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwicmVkLCBibHVlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjb2xvciBvZiB0aGUgZ3JpZGxpbmVzLiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgZWFjaCBheGlzJyBncmlkIHNlcGFyYXRlbHkuXCJcbiAgfSxcbiAgXCJncmlkTGluZVBhdHRlcm5cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5PGludGVnZXI+XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWzEwLCAyLCA1LCAyXVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGN1c3RvbSBwYXR0ZXJuIGFycmF5IHdoZXJlIHRoZSBldmVuIGluZGV4IGlzIGEgZHJhdyBhbmQgb2RkIGlzIGEgc3BhY2UgaW4gcGl4ZWxzLiBJZiBudWxsIHRoZW4gaXQgZHJhd3MgYSBzb2xpZCBsaW5lLiBUaGUgYXJyYXkgc2hvdWxkIGhhdmUgYSBldmVuIGxlbmd0aCBhcyBhbnkgb2RkIGxlbmd0aGVkIGFycmF5IGNvdWxkIGJlIGV4cHJlc3NlZCBhcyBhIHNtYWxsZXIgZXZlbiBsZW5ndGggYXJyYXkuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgZGFzaGVkIGdyaWRsaW5lcy5cIlxuICB9LFxuICBcInZpc2liaWxpdHlcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIlt0cnVlLCB0cnVlLCAuLi5dXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiQXJyYXkgb2YgYm9vbGVhbnNcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hpY2ggc2VyaWVzIHNob3VsZCBpbml0aWFsbHkgYmUgdmlzaWJsZT8gT25jZSB0aGUgRHlncmFwaCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCwgeW91IGNhbiBhY2Nlc3MgYW5kIG1vZGlmeSB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoIHNlcmllcyB1c2luZyB0aGUgPGNvZGU+dmlzaWJpbGl0eTwvY29kZT4gYW5kIDxjb2RlPnNldFZpc2liaWxpdHk8L2NvZGU+IG1ldGhvZHMuXCJcbiAgfSxcbiAgXCJ2YWx1ZVJhbmdlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJGdWxsIHJhbmdlIG9mIHRoZSBpbnB1dCBpcyBzaG93blwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheSBvZiB0d28gbnVtYmVyc1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIlsxMCwgMTEwXVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJFeHBsaWNpdGx5IHNldCB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGdyYXBoIHRvIFtsb3csIGhpZ2hdLiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgZWFjaCB5LWF4aXMgc2VwYXJhdGVseS4gSWYgZWl0aGVyIGxpbWl0IGlzIHVuc3BlY2lmaWVkLCBpdCB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSAoZS5nLiBbbnVsbCwgMzBdIHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIGp1c3QgdGhlIGxvd2VyIGJvdW5kKVwiXG4gIH0sXG4gIFwiY29sb3JTYXR1cmF0aW9uXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgPHN0cm9uZz5jb2xvcnM8L3N0cm9uZz4gaXMgbm90IHNwZWNpZmllZCwgc2F0dXJhdGlvbiBvZiB0aGUgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgZGF0YSBzZXJpZXMgY29sb3JzLlwiXG4gIH0sXG4gIFwiaGlkZU92ZXJsYXlPbk1vdXNlT3V0XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIiwgXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGV0aGVyIHRvIGhpZGUgdGhlIGxlZ2VuZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNoYXJ0IGFyZWEuXCJcbiAgfSxcbiAgXCJsZWdlbmRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm9ubW91c2VvdmVyXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHRvIGRpc3BsYXkgdGhlIGxlZ2VuZC4gQnkgZGVmYXVsdCwgaXQgb25seSBhcHBlYXJzIHdoZW4gYSB1c2VyIG1vdXNlcyBvdmVyIHRoZSBjaGFydC4gU2V0IGl0IHRvIFxcXCJhbHdheXNcXFwiIHRvIGFsd2F5cyBkaXNwbGF5IGEgbGVnZW5kIG9mIHNvbWUgc29ydC4gV2hlbiBzZXQgdG8gXFxcImZvbGxvd1xcXCIsIGxlZ2VuZCBmb2xsb3dzIGhpZ2hsaWdodGVkIHBvaW50cy5cIlxuICB9LFxuICBcImxlZ2VuZEZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihkYXRhKTogc3RyaW5nXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAgWyBcImRhdGFcIiwgXCJBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VsZWN0aW9uIChvciBsYWNrIG9mIGEgc2VsZWN0aW9uKS4gVGhpcyBpbmNsdWRlcyBmb3JtYXR0ZWQgdmFsdWVzIGFuZCBzZXJpZXMgaW5mb3JtYXRpb24uIFNlZSA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vZGFudmsvZHlncmFwaHMvcHVsbC82ODNcXFwiPmhlcmU8L2E+IGZvciBzYW1wbGUgdmFsdWVzLlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgdGhpcyB0byBzdXBwbHkgYSBjdXN0b20gZm9ybWF0dGVyIGZvciB0aGUgbGVnZW5kLiBTZWUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2RhbnZrL2R5Z3JhcGhzL3B1bGwvNjgzXFxcIj50aGlzIGNvbW1lbnQ8L2E+IGFuZCB0aGUgPGEgaHJlZj1cXFwidGVzdHMvbGVnZW5kLWZvcm1hdHRlci5odG1sXFxcIj5sZWdlbmRGb3JtYXR0ZXIgZGVtbzwvYT4gZm9yIHVzYWdlLlwiXG4gIH0sXG4gIFwibGFiZWxzU2hvd1plcm9WYWx1ZXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IHplcm8gdmFsdWUgbGFiZWxzIGluIHRoZSBsYWJlbHNEaXYuXCJcbiAgfSxcbiAgXCJzdGVwUGxvdFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBkaXNwbGF5IHRoZSBncmFwaCBhcyBhIHN0ZXAgcGxvdCBpbnN0ZWFkIG9mIGEgbGluZSBwbG90LiBUaGlzIG9wdGlvbiBtYXkgZWl0aGVyIGJlIHNldCBmb3IgdGhlIHdob2xlIGdyYXBoIG9yIGZvciBzaW5nbGUgc2VyaWVzLlwiXG4gIH0sXG4gIFwibGFiZWxzVVRDXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZ1wiLCBcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3cgZGF0ZS90aW1lIGxhYmVscyBhY2NvcmRpbmcgdG8gVVRDIChpbnN0ZWFkIG9mIGxvY2FsIHRpbWUpLlwiXG4gIH0sXG4gIFwibGFiZWxzS01CXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZ1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3cgSy9NL0IgZm9yIHRob3VzYW5kcy9taWxsaW9ucy9iaWxsaW9ucyBvbiB5LWF4aXMuXCJcbiAgfSxcbiAgXCJyaWdodEdhcFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiNVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIk92ZXJhbGwgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk51bWJlciBvZiBwaXhlbHMgdG8gbGVhdmUgYmxhbmsgYXQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIER5Z3JhcGguIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIGhpZ2hsaWdodCB0aGUgcmlnaHQtbW9zdCBkYXRhIHBvaW50LlwiXG4gIH0sXG4gIFwiZHJhd0F4ZXNBdFplcm9cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIGRyYXcgdGhlIFggYXhpcyBhdCB0aGUgWT0wIHBvc2l0aW9uIGFuZCB0aGUgWSBheGlzIGF0IHRoZSBYPTAgcG9zaXRpb24gaWYgdGhvc2UgcG9zaXRpb25zIGFyZSBpbnNpZGUgdGhlIGdyYXBoJ3MgdmlzaWJsZSBhcmVhLiBPdGhlcndpc2UsIGRyYXcgdGhlIGF4ZXMgYXQgdGhlIGJvdHRvbSBvciBsZWZ0IGdyYXBoIGVkZ2UgYXMgdXN1YWwuXCJcbiAgfSxcbiAgXCJ4UmFuZ2VQYWRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkIHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIGV4dHJhIHNwYWNlIChpbiBwaXhlbHMpIGFyb3VuZCB0aGUgWC1heGlzIHZhbHVlIHJhbmdlIHRvIGVuc3VyZSBwb2ludHMgYXQgdGhlIGVkZ2VzIHJlbWFpbiB2aXNpYmxlLlwiXG4gIH0sXG4gIFwieVJhbmdlUGFkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHNldCwgYWRkIHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIGV4dHJhIHNwYWNlIChpbiBwaXhlbHMpIGFyb3VuZCB0aGUgWS1heGlzIHZhbHVlIHJhbmdlIHRvIGVuc3VyZSBwb2ludHMgYXQgdGhlIGVkZ2VzIHJlbWFpbiB2aXNpYmxlLiBJZiB1bnNldCwgdXNlIHRoZSB0cmFkaXRpb25hbCBZIHBhZGRpbmcgYWxnb3JpdGhtLlwiXG4gIH0sXG4gIFwiYXhpc0xhYmVsRm9ybWF0dGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJEZXBlbmRzIG9uIHRoZSBkYXRhIHR5cGVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24obnVtYmVyIG9yIERhdGUsIGdyYW51bGFyaXR5LCBvcHRzLCBkeWdyYXBoKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwibnVtYmVyIG9yIGRhdGVcIiAsIFwiRWl0aGVyIGEgbnVtYmVyIChmb3IgYSBudW1lcmljIGF4aXMpIG9yIGEgRGF0ZSBvYmplY3QgKGZvciBhIGRhdGUgYXhpcylcIiBdLFxuICAgICAgWyBcImdyYW51bGFyaXR5XCIgLCBcInNwZWNpZmllcyBob3cgZmluZS1ncmFpbmVkIHRoZSBheGlzIGlzLiBGb3IgZGF0ZSBheGVzLCB0aGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSB0aW1lIGdyYW51bGFyaXR5IGVudW1lcmF0aW9uLCBkZWZpbmVkIGluIGR5Z3JhcGgtdGlja2Vycy5qcywgZS5nLiBEeWdyYXBoLldFRUtMWS5cIiBdLFxuICAgICAgWyBcIm9wdHNcIiAsIFwiYSBmdW5jdGlvbiB3aGljaCBwcm92aWRlcyBhY2Nlc3MgdG8gdmFyaW91cyBvcHRpb25zIG9uIHRoZSBkeWdyYXBoLCBlLmcuIG9wdHMoJ2xhYmVsc0tNQicpLlwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlZCBncmFwaFwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGdW5jdGlvbiB0byBjYWxsIHRvIGZvcm1hdCB0aGUgdGljayB2YWx1ZXMgdGhhdCBhcHBlYXIgYWxvbmcgYW4gYXhpcy4gVGhpcyBpcyB1c3VhbGx5IHNldCBvbiBhIDxhIGhyZWY9J3Blci1heGlzLmh0bWwnPnBlci1heGlzPC9hPiBiYXNpcy5cIlxuICB9LFxuICBcImNsaWNrQ2FsbGJhY2tcIjoge1xuICAgIFwic25pcHBldFwiOiBcImZ1bmN0aW9uKGUsIGRhdGVfbWlsbGlzKXs8YnI+Jm5ic3A7Jm5ic3A7YWxlcnQobmV3IERhdGUoZGF0ZV9taWxsaXMpKTs8YnI+fVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZSwgeCwgcG9pbnRzKVwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiBbXG4gICAgICBbIFwiZVwiICwgXCJUaGUgZXZlbnQgb2JqZWN0IGZvciB0aGUgY2xpY2tcIiBdLFxuICAgICAgWyBcInhcIiAsIFwiVGhlIHggdmFsdWUgdGhhdCB3YXMgY2xpY2tlZCAoZm9yIGRhdGVzLCB0aGlzIGlzIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaClcIiBdLFxuICAgICAgWyBcInBvaW50c1wiICwgXCJUaGUgY2xvc2VzdCBwb2ludHMgYWxvbmcgdGhhdCBkYXRlLiBTZWUgPGEgaHJlZj0nI3BvaW50X3Byb3BlcnRpZXMnPlBvaW50IHByb3BlcnRpZXM8L2E+IGZvciBkZXRhaWxzLlwiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgY2FudmFzIGlzIGNsaWNrZWQuXCJcbiAgfSxcbiAgXCJsYWJlbHNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIltcXFwiWFxcXCIsIFxcXCJZMVxcXCIsIFxcXCJZMlxcXCIsIC4uLl0qXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5PHN0cmluZz5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBuYW1lIGZvciBlYWNoIGRhdGEgc2VyaWVzLCBpbmNsdWRpbmcgdGhlIGluZGVwZW5kZW50IChYKSBzZXJpZXMuIEZvciBDU1YgZmlsZXMgYW5kIERhdGFUYWJsZSBvYmplY3Rpb25zLCB0aGlzIGlzIGRldGVybWluZWQgYnkgY29udGV4dC4gRm9yIHJhdyBkYXRhLCB0aGlzIG11c3QgYmUgc3BlY2lmaWVkLiBJZiBpdCBpcyBub3QsIGRlZmF1bHQgdmFsdWVzIGFyZSBzdXBwbGllZCBhbmQgYSB3YXJuaW5nIGlzIGxvZ2dlZC5cIlxuICB9LFxuICBcImRhdGVXaW5kb3dcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIkZ1bGwgcmFuZ2Ugb2YgdGhlIGlucHV0IGlzIHNob3duXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcIkFycmF5IG9mIHR3byBudW1iZXJzXCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWzxicj4mbmJzcDsmbmJzcDtEYXRlLnBhcnNlKCcyMDA2LTAxLTAxJyksPGJyPiZuYnNwOyZuYnNwOyhuZXcgRGF0ZSgpKS52YWx1ZU9mKCk8YnI+XVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbml0aWFsbHkgem9vbSBpbiBvbiBhIHNlY3Rpb24gb2YgdGhlIGdyYXBoLiBJcyBvZiB0aGUgZm9ybSBbZWFybGllc3QsIGxhdGVzdF0sIHdoZXJlIGVhcmxpZXN0L2xhdGVzdCBhcmUgbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLiBJZiB0aGUgZGF0YSBmb3IgdGhlIHgtYXhpcyBpcyBudW1lcmljLCB0aGUgdmFsdWVzIGluIGRhdGVXaW5kb3cgbXVzdCBhbHNvIGJlIG51bWJlcnMuXCJcbiAgfSxcbiAgXCJzaG93Um9sbGVyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCIsIFwiUm9sbGluZyBBdmVyYWdlc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRoZSByb2xsaW5nIGF2ZXJhZ2UgcGVyaW9kIHRleHQgYm94IHNob3VsZCBiZSBzaG93bi5cIlxuICB9LFxuICBcInNpZ21hXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIyLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gZXJyb3JCYXJzIGlzIHNldCwgc2hhZGUgdGhpcyBtYW55IHN0YW5kYXJkIGRldmlhdGlvbnMgYWJvdmUvYmVsb3cgZWFjaCBwb2ludC5cIlxuICB9LFxuICBcImN1c3RvbUJhcnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHBhcnNlIGVhY2ggQ1NWIGNlbGwgYXMgXFxcImxvdzttaWRkbGU7aGlnaFxcXCIuIEVycm9yIGJhcnMgd2lsbCBiZSBkcmF3biBmb3IgZWFjaCBwb2ludCBiZXR3ZWVuIGxvdyBhbmQgaGlnaCwgd2l0aCB0aGUgc2VyaWVzIGl0c2VsZiBnb2luZyB0aHJvdWdoIG1pZGRsZS5cIlxuICB9LFxuICBcImNvbG9yVmFsdWVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjEuMFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgU2VyaWVzIENvbG9yc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdCAoMC4wIC0gMS4wKVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBjb2xvcnMgaXMgbm90IHNwZWNpZmllZCwgdmFsdWUgb2YgdGhlIGRhdGEgc2VyaWVzIGNvbG9ycywgYXMgaW4gaHVlL3NhdHVyYXRpb24vdmFsdWUuICgwLjAtMS4wLCBkZWZhdWx0IDAuNSlcIlxuICB9LFxuICBcImVycm9yQmFyc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDU1YgcGFyc2luZ1wiLCBcIkVycm9yIEJhcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEb2VzIHRoZSBkYXRhIGNvbnRhaW4gc3RhbmRhcmQgZGV2aWF0aW9ucz8gU2V0dGluZyB0aGlzIHRvIHRydWUgYWx0ZXJzIHRoZSBpbnB1dCBmb3JtYXQgKHNlZSBhYm92ZSkuXCJcbiAgfSxcbiAgXCJkaXNwbGF5QW5ub3RhdGlvbnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQW5ub3RhdGlvbnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbmx5IGFwcGxpZXMgd2hlbiBEeWdyYXBocyBpcyB1c2VkIGFzIGEgR1ZpeiBjaGFydC4gQ2F1c2VzIHN0cmluZyBjb2x1bW5zIGZvbGxvd2luZyBhIGRhdGEgc2VyaWVzIHRvIGJlIGludGVycHJldGVkIGFzIGFubm90YXRpb25zIG9uIHBvaW50cyBpbiB0aGF0IHNlcmllcy4gVGhpcyBpcyB0aGUgc2FtZSBmb3JtYXQgdXNlZCBieSBHb29nbGUncyBBbm5vdGF0ZWRUaW1lTGluZSBjaGFydC5cIlxuICB9LFxuICBcInBhbkVkZ2VGcmFjdGlvblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiLCBcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBmYXJ0aGVzdCBhIGdyYXBoIG1heSBiZSBwYW5uZWQsIGluIHBlcmNlbnQgb2YgdGhlIGRpc3BsYXkuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIDAuMSBtZWFucyB0aGF0IHRoZSBncmFwaCBjYW4gb25seSBiZSBwYW5uZWQgMTAlIHBhc3NlZCB0aGUgZWRnZXMgb2YgdGhlIGRpc3BsYXllZCB2YWx1ZXMuIG51bGwgbWVhbnMgbm8gYm91bmRzLlwiXG4gIH0sXG4gIFwidGl0bGVcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSBhYm92ZSB0aGUgY2hhcnQuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXRpdGxlJyBjbGFzc2VzLlwiXG4gIH0sXG4gIFwidGl0bGVIZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjE4XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0IG9mIHRoZSBjaGFydCB0aXRsZSwgaW4gcGl4ZWxzLiBUaGlzIGFsc28gY29udHJvbHMgdGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSB0aXRsZS4gSWYgeW91IHN0eWxlIHRoZSB0aXRsZSBvbiB5b3VyIG93biwgdGhpcyBjb250cm9scyBob3cgbXVjaCBzcGFjZSBpcyBzZXQgYXNpZGUgYWJvdmUgdGhlIGNoYXJ0IGZvciB0aGUgdGl0bGUncyBkaXYuXCJcbiAgfSxcbiAgXCJ4bGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSBiZWxvdyB0aGUgY2hhcnQncyB4LWF4aXMuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXhsYWJlbCcgY2xhc3Nlcy5cIlxuICB9LFxuICBcInhMYWJlbEhlaWdodFwiOiB7XG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlZmF1bHRcIjogXCIxOFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQgb2YgdGhlIHgtYXhpcyBsYWJlbCwgaW4gcGl4ZWxzLiBUaGlzIGFsc28gY29udHJvbHMgdGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSB4LWF4aXMgbGFiZWwuIElmIHlvdSBzdHlsZSB0aGUgbGFiZWwgb24geW91ciBvd24sIHRoaXMgY29udHJvbHMgaG93IG11Y2ggc3BhY2UgaXMgc2V0IGFzaWRlIGJlbG93IHRoZSBjaGFydCBmb3IgdGhlIHgtYXhpcyBsYWJlbCdzIGRpdi5cIlxuICB9LFxuICBcInlsYWJlbFwiOiB7XG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGV4dCB0byBkaXNwbGF5IHRvIHRoZSBsZWZ0IG9mIHRoZSBjaGFydCdzIHktYXhpcy4gWW91IGNhbiBzdXBwbHkgYW55IEhUTUwgZm9yIHRoaXMgdmFsdWUsIG5vdCBqdXN0IHRleHQuIElmIHlvdSB3aXNoIHRvIHN0eWxlIGl0IHVzaW5nIENTUywgdXNlIHRoZSAnZHlncmFwaC1sYWJlbCcgb3IgJ2R5Z3JhcGgteWxhYmVsJyBjbGFzc2VzLiBUaGUgdGV4dCB3aWxsIGJlIHJvdGF0ZWQgOTAgZGVncmVlcyBieSBkZWZhdWx0LCBzbyBDU1MgcnVsZXMgbWF5IGJlaGF2ZSBpbiB1bmludHVpdGl2ZSB3YXlzLiBObyBhZGRpdGlvbmFsIHNwYWNlIGlzIHNldCBhc2lkZSBmb3IgYSB5LWF4aXMgbGFiZWwuIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UsIGluY3JlYXNlIHRoZSB3aWR0aCBvZiB0aGUgeS1heGlzIHRpY2sgbGFiZWxzIHVzaW5nIHRoZSB5QXhpc0xhYmVsV2lkdGggb3B0aW9uLiBJZiB5b3UgbmVlZCBhIHdpZGVyIGRpdiBmb3IgdGhlIHktYXhpcyBsYWJlbCwgZWl0aGVyIHN0eWxlIGl0IHRoYXQgd2F5IHdpdGggQ1NTIChidXQgcmVtZW1iZXIgdGhhdCBpdCdzIHJvdGF0ZWQsIHNvIHdpZHRoIGlzIGNvbnRyb2xsZWQgYnkgdGhlICdoZWlnaHQnIHByb3BlcnR5KSBvciBzZXQgdGhlIHlMYWJlbFdpZHRoIG9wdGlvbi5cIlxuICB9LFxuICBcInkybGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSB0byB0aGUgcmlnaHQgb2YgdGhlIGNoYXJ0J3Mgc2Vjb25kYXJ5IHktYXhpcy4gVGhpcyBsYWJlbCBpcyBvbmx5IGRpc3BsYXllZCBpZiBhIHNlY29uZGFyeSB5LWF4aXMgaXMgcHJlc2VudC4gU2VlIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvdHdvLWF4ZXMuaHRtbCc+dGhpcyB0ZXN0PC9hPiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZG8gdGhpcy4gVGhlIGNvbW1lbnRzIGZvciB0aGUgJ3lsYWJlbCcgb3B0aW9uIGdlbmVyYWxseSBhcHBseSBoZXJlIGFzIHdlbGwuIFRoaXMgbGFiZWwgZ2V0cyBhICdkeWdyYXBoLXkybGFiZWwnIGluc3RlYWQgb2YgYSAnZHlncmFwaC15bGFiZWwnIGNsYXNzLlwiXG4gIH0sXG4gIFwieUxhYmVsV2lkdGhcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiMThcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2lkdGggb2YgdGhlIGRpdiB3aGljaCBjb250YWlucyB0aGUgeS1heGlzIGxhYmVsLiBTaW5jZSB0aGUgeS1heGlzIGxhYmVsIGFwcGVhcnMgcm90YXRlZCA5MCBkZWdyZWVzLCB0aGlzIGFjdHVhbGx5IGFmZmVjdHMgdGhlIGhlaWdodCBvZiBpdHMgZGl2LlwiXG4gIH0sXG4gIFwiZHJhd0dyaWRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWUgZm9yIHggYW5kIHksIGZhbHNlIGZvciB5MlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2hldGhlciB0byBkaXNwbGF5IGdyaWRsaW5lcyBpbiB0aGUgY2hhcnQuIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoIGF4aXMnIGdyaWQgc2VwYXJhdGVseS5cIlxuICB9LFxuICBcImluZGVwZW5kZW50VGlja3NcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWUgZm9yIHksIGZhbHNlIGZvciB5MlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiLCBcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiT25seSB2YWxpZCBmb3IgeSBhbmQgeTIsIGhhcyBubyBlZmZlY3Qgb24geDogVGhpcyBvcHRpb24gZGVmaW5lcyB3aGV0aGVyIHRoZSB5IGF4ZXMgc2hvdWxkIGFsaWduIHRoZWlyIHRpY2tzIG9yIGlmIHRoZXkgc2hvdWxkIGJlIGluZGVwZW5kZW50LiBQb3NzaWJsZSBjb21iaW5hdGlvbnM6IDEuKSB5PXRydWUsIHkyPWZhbHNlIChkZWZhdWx0KTogeSBpcyB0aGUgcHJpbWFyeSBheGlzIGFuZCB0aGUgeTIgdGlja3MgYXJlIGFsaWduZWQgdG8gdGhlIHRoZSBvbmVzIG9mIHkuIChvbmx5IDEgZ3JpZCkgMi4pIHk9ZmFsc2UsIHkyPXRydWU6IHkyIGlzIHRoZSBwcmltYXJ5IGF4aXMgYW5kIHRoZSB5IHRpY2tzIGFyZSBhbGlnbmVkIHRvIHRoZSB0aGUgb25lcyBvZiB5Mi4gKG9ubHkgMSBncmlkKSAzLikgeT10cnVlLCB5Mj10cnVlOiBCb3RoIGF4aXMgYXJlIGluZGVwZW5kZW50IGFuZCBoYXZlIHRoZWlyIG93biB0aWNrcy4gKDIgZ3JpZHMpIDQuKSB5PWZhbHNlLCB5Mj1mYWxzZTogSW52YWxpZCBjb25maWd1cmF0aW9uIGNhdXNlcyBhbiBlcnJvci5cIlxuICB9LFxuICBcImRyYXdBeGlzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB4IGFuZCB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2hldGhlciB0byBkcmF3IHRoZSBzcGVjaWZpZWQgYXhpcy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIHRoZSB2aXNpYmlsaXR5IG9mIGVhY2ggYXhpcyBzZXBhcmF0ZWx5LiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgYWxzbyBwcmV2ZW50cyBheGlzIHRpY2tzIGZyb20gYmVpbmcgZHJhd24gYW5kIHJlY2xhaW1zIHRoZSBzcGFjZSBmb3IgdGhlIGNoYXJ0IGdyaWQvbGluZXMuXCJcbiAgfSxcbiAgXCJncmlkTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjNcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJUaGlja25lc3MgKGluIHBpeGVscykgb2YgdGhlIGdyaWRsaW5lcyBkcmF3biB1bmRlciB0aGUgY2hhcnQuIFRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsIGdyaWRsaW5lcyBjYW4gYmUgdHVybmVkIG9mZiBlbnRpcmVseSBieSB1c2luZyB0aGUgZHJhd0dyaWQgb3B0aW9uLiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgZWFjaCBheGlzJyBncmlkIHNlcGFyYXRlbHkuXCJcbiAgfSxcbiAgXCJheGlzTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjNcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIlRoaWNrbmVzcyAoaW4gcGl4ZWxzKSBvZiB0aGUgeC0gYW5kIHktYXhpcyBsaW5lcy5cIlxuICB9LFxuICBcImF4aXNMaW5lQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImJsYWNrXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiQ29sb3Igb2YgdGhlIHgtIGFuZCB5LWF4aXMgbGluZXMuIEFjY2VwdHMgYW55IHZhbHVlIHdoaWNoIHRoZSBIVE1MIGNhbnZhcyBzdHJva2VTdHlsZSBhdHRyaWJ1dGUgdW5kZXJzdGFuZHMsIGUuZy4gJ2JsYWNrJyBvciAncmdiKDAsIDEwMCwgMjU1KScuXCJcbiAgfSxcbiAgXCJmaWxsQWxwaGFcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjAuMTVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJFcnJvciBCYXJzXCIsIFwiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJFcnJvciBiYXJzIChvciBjdXN0b20gYmFycykgZm9yIGVhY2ggc2VyaWVzIGFyZSBkcmF3biBpbiB0aGUgc2FtZSBjb2xvciBhcyB0aGUgc2VyaWVzLCBidXQgd2l0aCBwYXJ0aWFsIHRyYW5zcGFyZW5jeS4gVGhpcyBzZXRzIHRoZSB0cmFuc3BhcmVuY3kuIEEgdmFsdWUgb2YgMC4wIG1lYW5zIHRoYXQgdGhlIGVycm9yIGJhcnMgd2lsbCBub3QgYmUgZHJhd24sIHdoZXJlYXMgYSB2YWx1ZSBvZiAxLjAgbWVhbnMgdGhhdCB0aGUgZXJyb3IgYmFycyB3aWxsIGJlIGFzIGRhcmsgYXMgdGhlIGxpbmUgZm9yIHRoZSBzZXJpZXMgaXRzZWxmLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb2R1Y2UgY2hhcnQgbGluZXMgd2hvc2UgdGhpY2tuZXNzIHZhcmllcyBhdCBlYWNoIHBvaW50LlwiXG4gIH0sXG4gIFwiYXhpc0xhYmVsV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjUwICh5LWF4aXMpLCA2MCAoeC1heGlzKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiLCBcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJXaWR0aCAoaW4gcGl4ZWxzKSBvZiB0aGUgY29udGFpbmluZyBkaXZzIGZvciB4LSBhbmQgeS1heGlzIGxhYmVscy4gRm9yIHRoZSB5LWF4aXMsIHRoaXMgYWxzbyBjb250cm9scyB0aGUgd2lkdGggb2YgdGhlIHktYXhpcy4gTm90ZSB0aGF0IGZvciB0aGUgeC1heGlzLCB0aGlzIGlzIGluZGVwZW5kZW50IGZyb20gcGl4ZWxzUGVyTGFiZWwsIHdoaWNoIGNvbnRyb2xzIHRoZSBzcGFjaW5nIGJldHdlZW4gbGFiZWxzLlwiXG4gIH0sXG4gIFwic2lnRmlnc1wiIDoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJCeSBkZWZhdWx0LCBkeWdyYXBocyBkaXNwbGF5cyBudW1iZXJzIHdpdGggYSBmaXhlZCBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBJZiB5b3UnZCBwcmVmZXIgdG8gaGF2ZSBhIGZpeGVkIG51bWJlciBvZiBzaWduaWZpY2FudCBmaWd1cmVzLCBzZXQgdGhpcyBvcHRpb24gdG8gdGhhdCBudW1iZXIgb2Ygc2lnIGZpZ3MuIEEgdmFsdWUgb2YgMiwgZm9yIGluc3RhbmNlLCB3b3VsZCBjYXVzZSAxIHRvIGJlIGRpc3BsYXkgYXMgMS4wIGFuZCAxMjM0IHRvIGJlIGRpc3BsYXllZCBhcyAxLjIzZSszLlwiXG4gIH0sXG4gIFwiZGlnaXRzQWZ0ZXJEZWNpbWFsXCIgOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZ1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlVubGVzcyBpdCdzIHJ1biBpbiBzY2llbnRpZmljIG1vZGUgKHNlZSB0aGUgPGNvZGU+c2lnRmlnczwvY29kZT4gb3B0aW9uKSwgZHlncmFwaHMgZGlzcGxheXMgbnVtYmVycyB3aXRoIDxjb2RlPmRpZ2l0c0FmdGVyRGVjaW1hbDwvY29kZT4gZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBUcmFpbGluZyB6ZXJvcyBhcmUgbm90IGRpc3BsYXllZCwgc28gd2l0aCBhIHZhbHVlIG9mIDIgeW91J2xsIGdldCAnMCcsICcwLjEnLCAnMC4xMicsICcxMjMuNDUnIGJ1dCBub3QgJzEyMy40NTYnIChpdCB3aWxsIGJlIHJvdW5kZWQgdG8gJzEyMy40NicpLiBOdW1iZXJzIHdpdGggYWJzb2x1dGUgdmFsdWUgbGVzcyB0aGFuIDAuMV5kaWdpdHNBZnRlckRlY2ltYWwgKGkuZS4gdGhvc2Ugd2hpY2ggd291bGQgc2hvdyB1cCBhcyAnMC4wMCcpIHdpbGwgYmUgZGlzcGxheWVkIGluIHNjaWVudGlmaWMgbm90YXRpb24uXCJcbiAgfSxcbiAgXCJtYXhOdW1iZXJXaWR0aFwiIDoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjZcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIGRpc3BsYXlpbmcgbnVtYmVycyBpbiBub3JtYWwgKG5vdCBzY2llbnRpZmljKSBtb2RlLCBsYXJnZSBudW1iZXJzIHdpbGwgYmUgZGlzcGxheWVkIHdpdGggbWFueSB0cmFpbGluZyB6ZXJvcyAoZS5nLiAxMDAwMDAwMDAgaW5zdGVhZCBvZiAxZTkpLiBUaGlzIGNhbiBsZWFkIHRvIHVud2llbGR5IHktYXhpcyBsYWJlbHMuIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gPGNvZGU+bWF4TnVtYmVyV2lkdGg8L2NvZGU+IGRpZ2l0cyB0byB0aGUgbGVmdCBvZiB0aGUgZGVjaW1hbCBpbiBhIG51bWJlciwgZHlncmFwaHMgd2lsbCBzd2l0Y2ggdG8gc2NpZW50aWZpYyBub3RhdGlvbiwgZXZlbiB3aGVuIG5vdCBvcGVyYXRpbmcgaW4gc2NpZW50aWZpYyBtb2RlLiBJZiB5b3UnZCBsaWtlIHRvIHNlZSBhbGwgdGhvc2UgZGlnaXRzLCBzZXQgdGhpcyB0byBzb21ldGhpbmcgbGFyZ2UsIGxpa2UgMjAgb3IgMzAuXCJcbiAgfSxcbiAgXCJmaWxlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIoc2V0IHdoZW4gY29uc3RydWN0ZWQpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YVwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmcgKFVSTCBvZiBDU1Ygb3IgQ1NWKSwgR1ZpeiBEYXRhVGFibGUgb3IgMkQgQXJyYXlcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0cyB0aGUgZGF0YSBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIGNoYXJ0LiBUaGlzIGNhbiBvbmx5IGJlIHNldCB3aGVuIGNhbGxpbmcgdXBkYXRlT3B0aW9uczsgaXQgY2Fubm90IGJlIHNldCBmcm9tIHRoZSBjb25zdHJ1Y3Rvci4gRm9yIGEgZnVsbCBkZXNjcmlwdGlvbiBvZiB2YWxpZCBkYXRhIGZvcm1hdHMsIHNlZSB0aGUgPGEgaHJlZj0naHR0cDovL2R5Z3JhcGhzLmNvbS9kYXRhLmh0bWwnPkRhdGEgRm9ybWF0czwvYT4gcGFnZS5cIlxuICB9LFxuICBcInRpbWluZ05hbWVcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbIFwiRGVidWdnaW5nXCIsIFwiRGVwcmVjYXRlZFwiIF0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldCB0aGlzIG9wdGlvbiB0byBsb2cgdGltaW5nIGluZm9ybWF0aW9uLiBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiB3aWxsIGJlIGxvZ2dlZCBhbG9uZyB3aXRoIHRoZSB0aW1pbWcsIHNvIHRoYXQgeW91IGNhbiBkaXN0aW5ndWlzaCBtdWx0aXBsZSBkeWdyYXBocyBvbiB0aGUgc2FtZSBwYWdlLlwiXG4gIH0sXG4gIFwic2hvd1JhbmdlU2VsZWN0b3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IG9yIGhpZGUgdGhlIHJhbmdlIHNlbGVjdG9yIHdpZGdldC5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JIZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjQwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQsIGluIHBpeGVscywgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIHdpZGdldC4gVGhpcyBvcHRpb24gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIGF0IER5Z3JhcGggY3JlYXRpb24gdGltZS5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIiM4MDhGQUJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBzdHJva2UgY29sb3IuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IG51bGwgb3IgXFxcIlxcXCIgdG8gdHVybiBvZmYgc3Ryb2tlLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIiNBN0IxQzRcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBmaWxsIGNvbG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBudWxsIG9yIFxcXCJcXFwiIHRvIHR1cm4gb2ZmIGZpbGwuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ3aGl0ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgdG9wIGNvbG9yIGZvciB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90IGZpbGwgY29sb3IgZ3JhZGllbnQuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInJnYmEoMjU1LDEwMCwyMDAsNDIpXFxcIiBvciBcXFwieWVsbG93XFxcIi4gWW91IGNhbiBhbHNvIHNwZWNpZnkgbnVsbCBvciBcXFwiXFxcIiB0byBkaXNhYmxlIHRoZSBncmFkaWVudCBhbmQgZmlsbCB3aXRoIG9uZSBzaW5nbGUgY29sb3IuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJncmF5XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjb2xvciBvZiB0aGUgbGluZXMgYmVsb3cgYW5kIG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC4gVGhpcyBjYW4gYmUgb2YgdGhlIGZvcm0gXFxcIiNBQUJCQ0NcXFwiIG9yIFxcXCJyZ2IoMjU1LDEwMCwyMDApXFxcIiBvciBcXFwieWVsbG93XFxcIi5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBiZWxvdyBhbmQgb24gYm90aCBzaWRlcyBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90LlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RMaW5lV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjEuNVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90IGxpbmUuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJibGFja1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGxpbmVzIGluIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCB0aGUgbGluZXMgaW4gdGhlIGludGVyYWN0aXZlIGxheWVyIG9mIHRoZSByYW5nZSBzZWxlY3Rvci5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JBbHBoYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC42XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRyYW5zcGFyZW5jeSBvZiB0aGUgdmVpbCB0aGF0IGlzIGRyYXduIG92ZXIgdGhlIHVuc2VsZWN0ZWQgcG9ydGlvbnMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC4gQSB2YWx1ZSBvZiAwIHJlcHJlc2VudHMgZnVsbCB0cmFuc3BhcmVuY3kgYW5kIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSBtaW5pIHBsb3Qgd2lsbCBhcHBlYXIgYXMgbm9ybWFsLiBBIHZhbHVlIG9mIDEgcmVwcmVzZW50cyBmdWxsIG9wYWNpdHkgYW5kIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSBtaW5pIHBsb3Qgd2lsbCBiZSBoaWRkZW4uXCJcbiAgfSxcbiAgXCJzaG93SW5SYW5nZVNlbGVjdG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJNYXJrIHRoaXMgc2VyaWVzIGZvciBpbmNsdXNpb24gaW4gdGhlIHJhbmdlIHNlbGVjdG9yLiBUaGUgbWluaSBwbG90IGN1cnZlIHdpbGwgYmUgYW4gYXZlcmFnZSBvZiBhbGwgc3VjaCBzZXJpZXMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBmb3IgYW55IHNlcmllcywgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gYXZlcmFnZSBhbGwgdGhlIHZpc2libGUgc2VyaWVzLiBTZXR0aW5nIGl0IGZvciBvbmUgc2VyaWVzIHdpbGwgcmVzdWx0IGluIHRoYXQgc2VyaWVzIGJlaW5nIGNoYXJ0ZWQgYWxvbmUgaW4gdGhlIHJhbmdlIHNlbGVjdG9yLiBPbmNlIGl0J3Mgc2V0IGZvciBhIHNpbmdsZSBzZXJpZXMsIGl0IG5lZWRzIHRvIGJlIHNldCBmb3IgYWxsIHNlcmllcyB3aGljaCBzaG91bGQgYmUgaW5jbHVkZWQgKHJlZ2FyZGxlc3Mgb2YgdmlzaWJpbGl0eSkuXCJcbiAgfSxcbiAgXCJhbmltYXRlZFpvb21zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRoaXMgb3B0aW9uIHRvIGFuaW1hdGUgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiB6b29tIHdpbmRvd3MuIEFwcGxpZXMgdG8gcHJvZ3JhbW1hdGljIGFuZCBpbnRlcmFjdGl2ZSB6b29tcy4gTm90ZSB0aGF0IGlmIHlvdSBhbHNvIHNldCBhIGRyYXdDYWxsYmFjaywgaXQgd2lsbCBiZSBjYWxsZWQgc2V2ZXJhbCB0aW1lcyBvbiBlYWNoIHpvb20uIElmIHlvdSBzZXQgYSB6b29tQ2FsbGJhY2ssIGl0IHdpbGwgb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cIlxuICB9LFxuICBcInBsb3R0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIltEeWdyYXBoQ2FudmFzUmVuZGVyZXIuUGxvdHRlcnMuZmlsbFBsb3R0ZXIsIER5Z3JhcGhDYW52YXNSZW5kZXJlci5QbG90dGVycy5lcnJvclBsb3R0ZXIsIER5Z3JhcGhDYW52YXNSZW5kZXJlci5QbG90dGVycy5saW5lUGxvdHRlcl1cIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheSBvciBmdW5jdGlvblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGZ1bmN0aW9uIChvciBhcnJheSBvZiBmdW5jdGlvbnMpIHdoaWNoIHBsb3QgZWFjaCBkYXRhIHNlcmllcyBvbiB0aGUgY2hhcnQuIFRPRE8oZGFudmspOiBtb3JlIGRldGFpbHMhIE1heSBiZSBzZXQgcGVyLXNlcmllcy5cIlxuICB9LFxuICBcImF4ZXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDb25maWd1cmF0aW9uXCJdLFxuICAgIFwidHlwZVwiOiBcIk9iamVjdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZWZpbmVzIHBlci1heGlzIG9wdGlvbnMuIFZhbGlkIGtleXMgYXJlICd4JywgJ3knIGFuZCAneTInLiBPbmx5IHNvbWUgb3B0aW9ucyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMuIElmIGFuIG9wdGlvbiBtYXkgYmUgc2V0IGluIHRoaXMgd2F5LCBpdCB3aWxsIGJlIG5vdGVkIG9uIHRoaXMgcGFnZS4gU2VlIGFsc28gZG9jdW1lbnRhdGlvbiBvbiA8YSBocmVmPSdodHRwOi8vZHlncmFwaHMuY29tL3Blci1heGlzLmh0bWwnPnBlci1zZXJpZXMgYW5kIHBlci1heGlzIG9wdGlvbnM8L2E+LlwiXG4gIH0sXG4gIFwic2VyaWVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiU2VyaWVzXCJdLFxuICAgIFwidHlwZVwiOiBcIk9iamVjdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZWZpbmVzIHBlci1zZXJpZXMgb3B0aW9ucy4gSXRzIGtleXMgbWF0Y2ggdGhlIHktYXhpcyBsYWJlbCBuYW1lcywgYW5kIHRoZSB2YWx1ZXMgYXJlIGRpY3Rpb25hcmllcyB0aGVtc2VsdmVzIHRoYXQgY29udGFpbiBvcHRpb25zIHNwZWNpZmljIHRvIHRoYXQgc2VyaWVzLlwiXG4gIH0sXG4gIFwicGx1Z2luc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiW11cIixcbiAgICBcImxhYmVsc1wiOiBbXCJDb25maWd1cmF0aW9uXCJdLFxuICAgIFwidHlwZVwiOiBcIkFycmF5PHBsdWdpbj5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVmaW5lcyBwZXItZ3JhcGggcGx1Z2lucy4gVXNlZnVsIGZvciBwZXItZ3JhcGggY3VzdG9taXphdGlvblwiXG4gIH0sXG4gIFwiZGF0YUhhbmRsZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihkZXBlbmRzIG9uIGRhdGEpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YVwiXSxcbiAgICBcInR5cGVcIjogXCJEeWdyYXBoLkRhdGFIYW5kbGVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkN1c3RvbSBEYXRhSGFuZGxlci4gVGhpcyBpcyBhbiBhZHZhbmNlZCBjdXN0b21pemF0aW9uLiBTZWUgaHR0cDovL2JpdC5seS8xNTFFN0FxLlwiXG4gIH1cbn1cbjsgIC8vIDwvSlNPTj5cbi8vIE5PVEU6IGluIGFkZGl0aW9uIHRvIHBhcnNpbmcgYXMgSlMsIHRoaXMgc25pcHBldCBpcyBleHBlY3RlZCB0byBiZSB2YWxpZFxuLy8gSlNPTi4gVGhpcyBhc3N1bXB0aW9uIGNhbm5vdCBiZSBjaGVja2VkIGluIEpTLCBidXQgaXQgd2lsbCBiZSBjaGVja2VkIHdoZW5cbi8vIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkIGJ5IHRoZSBnZW5lcmF0ZS1kb2N1bWVudGF0aW9uLnB5IHNjcmlwdC4gRm9yIHRoZVxuLy8gbW9zdCBwYXJ0LCB0aGlzIGp1c3QgbWVhbnMgdGhhdCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgZG91YmxlIHF1b3Rlcy5cblxuLy8gRG8gYSBxdWljayBzYW5pdHkgY2hlY2sgb24gdGhlIG9wdGlvbnMgcmVmZXJlbmNlLlxudmFyIHdhcm4gPSBmdW5jdGlvbihtc2cpIHsgaWYgKHdpbmRvdy5jb25zb2xlKSB3aW5kb3cuY29uc29sZS53YXJuKG1zZyk7IH07XG52YXIgZmxkcyA9IFsndHlwZScsICdkZWZhdWx0JywgJ2Rlc2NyaXB0aW9uJ107XG52YXIgdmFsaWRfY2F0cyA9IFtcbiAnQW5ub3RhdGlvbnMnLFxuICdBeGlzIGRpc3BsYXknLFxuICdDaGFydCBsYWJlbHMnLFxuICdDU1YgcGFyc2luZycsXG4gJ0NhbGxiYWNrcycsXG4gJ0RhdGEnLFxuICdEYXRhIExpbmUgZGlzcGxheScsXG4gJ0RhdGEgU2VyaWVzIENvbG9ycycsXG4gJ0Vycm9yIEJhcnMnLFxuICdHcmlkJyxcbiAnSW50ZXJhY3RpdmUgRWxlbWVudHMnLFxuICdSYW5nZSBTZWxlY3RvcicsXG4gJ0xlZ2VuZCcsXG4gJ092ZXJhbGwgZGlzcGxheScsXG4gJ1JvbGxpbmcgQXZlcmFnZXMnLFxuICdTZXJpZXMnLFxuICdWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmcnLFxuICdab29taW5nJyxcbiAnRGVidWdnaW5nJyxcbiAnQ29uZmlndXJhdGlvbicsXG4gJ0RlcHJlY2F0ZWQnXG5dO1xudmFyIGk7XG52YXIgY2F0cyA9IHt9O1xuZm9yIChpID0gMDsgaSA8IHZhbGlkX2NhdHMubGVuZ3RoOyBpKyspIGNhdHNbdmFsaWRfY2F0c1tpXV0gPSB0cnVlO1xuXG5mb3IgKHZhciBrIGluIE9QVElPTlNfUkVGRVJFTkNFKSB7XG4gIGlmICghT1BUSU9OU19SRUZFUkVOQ0UuaGFzT3duUHJvcGVydHkoaykpIGNvbnRpbnVlO1xuICB2YXIgb3AgPSBPUFRJT05TX1JFRkVSRU5DRVtrXTtcbiAgZm9yIChpID0gMDsgaSA8IGZsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW9wLmhhc093blByb3BlcnR5KGZsZHNbaV0pKSB7XG4gICAgICB3YXJuKCdPcHRpb24gJyArIGsgKyAnIG1pc3NpbmcgXCInICsgZmxkc1tpXSArICdcIiBwcm9wZXJ0eScpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKG9wW2ZsZHNbaV1dKSAhPSAnc3RyaW5nJykge1xuICAgICAgd2FybihrICsgJy4nICsgZmxkc1tpXSArICcgbXVzdCBiZSBvZiB0eXBlIHN0cmluZycpO1xuICAgIH1cbiAgfVxuICB2YXIgbGFiZWxzID0gb3AubGFiZWxzO1xuICBpZiAodHlwZW9mKGxhYmVscykgIT09ICdvYmplY3QnKSB7XG4gICAgd2FybignT3B0aW9uIFwiJyArIGsgKyAnXCIgaXMgbWlzc2luZyBhIFwibGFiZWxzXCI6IFsuLi5dIG9wdGlvbicpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY2F0cy5oYXNPd25Qcm9wZXJ0eShsYWJlbHNbaV0pKSB7XG4gICAgICAgIHdhcm4oJ09wdGlvbiBcIicgKyBrICsgJ1wiIGhhcyBsYWJlbCBcIicgKyBsYWJlbHNbaV0gK1xuICAgICAgICAgICAgICdcIiwgd2hpY2ggaXMgaW52YWxpZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxufVxufVxuXG5leHBvcnQgZGVmYXVsdCBPUFRJT05TX1JFRkVSRU5DRTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBdzJCQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var _dygraph_options_reference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DygraphOptions is responsible for parsing and returning\n * information about options.\n */\n\n// TODO: remove this jshint directive & fix the warnings.\n/*jshint sub:true */\n\n\n\n\n\n\n/*\n * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)\n * global_ - global attributes (common among all graphs, AIUI)\n * user - attributes set by the user\n * series_ - { seriesName -> { idx, yAxis, options }}\n */\n\n/**\n * This parses attributes into an object that can be easily queried.\n *\n * It doesn\'t necessarily mean that all options are available, specifically\n * if labels are not yet available, since those drive details of the per-series\n * and per-axis options.\n *\n * @param {Dygraph} dygraph The chart to which these options belong.\n * @constructor\n */\nvar DygraphOptions = function(dygraph) {\n  /**\n   * The dygraph.\n   * @type {!Dygraph}\n   */\n  this.dygraph_ = dygraph;\n\n  /**\n   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }\n   * @type {Array.<{series : Array.<string>, options : Object}>} @private\n   */\n  this.yAxes_ = [];\n\n  /**\n   * Contains x-axis specific options, which are stored in the options key.\n   * This matches the yAxes_ object structure (by being a dictionary with an\n   * options element) allowing for shared code.\n   * @type {options: Object} @private\n   */\n  this.xAxis_ = {};\n  this.series_ = {};\n\n  // Once these two objects are initialized, you can call get();\n  this.global_ = this.dygraph_.attrs_;\n  this.user_ = this.dygraph_.user_attrs_ || {};\n\n  /**\n   * A list of series in columnar order.\n   * @type {Array.<string>}\n   */\n  this.labels_ = [];\n\n  this.highlightSeries_ = this.get("highlightSeriesOpts") || {};\n  this.reparseSeries();\n};\n\n/**\n * Not optimal, but does the trick when you\'re only using two axes.\n * If we move to more axes, this can just become a function.\n *\n * @type {Object.<number>}\n * @private\n */\nDygraphOptions.AXIS_STRING_MAPPINGS_ = {\n  \'y\' : 0,\n  \'Y\' : 0,\n  \'y1\' : 0,\n  \'Y1\' : 0,\n  \'y2\' : 1,\n  \'Y2\' : 1\n};\n\n/**\n * @param {string|number} axis\n * @private\n */\nDygraphOptions.axisToIndex_ = function(axis) {\n  if (typeof(axis) == "string") {\n    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {\n      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];\n    }\n    throw "Unknown axis : " + axis;\n  }\n  if (typeof(axis) == "number") {\n    if (axis === 0 || axis === 1) {\n      return axis;\n    }\n    throw "Dygraphs only supports two y-axes, indexed from 0-1.";\n  }\n  if (axis) {\n    throw "Unknown axis : " + axis;\n  }\n  // No axis specification means axis 0.\n  return 0;\n};\n\n/**\n * Reparses options that are all related to series. This typically occurs when\n * options are either updated, or source data has been made available.\n *\n * TODO(konigsberg): The method name is kind of weak; fix.\n */\nDygraphOptions.prototype.reparseSeries = function() {\n  var labels = this.get("labels");\n  if (!labels) {\n    return; // -- can\'t do more for now, will parse after getting the labels.\n  }\n\n  this.labels_ = labels.slice(1);\n\n  this.yAxes_ = [ { series : [], options : {}} ]; // Always one axis at least.\n  this.xAxis_ = { options : {} };\n  this.series_ = {};\n\n  // Series are specified in the series element:\n  //\n  // {\n  //   labels: [ "X", "foo", "bar" ],\n  //   pointSize: 3,\n  //   series : {\n  //     foo : {}, // options for foo\n  //     bar : {} // options for bar\n  //   }\n  // }\n  //\n  // So, if series is found, it\'s expected to contain per-series data, otherwise set a\n  // default.\n  var seriesDict = this.user_.series || {};\n  for (var idx = 0; idx < this.labels_.length; idx++) {\n    var seriesName = this.labels_[idx];\n    var optionsForSeries = seriesDict[seriesName] || {};\n    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries["axis"]);\n\n    this.series_[seriesName] = {\n      idx: idx,\n      yAxis: yAxis,\n      options : optionsForSeries };\n\n    if (!this.yAxes_[yAxis]) {\n      this.yAxes_[yAxis] =  { series : [ seriesName ], options : {} };\n    } else {\n      this.yAxes_[yAxis].series.push(seriesName);\n    }\n  }\n\n  var axis_opts = this.user_["axes"] || {};\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ "R"](this.yAxes_[0].options, axis_opts["y"] || {});\n  if (this.yAxes_.length > 1) {\n    _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ "R"](this.yAxes_[1].options, axis_opts["y2"] || {});\n  }\n  _dygraph_utils__WEBPACK_IMPORTED_MODULE_0__[/* update */ "R"](this.xAxis_.options, axis_opts["x"] || {});\n\n  // For "production" code, this gets removed by uglifyjs.\n  if (typeof(process) !== \'undefined\') {\n    if (false) {}\n  }\n};\n\n/**\n * Get a global value.\n *\n * @param {string} name the name of the option.\n */\nDygraphOptions.prototype.get = function(name) {\n  var result = this.getGlobalUser_(name);\n  if (result !== null) {\n    return result;\n  }\n  return this.getGlobalDefault_(name);\n};\n\nDygraphOptions.prototype.getGlobalUser_ = function(name) {\n  if (this.user_.hasOwnProperty(name)) {\n    return this.user_[name];\n  }\n  return null;\n};\n\nDygraphOptions.prototype.getGlobalDefault_ = function(name) {\n  if (this.global_.hasOwnProperty(name)) {\n    return this.global_[name];\n  }\n  if (_dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].hasOwnProperty(name)) {\n    return _dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"][name];\n  }\n  return null;\n};\n\n/**\n * Get a value for a specific axis. If there is no specific value for the axis,\n * the global value is returned.\n *\n * @param {string} name the name of the option.\n * @param {string|number} axis the axis to search. Can be the string representation\n * ("y", "y2") or the axis number (0, 1).\n */\nDygraphOptions.prototype.getForAxis = function(name, axis) {\n  var axisIdx;\n  var axisString;\n\n  // Since axis can be a number or a string, straighten everything out here.\n  if (typeof(axis) == \'number\') {\n    axisIdx = axis;\n    axisString = axisIdx === 0 ? "y" : "y2";\n  } else {\n    if (axis == "y1") { axis = "y"; } // Standardize on \'y\'. Is this bad? I think so.\n    if (axis == "y") {\n      axisIdx = 0;\n    } else if (axis == "y2") {\n      axisIdx = 1;\n    } else if (axis == "x") {\n      axisIdx = -1; // simply a placeholder for below.\n    } else {\n      throw "Unknown axis " + axis;\n    }\n    axisString = axis;\n  }\n\n  var userAxis = (axisIdx == -1) ? this.xAxis_ : this.yAxes_[axisIdx];\n\n  // Search the user-specified axis option first.\n  if (userAxis) { // This condition could be removed if we always set up this.yAxes_ for y2.\n    var axisOptions = userAxis.options;\n    if (axisOptions.hasOwnProperty(name)) {\n      return axisOptions[name];\n    }\n  }\n\n  // User-specified global options second.\n  // But, hack, ignore globally-specified \'logscale\' for \'x\' axis declaration.\n  if (!(axis === \'x\' && name === \'logscale\')) {\n    var result = this.getGlobalUser_(name);\n    if (result !== null) {\n      return result;\n    }\n  }\n  // Default axis options third.\n  var defaultAxisOptions = _dygraph_default_attrs__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].axes[axisString];\n  if (defaultAxisOptions.hasOwnProperty(name)) {\n    return defaultAxisOptions[name];\n  }\n\n  // Default global options last.\n  return this.getGlobalDefault_(name);\n};\n\n/**\n * Get a value for a specific series. If there is no specific value for the series,\n * the value for the axis is returned (and afterwards, the global value.)\n *\n * @param {string} name the name of the option.\n * @param {string} series the series to search.\n */\nDygraphOptions.prototype.getForSeries = function(name, series) {\n  // Honors indexes as series.\n  if (series === this.dygraph_.getHighlightSeries()) {\n    if (this.highlightSeries_.hasOwnProperty(name)) {\n      return this.highlightSeries_[name];\n    }\n  }\n\n  if (!this.series_.hasOwnProperty(series)) {\n    throw "Unknown series: " + series;\n  }\n\n  var seriesObj = this.series_[series];\n  var seriesOptions = seriesObj["options"];\n  if (seriesOptions.hasOwnProperty(name)) {\n    return seriesOptions[name];\n  }\n\n  return this.getForAxis(name, seriesObj["yAxis"]);\n};\n\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\nDygraphOptions.prototype.numAxes = function() {\n  return this.yAxes_.length;\n};\n\n/**\n * Return the y-axis for a given series, specified by name.\n */\nDygraphOptions.prototype.axisForSeries = function(series) {\n  return this.series_[series].yAxis;\n};\n\n/**\n * Returns the options for the specified axis.\n */\n// TODO(konigsberg): this is y-axis specific. Support the x axis.\nDygraphOptions.prototype.axisOptions = function(yAxis) {\n  return this.yAxes_[yAxis].options;\n};\n\n/**\n * Return the series associated with an axis.\n */\nDygraphOptions.prototype.seriesForAxis = function(yAxis) {\n  return this.yAxes_[yAxis].series;\n};\n\n/**\n * Return the list of all series, in their columnar order.\n */\nDygraphOptions.prototype.seriesNames = function() {\n  return this.labels_;\n};\n\n// For "production" code, this gets removed by uglifyjs.\nif (typeof(process) !== \'undefined\') {\nif (false) { var WARNINGS; }\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (DygraphOptions);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2R5Z3JhcGgtb3B0aW9ucy5qcz84NzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IER5Z3JhcGhPcHRpb25zIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGFuZCByZXR1cm5pbmdcbiAqIGluZm9ybWF0aW9uIGFib3V0IG9wdGlvbnMuXG4gKi9cblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMganNoaW50IGRpcmVjdGl2ZSAmIGZpeCB0aGUgd2FybmluZ3MuXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgREVGQVVMVF9BVFRSUyBmcm9tICcuL2R5Z3JhcGgtZGVmYXVsdC1hdHRycyc7XG5pbXBvcnQgT1BUSU9OU19SRUZFUkVOQ0UgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlJztcblxuLypcbiAqIEludGVyZXN0aW5nIG1lbWJlciB2YXJpYWJsZXM6IChSRU1PVklORyBUSElTIExJU1QgQVMgSSBDTE9TVVJJWkUpXG4gKiBnbG9iYWxfIC0gZ2xvYmFsIGF0dHJpYnV0ZXMgKGNvbW1vbiBhbW9uZyBhbGwgZ3JhcGhzLCBBSVVJKVxuICogdXNlciAtIGF0dHJpYnV0ZXMgc2V0IGJ5IHRoZSB1c2VyXG4gKiBzZXJpZXNfIC0geyBzZXJpZXNOYW1lIC0+IHsgaWR4LCB5QXhpcywgb3B0aW9ucyB9fVxuICovXG5cbi8qKlxuICogVGhpcyBwYXJzZXMgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBlYXNpbHkgcXVlcmllZC5cbiAqXG4gKiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlLCBzcGVjaWZpY2FsbHlcbiAqIGlmIGxhYmVscyBhcmUgbm90IHlldCBhdmFpbGFibGUsIHNpbmNlIHRob3NlIGRyaXZlIGRldGFpbHMgb2YgdGhlIHBlci1zZXJpZXNcbiAqIGFuZCBwZXItYXhpcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhlc2Ugb3B0aW9ucyBiZWxvbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhPcHRpb25zID0gZnVuY3Rpb24oZHlncmFwaCkge1xuICAvKipcbiAgICogVGhlIGR5Z3JhcGguXG4gICAqIEB0eXBlIHshRHlncmFwaH1cbiAgICovXG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBheGlzIGluZGV4IHRvIHsgc2VyaWVzIDogWyBzZXJpZXMgbmFtZXMgXSAsIG9wdGlvbnMgOiB7IGF4aXMtc3BlY2lmaWMgb3B0aW9ucy4gfVxuICAgKiBAdHlwZSB7QXJyYXkuPHtzZXJpZXMgOiBBcnJheS48c3RyaW5nPiwgb3B0aW9ucyA6IE9iamVjdH0+fSBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy55QXhlc18gPSBbXTtcblxuICAvKipcbiAgICogQ29udGFpbnMgeC1heGlzIHNwZWNpZmljIG9wdGlvbnMsIHdoaWNoIGFyZSBzdG9yZWQgaW4gdGhlIG9wdGlvbnMga2V5LlxuICAgKiBUaGlzIG1hdGNoZXMgdGhlIHlBeGVzXyBvYmplY3Qgc3RydWN0dXJlIChieSBiZWluZyBhIGRpY3Rpb25hcnkgd2l0aCBhblxuICAgKiBvcHRpb25zIGVsZW1lbnQpIGFsbG93aW5nIGZvciBzaGFyZWQgY29kZS5cbiAgICogQHR5cGUge29wdGlvbnM6IE9iamVjdH0gQHByaXZhdGVcbiAgICovXG4gIHRoaXMueEF4aXNfID0ge307XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIE9uY2UgdGhlc2UgdHdvIG9iamVjdHMgYXJlIGluaXRpYWxpemVkLCB5b3UgY2FuIGNhbGwgZ2V0KCk7XG4gIHRoaXMuZ2xvYmFsXyA9IHRoaXMuZHlncmFwaF8uYXR0cnNfO1xuICB0aGlzLnVzZXJfID0gdGhpcy5keWdyYXBoXy51c2VyX2F0dHJzXyB8fCB7fTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHNlcmllcyBpbiBjb2x1bW5hciBvcmRlci5cbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgdGhpcy5sYWJlbHNfID0gW107XG5cbiAgdGhpcy5oaWdobGlnaHRTZXJpZXNfID0gdGhpcy5nZXQoXCJoaWdobGlnaHRTZXJpZXNPcHRzXCIpIHx8IHt9O1xuICB0aGlzLnJlcGFyc2VTZXJpZXMoKTtcbn07XG5cbi8qKlxuICogTm90IG9wdGltYWwsIGJ1dCBkb2VzIHRoZSB0cmljayB3aGVuIHlvdSdyZSBvbmx5IHVzaW5nIHR3byBheGVzLlxuICogSWYgd2UgbW92ZSB0byBtb3JlIGF4ZXMsIHRoaXMgY2FuIGp1c3QgYmVjb21lIGEgZnVuY3Rpb24uXG4gKlxuICogQHR5cGUge09iamVjdC48bnVtYmVyPn1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhPcHRpb25zLkFYSVNfU1RSSU5HX01BUFBJTkdTXyA9IHtcbiAgJ3knIDogMCxcbiAgJ1knIDogMCxcbiAgJ3kxJyA6IDAsXG4gICdZMScgOiAwLFxuICAneTInIDogMSxcbiAgJ1kyJyA6IDFcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBheGlzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoT3B0aW9ucy5heGlzVG9JbmRleF8gPSBmdW5jdGlvbihheGlzKSB7XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU18uaGFzT3duUHJvcGVydHkoYXhpcykpIHtcbiAgICAgIHJldHVybiBEeWdyYXBoT3B0aW9ucy5BWElTX1NUUklOR19NQVBQSU5HU19bYXhpc107XG4gICAgfVxuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIGlmICh0eXBlb2YoYXhpcykgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChheGlzID09PSAwIHx8IGF4aXMgPT09IDEpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgICB0aHJvdyBcIkR5Z3JhcGhzIG9ubHkgc3VwcG9ydHMgdHdvIHktYXhlcywgaW5kZXhlZCBmcm9tIDAtMS5cIjtcbiAgfVxuICBpZiAoYXhpcykge1xuICAgIHRocm93IFwiVW5rbm93biBheGlzIDogXCIgKyBheGlzO1xuICB9XG4gIC8vIE5vIGF4aXMgc3BlY2lmaWNhdGlvbiBtZWFucyBheGlzIDAuXG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBSZXBhcnNlcyBvcHRpb25zIHRoYXQgYXJlIGFsbCByZWxhdGVkIHRvIHNlcmllcy4gVGhpcyB0eXBpY2FsbHkgb2NjdXJzIHdoZW5cbiAqIG9wdGlvbnMgYXJlIGVpdGhlciB1cGRhdGVkLCBvciBzb3VyY2UgZGF0YSBoYXMgYmVlbiBtYWRlIGF2YWlsYWJsZS5cbiAqXG4gKiBUT0RPKGtvbmlnc2JlcmcpOiBUaGUgbWV0aG9kIG5hbWUgaXMga2luZCBvZiB3ZWFrOyBmaXguXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5yZXBhcnNlU2VyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldChcImxhYmVsc1wiKTtcbiAgaWYgKCFsYWJlbHMpIHtcbiAgICByZXR1cm47IC8vIC0tIGNhbid0IGRvIG1vcmUgZm9yIG5vdywgd2lsbCBwYXJzZSBhZnRlciBnZXR0aW5nIHRoZSBsYWJlbHMuXG4gIH1cblxuICB0aGlzLmxhYmVsc18gPSBsYWJlbHMuc2xpY2UoMSk7XG5cbiAgdGhpcy55QXhlc18gPSBbIHsgc2VyaWVzIDogW10sIG9wdGlvbnMgOiB7fX0gXTsgLy8gQWx3YXlzIG9uZSBheGlzIGF0IGxlYXN0LlxuICB0aGlzLnhBeGlzXyA9IHsgb3B0aW9ucyA6IHt9IH07XG4gIHRoaXMuc2VyaWVzXyA9IHt9O1xuXG4gIC8vIFNlcmllcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBzZXJpZXMgZWxlbWVudDpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIGxhYmVsczogWyBcIlhcIiwgXCJmb29cIiwgXCJiYXJcIiBdLFxuICAvLyAgIHBvaW50U2l6ZTogMyxcbiAgLy8gICBzZXJpZXMgOiB7XG4gIC8vICAgICBmb28gOiB7fSwgLy8gb3B0aW9ucyBmb3IgZm9vXG4gIC8vICAgICBiYXIgOiB7fSAvLyBvcHRpb25zIGZvciBiYXJcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy8gU28sIGlmIHNlcmllcyBpcyBmb3VuZCwgaXQncyBleHBlY3RlZCB0byBjb250YWluIHBlci1zZXJpZXMgZGF0YSwgb3RoZXJ3aXNlIHNldCBhXG4gIC8vIGRlZmF1bHQuXG4gIHZhciBzZXJpZXNEaWN0ID0gdGhpcy51c2VyXy5zZXJpZXMgfHwge307XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMubGFiZWxzXy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmxhYmVsc19baWR4XTtcbiAgICB2YXIgb3B0aW9uc0ZvclNlcmllcyA9IHNlcmllc0RpY3Rbc2VyaWVzTmFtZV0gfHwge307XG4gICAgdmFyIHlBeGlzID0gRHlncmFwaE9wdGlvbnMuYXhpc1RvSW5kZXhfKG9wdGlvbnNGb3JTZXJpZXNbXCJheGlzXCJdKTtcblxuICAgIHRoaXMuc2VyaWVzX1tzZXJpZXNOYW1lXSA9IHtcbiAgICAgIGlkeDogaWR4LFxuICAgICAgeUF4aXM6IHlBeGlzLFxuICAgICAgb3B0aW9ucyA6IG9wdGlvbnNGb3JTZXJpZXMgfTtcblxuICAgIGlmICghdGhpcy55QXhlc19beUF4aXNdKSB7XG4gICAgICB0aGlzLnlBeGVzX1t5QXhpc10gPSAgeyBzZXJpZXMgOiBbIHNlcmllc05hbWUgXSwgb3B0aW9ucyA6IHt9IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXMucHVzaChzZXJpZXNOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXhpc19vcHRzID0gdGhpcy51c2VyX1tcImF4ZXNcIl0gfHwge307XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnlBeGVzX1swXS5vcHRpb25zLCBheGlzX29wdHNbXCJ5XCJdIHx8IHt9KTtcbiAgaWYgKHRoaXMueUF4ZXNfLmxlbmd0aCA+IDEpIHtcbiAgICB1dGlscy51cGRhdGUodGhpcy55QXhlc19bMV0ub3B0aW9ucywgYXhpc19vcHRzW1wieTJcIl0gfHwge30pO1xuICB9XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnhBeGlzXy5vcHRpb25zLCBheGlzX29wdHNbXCJ4XCJdIHx8IHt9KTtcblxuICAvLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG4gIGlmICh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy52YWxpZGF0ZU9wdGlvbnNfKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxVc2VyXyhuYW1lKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsVXNlcl8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLnVzZXJfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcl9bbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsRGVmYXVsdF8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLmdsb2JhbF8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfW25hbWVdO1xuICB9XG4gIGlmIChERUZBVUxUX0FUVFJTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQVRUUlNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIGF4aXMuIElmIHRoZXJlIGlzIG5vIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgYXhpcyxcbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXhpcyB0aGUgYXhpcyB0byBzZWFyY2guIENhbiBiZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ5XCIsIFwieTJcIikgb3IgdGhlIGF4aXMgbnVtYmVyICgwLCAxKS5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLmdldEZvckF4aXMgPSBmdW5jdGlvbihuYW1lLCBheGlzKSB7XG4gIHZhciBheGlzSWR4O1xuICB2YXIgYXhpc1N0cmluZztcblxuICAvLyBTaW5jZSBheGlzIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZywgc3RyYWlnaHRlbiBldmVyeXRoaW5nIG91dCBoZXJlLlxuICBpZiAodHlwZW9mKGF4aXMpID09ICdudW1iZXInKSB7XG4gICAgYXhpc0lkeCA9IGF4aXM7XG4gICAgYXhpc1N0cmluZyA9IGF4aXNJZHggPT09IDAgPyBcInlcIiA6IFwieTJcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXhpcyA9PSBcInkxXCIpIHsgYXhpcyA9IFwieVwiOyB9IC8vIFN0YW5kYXJkaXplIG9uICd5Jy4gSXMgdGhpcyBiYWQ/IEkgdGhpbmsgc28uXG4gICAgaWYgKGF4aXMgPT0gXCJ5XCIpIHtcbiAgICAgIGF4aXNJZHggPSAwO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInkyXCIpIHtcbiAgICAgIGF4aXNJZHggPSAxO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInhcIikge1xuICAgICAgYXhpc0lkeCA9IC0xOyAvLyBzaW1wbHkgYSBwbGFjZWhvbGRlciBmb3IgYmVsb3cuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVW5rbm93biBheGlzIFwiICsgYXhpcztcbiAgICB9XG4gICAgYXhpc1N0cmluZyA9IGF4aXM7XG4gIH1cblxuICB2YXIgdXNlckF4aXMgPSAoYXhpc0lkeCA9PSAtMSkgPyB0aGlzLnhBeGlzXyA6IHRoaXMueUF4ZXNfW2F4aXNJZHhdO1xuXG4gIC8vIFNlYXJjaCB0aGUgdXNlci1zcGVjaWZpZWQgYXhpcyBvcHRpb24gZmlyc3QuXG4gIGlmICh1c2VyQXhpcykgeyAvLyBUaGlzIGNvbmRpdGlvbiBjb3VsZCBiZSByZW1vdmVkIGlmIHdlIGFsd2F5cyBzZXQgdXAgdGhpcy55QXhlc18gZm9yIHkyLlxuICAgIHZhciBheGlzT3B0aW9ucyA9IHVzZXJBeGlzLm9wdGlvbnM7XG4gICAgaWYgKGF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1zcGVjaWZpZWQgZ2xvYmFsIG9wdGlvbnMgc2Vjb25kLlxuICAvLyBCdXQsIGhhY2ssIGlnbm9yZSBnbG9iYWxseS1zcGVjaWZpZWQgJ2xvZ3NjYWxlJyBmb3IgJ3gnIGF4aXMgZGVjbGFyYXRpb24uXG4gIGlmICghKGF4aXMgPT09ICd4JyAmJiBuYW1lID09PSAnbG9nc2NhbGUnKSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEdsb2JhbFVzZXJfKG5hbWUpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgYXhpcyBvcHRpb25zIHRoaXJkLlxuICB2YXIgZGVmYXVsdEF4aXNPcHRpb25zID0gREVGQVVMVF9BVFRSUy5heGVzW2F4aXNTdHJpbmddO1xuICBpZiAoZGVmYXVsdEF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRBeGlzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgZ2xvYmFsIG9wdGlvbnMgbGFzdC5cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIHNlcmllcy4gSWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBzZXJpZXMsXG4gKiB0aGUgdmFsdWUgZm9yIHRoZSBheGlzIGlzIHJldHVybmVkIChhbmQgYWZ0ZXJ3YXJkcywgdGhlIGdsb2JhbCB2YWx1ZS4pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgdGhlIHNlcmllcyB0byBzZWFyY2guXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5nZXRGb3JTZXJpZXMgPSBmdW5jdGlvbihuYW1lLCBzZXJpZXMpIHtcbiAgLy8gSG9ub3JzIGluZGV4ZXMgYXMgc2VyaWVzLlxuICBpZiAoc2VyaWVzID09PSB0aGlzLmR5Z3JhcGhfLmdldEhpZ2hsaWdodFNlcmllcygpKSB7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0U2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2VyaWVzX1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuc2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIHNlcmllczogXCIgKyBzZXJpZXM7XG4gIH1cblxuICB2YXIgc2VyaWVzT2JqID0gdGhpcy5zZXJpZXNfW3Nlcmllc107XG4gIHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzT2JqW1wib3B0aW9uc1wiXTtcbiAgaWYgKHNlcmllc09wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gc2VyaWVzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldEZvckF4aXMobmFtZSwgc2VyaWVzT2JqW1wieUF4aXNcIl0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgeS1heGVzIG9uIHRoZSBjaGFydC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBheGVzLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55QXhlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHktYXhpcyBmb3IgYSBnaXZlbiBzZXJpZXMsIHNwZWNpZmllZCBieSBuYW1lLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuYXhpc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICByZXR1cm4gdGhpcy5zZXJpZXNfW3Nlcmllc10ueUF4aXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAqL1xuLy8gVE9ETyhrb25pZ3NiZXJnKTogdGhpcyBpcyB5LWF4aXMgc3BlY2lmaWMuIFN1cHBvcnQgdGhlIHggYXhpcy5cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5heGlzT3B0aW9ucyA9IGZ1bmN0aW9uKHlBeGlzKSB7XG4gIHJldHVybiB0aGlzLnlBeGVzX1t5QXhpc10ub3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzZXJpZXMgYXNzb2NpYXRlZCB3aXRoIGFuIGF4aXMuXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5zZXJpZXNGb3JBeGlzID0gZnVuY3Rpb24oeUF4aXMpIHtcbiAgcmV0dXJuIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2VyaWVzLCBpbiB0aGVpciBjb2x1bW5hciBvcmRlci5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnNlcmllc05hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxhYmVsc187XG59O1xuXG4vLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG5pZiAodHlwZW9mKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJykge1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuXG4vKipcbiAqIFZhbGlkYXRlIGFsbCBvcHRpb25zLlxuICogVGhpcyByZXF1aXJlcyBPUFRJT05TX1JFRkVSRU5DRSwgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgaW4gZGVidWcgYnVpbGRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnZhbGlkYXRlT3B0aW9uc18gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBPUFRJT05TX1JFRkVSRU5DRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnQ2FsbGVkIHZhbGlkYXRlT3B0aW9uc18gaW4gcHJvZCBidWlsZC4nO1xuICB9XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgdmFsaWRhdGVPcHRpb24gPSBmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgaWYgKCFPUFRJT05TX1JFRkVSRU5DRVtvcHRpb25OYW1lXSkge1xuICAgICAgdGhhdC53YXJuSW52YWxpZE9wdGlvbl8ob3B0aW9uTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvcHRpb25zRGljdHMgPSBbdGhpcy54QXhpc18ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlBeGVzX1swXS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMueUF4ZXNfWzFdICYmIHRoaXMueUF4ZXNfWzFdLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlcl8sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRTZXJpZXNfXTtcbiAgdmFyIG5hbWVzID0gdGhpcy5zZXJpZXNOYW1lcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAodGhpcy5zZXJpZXNfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvcHRpb25zRGljdHMucHVzaCh0aGlzLnNlcmllc19bbmFtZV0ub3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uc0RpY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpY3QgPSBvcHRpb25zRGljdHNbaV07XG4gICAgaWYgKCFkaWN0KSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGRpY3QpIHtcbiAgICAgIGlmIChkaWN0Lmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9uKG9wdGlvbk5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIFdBUk5JTkdTID0ge307ICAvLyBPbmx5IHNob3cgYW55IHBhcnRpY3VsYXIgd2FybmluZyBvbmNlLlxuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGFib3V0IGludmFsaWQgb3B0aW9ucy5cbiAqIFRPRE86IG1ha2UgdGhpcyB0aHJvdyBmb3IgdGVzdGluZ1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLndhcm5JbnZhbGlkT3B0aW9uXyA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgaWYgKCFXQVJOSU5HU1tvcHRpb25OYW1lXSkge1xuICAgIFdBUk5JTkdTW29wdGlvbk5hbWVdID0gdHJ1ZTtcbiAgICB2YXIgaXNTZXJpZXMgPSAodGhpcy5sYWJlbHNfLmluZGV4T2Yob3B0aW9uTmFtZSkgPj0gMCk7XG4gICAgaWYgKGlzU2VyaWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzZSBuZXctc3R5bGUgcGVyLXNlcmllcyBvcHRpb25zIChzYXcgJyArIG9wdGlvbk5hbWUgKyAnIGFzIHRvcC1sZXZlbCBvcHRpb25zIGtleSkuIFNlZSBodHRwOi8vYml0Lmx5LzF0Y2VhSnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIG9wdGlvbiAnICsgb3B0aW9uTmFtZSArICcgKGZ1bGwgbGlzdCBvZiBvcHRpb25zIGF0IGR5Z3JhcGhzLmNvbS9vcHRpb25zLmh0bWwnKTtcbiAgICB9XG4gICAgdGhyb3cgXCJpbnZhbGlkIG9wdGlvbiBcIiArIG9wdGlvbk5hbWU7XG4gIH1cbn07XG5cbi8vIFJlc2V0IGxpc3Qgb2YgcHJldmlvdXNseS1zaG93biB3YXJuaW5ncy4gVXNlZCBmb3IgdGVzdGluZy5cbkR5Z3JhcGhPcHRpb25zLnJlc2V0V2FybmluZ3NfID0gZnVuY3Rpb24oKSB7XG4gIFdBUk5JTkdTID0ge307XG59O1xuXG59XG59XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGhPcHRpb25zO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBb0VBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _dygraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview A wrapper around the Dygraph class which implements the\n * interface for a GViz (aka Google Visualization API) visualization.\n * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,\n * so the documentation at\n * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html\n * translates over directly.\n *\n * For a full demo, see:\n * - http://dygraphs.com/tests/gviz.html\n * - http://dygraphs.com/tests/annotation-gviz.html\n */\n\n/*global Dygraph:false */\n\n\n\n\n/**\n * A wrapper around Dygraph that implements the gviz API.\n * @param {!HTMLDivElement} container The DOM object the visualization should\n *     live in.\n * @constructor\n */\nvar GVizChart = function(container) {\n  this.container = container;\n};\n\n/**\n * @param {GVizDataTable} data\n * @param {Object.<*>} options\n */\nGVizChart.prototype.draw = function(data, options) {\n  // Clear out any existing dygraph.\n  // TODO(danvk): would it make more sense to simply redraw using the current\n  // date_graph object?\n  this.container.innerHTML = '';\n  if (typeof(this.date_graph) != 'undefined') {\n    this.date_graph.destroy();\n  }\n\n  this.date_graph = new _dygraph__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](this.container, data, options);\n};\n\n/**\n * Google charts compatible setSelection\n * Only row selection is supported, all points in the row will be highlighted\n * @param {Array.<{row:number}>} selection_array array of the selected cells\n * @public\n */\nGVizChart.prototype.setSelection = function(selection_array) {\n  var row = false;\n  if (selection_array.length) {\n    row = selection_array[0].row;\n  }\n  this.date_graph.setSelection(row);\n};\n\n/**\n * Google charts compatible getSelection implementation\n * @return {Array.<{row:number,column:number}>} array of the selected cells\n * @public\n */\nGVizChart.prototype.getSelection = function() {\n  var selection = [];\n\n  var row = this.date_graph.getSelection();\n\n  if (row < 0) return selection;\n\n  var points = this.date_graph.layout_.points;\n  for (var setIdx = 0; setIdx < points.length; ++setIdx) {\n    selection.push({row: row, column: setIdx + 1});\n  }\n\n  return selection;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GVizChart);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHlncmFwaHMvc3JjL2R5Z3JhcGgtZ3Zpei5qcz8zNTAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgd3JhcHBlciBhcm91bmQgdGhlIER5Z3JhcGggY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyB0aGVcbiAqIGludGVyZmFjZSBmb3IgYSBHVml6IChha2EgR29vZ2xlIFZpc3VhbGl6YXRpb24gQVBJKSB2aXN1YWxpemF0aW9uLlxuICogSXQgaXMgZGVzaWduZWQgdG8gYmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBHb29nbGUncyBBbm5vdGF0ZWRUaW1lbGluZSxcbiAqIHNvIHRoZSBkb2N1bWVudGF0aW9uIGF0XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL2FwaXMvY2hhcnQvaW50ZXJhY3RpdmUvZG9jcy9nYWxsZXJ5L2Fubm90YXRlZHRpbWVsaW5lLmh0bWxcbiAqIHRyYW5zbGF0ZXMgb3ZlciBkaXJlY3RseS5cbiAqXG4gKiBGb3IgYSBmdWxsIGRlbW8sIHNlZTpcbiAqIC0gaHR0cDovL2R5Z3JhcGhzLmNvbS90ZXN0cy9ndml6Lmh0bWxcbiAqIC0gaHR0cDovL2R5Z3JhcGhzLmNvbS90ZXN0cy9hbm5vdGF0aW9uLWd2aXouaHRtbFxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaCBmcm9tICcuL2R5Z3JhcGgnO1xuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgRHlncmFwaCB0aGF0IGltcGxlbWVudHMgdGhlIGd2aXogQVBJLlxuICogQHBhcmFtIHshSFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG9iamVjdCB0aGUgdmlzdWFsaXphdGlvbiBzaG91bGRcbiAqICAgICBsaXZlIGluLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHVml6Q2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7R1ZpekRhdGFUYWJsZX0gZGF0YVxuICogQHBhcmFtIHtPYmplY3QuPCo+fSBvcHRpb25zXG4gKi9cbkdWaXpDaGFydC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gQ2xlYXIgb3V0IGFueSBleGlzdGluZyBkeWdyYXBoLlxuICAvLyBUT0RPKGRhbnZrKTogd291bGQgaXQgbWFrZSBtb3JlIHNlbnNlIHRvIHNpbXBseSByZWRyYXcgdXNpbmcgdGhlIGN1cnJlbnRcbiAgLy8gZGF0ZV9ncmFwaCBvYmplY3Q/XG4gIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICBpZiAodHlwZW9mKHRoaXMuZGF0ZV9ncmFwaCkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRhdGVfZ3JhcGguZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5kYXRlX2dyYXBoID0gbmV3IER5Z3JhcGgodGhpcy5jb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBHb29nbGUgY2hhcnRzIGNvbXBhdGlibGUgc2V0U2VsZWN0aW9uXG4gKiBPbmx5IHJvdyBzZWxlY3Rpb24gaXMgc3VwcG9ydGVkLCBhbGwgcG9pbnRzIGluIHRoZSByb3cgd2lsbCBiZSBoaWdobGlnaHRlZFxuICogQHBhcmFtIHtBcnJheS48e3JvdzpudW1iZXJ9Pn0gc2VsZWN0aW9uX2FycmF5IGFycmF5IG9mIHRoZSBzZWxlY3RlZCBjZWxsc1xuICogQHB1YmxpY1xuICovXG5HVml6Q2hhcnQucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbl9hcnJheSkge1xuICB2YXIgcm93ID0gZmFsc2U7XG4gIGlmIChzZWxlY3Rpb25fYXJyYXkubGVuZ3RoKSB7XG4gICAgcm93ID0gc2VsZWN0aW9uX2FycmF5WzBdLnJvdztcbiAgfVxuICB0aGlzLmRhdGVfZ3JhcGguc2V0U2VsZWN0aW9uKHJvdyk7XG59O1xuXG4vKipcbiAqIEdvb2dsZSBjaGFydHMgY29tcGF0aWJsZSBnZXRTZWxlY3Rpb24gaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge0FycmF5Ljx7cm93Om51bWJlcixjb2x1bW46bnVtYmVyfT59IGFycmF5IG9mIHRoZSBzZWxlY3RlZCBjZWxsc1xuICogQHB1YmxpY1xuICovXG5HVml6Q2hhcnQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZWN0aW9uID0gW107XG5cbiAgdmFyIHJvdyA9IHRoaXMuZGF0ZV9ncmFwaC5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAocm93IDwgMCkgcmV0dXJuIHNlbGVjdGlvbjtcblxuICB2YXIgcG9pbnRzID0gdGhpcy5kYXRlX2dyYXBoLmxheW91dF8ucG9pbnRzO1xuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCBwb2ludHMubGVuZ3RoOyArK3NldElkeCkge1xuICAgIHNlbGVjdGlvbi5wdXNoKHtyb3c6IHJvdywgY29sdW1uOiBzZXRJZHggKyAxfSk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR1ZpekNoYXJ0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n")},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(26);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(28)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL21haW4uc2Nzcz8yZDg0Il0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS03LTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9tYWluLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTctMSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTctMSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL21haW4uc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(27)(false);\n// Module\nexports.push([module.i, "body {\\n  background: blue; }\\n", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL21haW4uc2Nzcz9iNjRlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBiYWNrZ3JvdW5kOiBibHVlOyB9XFxuXCIsIFwiXCJdKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCJ7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbX2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIihcIi5jb25jYXQoaXRlbVsyXSwgXCIpIGFuZCAoXCIpLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCkuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(29);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === \'function\'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n')},function(module,exports){eval("/*!\n * Bootstrap v4.0.0-alpha.6 (https://getbootstrap.com)\n * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n */\n\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\'s JavaScript.')\n}\n\n+function ($) {\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] >= 4)) {\n    throw new Error('Bootstrap\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0')\n  }\n}(jQuery);\n\n\n+function () {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Util = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n\n  var transition = false;\n\n  var MAX_UID = 1000000;\n\n  var TransitionEndEvent = {\n    WebkitTransition: 'webkitTransitionEnd',\n    MozTransition: 'transitionend',\n    OTransition: 'oTransitionEnd otransitionend',\n    transition: 'transitionend'\n  };\n\n  // shoutout AngusCroll (https://goo.gl/pxwQGp)\n  function toType(obj) {\n    return {}.toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }\n\n  function isElement(obj) {\n    return (obj[0] || obj).nodeType;\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: transition.end,\n      delegateType: transition.end,\n      handle: function handle(event) {\n        if ($(event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n        return undefined;\n      }\n    };\n  }\n\n  function transitionEndTest() {\n    if (window.QUnit) {\n      return false;\n    }\n\n    var el = document.createElement('bootstrap');\n\n    for (var name in TransitionEndEvent) {\n      if (el.style[name] !== undefined) {\n        return {\n          end: TransitionEndEvent[name]\n        };\n      }\n    }\n\n    return false;\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n\n    $(this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    transition = transitionEndTest();\n\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\n\n    if (Util.supportsTransitionEnd()) {\n      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n    }\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n  var Util = {\n\n    TRANSITION_END: 'bsTransitionEnd',\n\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector) {\n        selector = element.getAttribute('href') || '';\n        selector = /^#[a-z]/i.test(selector) ? selector : null;\n      }\n\n      return selector;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $(element).trigger(transition.end);\n    },\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(transition);\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (configTypes.hasOwnProperty(property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + ': ' + ('Option \"' + property + '\" provided type \"' + valueType + '\" ') + ('but expected type \"' + expectedTypes + '\".'));\n          }\n        }\n      }\n    }\n  };\n\n  setTransitionEndSupport();\n\n  return Util;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Alert = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'alert';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.alert';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 150;\n\n  var Selector = {\n    DISMISS: '[data-dismiss=\"alert\"]'\n  };\n\n  var Event = {\n    CLOSE: 'close' + EVENT_KEY,\n    CLOSED: 'closed' + EVENT_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    ALERT: 'alert',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Alert = function () {\n    function Alert(element) {\n      _classCallCheck(this, Alert);\n\n      this._element = element;\n    }\n\n    // getters\n\n    // public\n\n    Alert.prototype.close = function close(element) {\n      element = element || this._element;\n\n      var rootElement = this._getRootElement(element);\n      var customEvent = this._triggerCloseEvent(rootElement);\n\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._removeElement(rootElement);\n    };\n\n    Alert.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    };\n\n    // private\n\n    Alert.prototype._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      if (!parent) {\n        parent = $(element).closest('.' + ClassName.ALERT)[0];\n      }\n\n      return parent;\n    };\n\n    Alert.prototype._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $.Event(Event.CLOSE);\n\n      $(element).trigger(closeEvent);\n      return closeEvent;\n    };\n\n    Alert.prototype._removeElement = function _removeElement(element) {\n      var _this2 = this;\n\n      $(element).removeClass(ClassName.SHOW);\n\n      if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {\n        this._destroyElement(element);\n        return;\n      }\n\n      $(element).one(Util.TRANSITION_END, function (event) {\n        return _this2._destroyElement(element, event);\n      }).emulateTransitionEnd(TRANSITION_DURATION);\n    };\n\n    Alert.prototype._destroyElement = function _destroyElement(element) {\n      $(element).detach().trigger(Event.CLOSED).remove();\n    };\n\n    // static\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $(this);\n        var data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        alertInstance.close(this);\n      };\n    };\n\n    _createClass(Alert, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Alert;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Alert._jQueryInterface;\n  $.fn[NAME].Constructor = Alert;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Alert._jQueryInterface;\n  };\n\n  return Alert;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Button = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'button';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.button';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n\n  var ClassName = {\n    ACTIVE: 'active',\n    BUTTON: 'btn',\n    FOCUS: 'focus'\n  };\n\n  var Selector = {\n    DATA_TOGGLE_CARROT: '[data-toggle^=\"button\"]',\n    DATA_TOGGLE: '[data-toggle=\"buttons\"]',\n    INPUT: 'input',\n    ACTIVE: '.active',\n    BUTTON: '.btn'\n  };\n\n  var Event = {\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\n    FOCUS_BLUR_DATA_API: 'focus' + EVENT_KEY + DATA_API_KEY + ' ' + ('blur' + EVENT_KEY + DATA_API_KEY)\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Button = function () {\n    function Button(element) {\n      _classCallCheck(this, Button);\n\n      this._element = element;\n    }\n\n    // getters\n\n    // public\n\n    Button.prototype.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];\n\n      if (rootElement) {\n        var input = $(this._element).find(Selector.INPUT)[0];\n\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];\n\n              if (activeElement) {\n                $(activeElement).removeClass(ClassName.ACTIVE);\n              }\n            }\n          }\n\n          if (triggerChangeEvent) {\n            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);\n            $(input).trigger('change');\n          }\n\n          input.focus();\n        }\n      }\n\n      this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));\n\n      if (triggerChangeEvent) {\n        $(this._element).toggleClass(ClassName.ACTIVE);\n      }\n    };\n\n    Button.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      this._element = null;\n    };\n\n    // static\n\n    Button._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        if (!data) {\n          data = new Button(this);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Button, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Button;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    event.preventDefault();\n\n    var button = event.target;\n\n    if (!$(button).hasClass(ClassName.BUTTON)) {\n      button = $(button).closest(Selector.BUTTON);\n    }\n\n    Button._jQueryInterface.call($(button), 'toggle');\n  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {\n    var button = $(event.target).closest(Selector.BUTTON)[0];\n    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Button._jQueryInterface;\n  $.fn[NAME].Constructor = Button;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Button._jQueryInterface;\n  };\n\n  return Button;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Carousel = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'carousel';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.carousel';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 600;\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true\n  };\n\n  var DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean'\n  };\n\n  var Direction = {\n    NEXT: 'next',\n    PREV: 'prev',\n    LEFT: 'left',\n    RIGHT: 'right'\n  };\n\n  var Event = {\n    SLIDE: 'slide' + EVENT_KEY,\n    SLID: 'slid' + EVENT_KEY,\n    KEYDOWN: 'keydown' + EVENT_KEY,\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY,\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    CAROUSEL: 'carousel',\n    ACTIVE: 'active',\n    SLIDE: 'slide',\n    RIGHT: 'carousel-item-right',\n    LEFT: 'carousel-item-left',\n    NEXT: 'carousel-item-next',\n    PREV: 'carousel-item-prev',\n    ITEM: 'carousel-item'\n  };\n\n  var Selector = {\n    ACTIVE: '.active',\n    ACTIVE_ITEM: '.active.carousel-item',\n    ITEM: '.carousel-item',\n    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',\n    INDICATORS: '.carousel-indicators',\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\n    DATA_RIDE: '[data-ride=\"carousel\"]'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Carousel = function () {\n    function Carousel(element, config) {\n      _classCallCheck(this, Carousel);\n\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n\n      this._isPaused = false;\n      this._isSliding = false;\n\n      this._config = this._getConfig(config);\n      this._element = $(element)[0];\n      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];\n\n      this._addEventListeners();\n    }\n\n    // getters\n\n    // public\n\n    Carousel.prototype.next = function next() {\n      if (this._isSliding) {\n        throw new Error('Carousel is sliding');\n      }\n      this._slide(Direction.NEXT);\n    };\n\n    Carousel.prototype.nextWhenVisible = function nextWhenVisible() {\n      // Don't call next when the page isn't visible\n      if (!document.hidden) {\n        this.next();\n      }\n    };\n\n    Carousel.prototype.prev = function prev() {\n      if (this._isSliding) {\n        throw new Error('Carousel is sliding');\n      }\n      this._slide(Direction.PREVIOUS);\n    };\n\n    Carousel.prototype.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n\n    Carousel.prototype.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config.interval && !this._isPaused) {\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n\n    Carousel.prototype.to = function to(index) {\n      var _this3 = this;\n\n      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n\n      var activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        $(this._element).one(Event.SLID, function () {\n          return _this3.to(index);\n        });\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREVIOUS;\n\n      this._slide(direction, this._items[index]);\n    };\n\n    Carousel.prototype.dispose = function dispose() {\n      $(this._element).off(EVENT_KEY);\n      $.removeData(this._element, DATA_KEY);\n\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    };\n\n    // private\n\n    Carousel.prototype._getConfig = function _getConfig(config) {\n      config = $.extend({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    Carousel.prototype._addEventListeners = function _addEventListeners() {\n      var _this4 = this;\n\n      if (this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN, function (event) {\n          return _this4._keydown(event);\n        });\n      }\n\n      if (this._config.pause === 'hover' && !('ontouchstart' in document.documentElement)) {\n        $(this._element).on(Event.MOUSEENTER, function (event) {\n          return _this4.pause(event);\n        }).on(Event.MOUSELEAVE, function (event) {\n          return _this4.cycle(event);\n        });\n      }\n    };\n\n    Carousel.prototype._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n        default:\n          return;\n      }\n    };\n\n    Carousel.prototype._getItemIndex = function _getItemIndex(element) {\n      this._items = $.makeArray($(element).parent().find(Selector.ITEM));\n      return this._items.indexOf(element);\n    };\n\n    Carousel.prototype._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === Direction.NEXT;\n      var isPrevDirection = direction === Direction.PREVIOUS;\n      var activeIndex = this._getItemIndex(activeElement);\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      var delta = direction === Direction.PREVIOUS ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n\n    Carousel.prototype._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var slideEvent = $.Event(Event.SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName\n      });\n\n      $(this._element).trigger(slideEvent);\n\n      return slideEvent;\n    };\n\n    Carousel.prototype._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n\n        if (nextIndicator) {\n          $(nextIndicator).addClass(ClassName.ACTIVE);\n        }\n      }\n    };\n\n    Carousel.prototype._slide = function _slide(direction, element) {\n      var _this5 = this;\n\n      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n\n      var isCycling = Boolean(this._interval);\n\n      var directionalClassName = void 0;\n      var orderClassName = void 0;\n      var eventDirectionName = void 0;\n\n      if (direction === Direction.NEXT) {\n        directionalClassName = ClassName.LEFT;\n        orderClassName = ClassName.NEXT;\n        eventDirectionName = Direction.LEFT;\n      } else {\n        directionalClassName = ClassName.RIGHT;\n        orderClassName = ClassName.PREV;\n        eventDirectionName = Direction.RIGHT;\n      }\n\n      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {\n        this._isSliding = false;\n        return;\n      }\n\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      var slidEvent = $.Event(Event.SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName\n      });\n\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {\n\n        $(nextElement).addClass(orderClassName);\n\n        Util.reflow(nextElement);\n\n        $(activeElement).addClass(directionalClassName);\n        $(nextElement).addClass(directionalClassName);\n\n        $(activeElement).one(Util.TRANSITION_END, function () {\n          $(nextElement).removeClass(directionalClassName + ' ' + orderClassName).addClass(ClassName.ACTIVE);\n\n          $(activeElement).removeClass(ClassName.ACTIVE + ' ' + orderClassName + ' ' + directionalClassName);\n\n          _this5._isSliding = false;\n\n          setTimeout(function () {\n            return $(_this5._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(TRANSITION_DURATION);\n      } else {\n        $(activeElement).removeClass(ClassName.ACTIVE);\n        $(nextElement).addClass(ClassName.ACTIVE);\n\n        this._isSliding = false;\n        $(this._element).trigger(slidEvent);\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    };\n\n    // static\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n        var _config = $.extend({}, Default, $(this).data());\n\n        if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {\n          $.extend(_config, config);\n        }\n\n        var action = typeof config === 'string' ? config : _config.slide;\n\n        if (!data) {\n          data = new Carousel(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (data[action] === undefined) {\n            throw new Error('No method named \"' + action + '\"');\n          }\n          data[action]();\n        } else if (_config.interval) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n\n      if (!selector) {\n        return;\n      }\n\n      var target = $(selector)[0];\n\n      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {\n        return;\n      }\n\n      var config = $.extend({}, $(target).data(), $(this).data());\n      var slideIndex = this.getAttribute('data-slide-to');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel._jQueryInterface.call($(target), config);\n\n      if (slideIndex) {\n        $(target).data(DATA_KEY).to(slideIndex);\n      }\n\n      event.preventDefault();\n    };\n\n    _createClass(Carousel, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Carousel;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);\n\n  $(window).on(Event.LOAD_DATA_API, function () {\n    $(Selector.DATA_RIDE).each(function () {\n      var $carousel = $(this);\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    });\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Carousel._jQueryInterface;\n  $.fn[NAME].Constructor = Carousel;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Carousel._jQueryInterface;\n  };\n\n  return Carousel;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Collapse = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'collapse';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.collapse';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 600;\n\n  var Default = {\n    toggle: true,\n    parent: ''\n  };\n\n  var DefaultType = {\n    toggle: 'boolean',\n    parent: 'string'\n  };\n\n  var Event = {\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    SHOW: 'show',\n    COLLAPSE: 'collapse',\n    COLLAPSING: 'collapsing',\n    COLLAPSED: 'collapsed'\n  };\n\n  var Dimension = {\n    WIDTH: 'width',\n    HEIGHT: 'height'\n  };\n\n  var Selector = {\n    ACTIVES: '.card > .show, .card > .collapsing',\n    DATA_TOGGLE: '[data-toggle=\"collapse\"]'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Collapse = function () {\n    function Collapse(element, config) {\n      _classCallCheck(this, Collapse);\n\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = $.makeArray($('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' + ('[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')));\n\n      this._parent = this._config.parent ? this._getParent() : null;\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    }\n\n    // getters\n\n    // public\n\n    Collapse.prototype.toggle = function toggle() {\n      if ($(this._element).hasClass(ClassName.SHOW)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    Collapse.prototype.show = function show() {\n      var _this6 = this;\n\n      if (this._isTransitioning) {\n        throw new Error('Collapse is transitioning');\n      }\n\n      if ($(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var actives = void 0;\n      var activesData = void 0;\n\n      if (this._parent) {\n        actives = $.makeArray($(this._parent).find(Selector.ACTIVES));\n        if (!actives.length) {\n          actives = null;\n        }\n      }\n\n      if (actives) {\n        activesData = $(actives).data(DATA_KEY);\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n\n      var startEvent = $.Event(Event.SHOW);\n      $(this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (actives) {\n        Collapse._jQueryInterface.call($(actives), 'hide');\n        if (!activesData) {\n          $(actives).data(DATA_KEY, null);\n        }\n      }\n\n      var dimension = this._getDimension();\n\n      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\n\n      this._element.style[dimension] = 0;\n      this._element.setAttribute('aria-expanded', true);\n\n      if (this._triggerArray.length) {\n        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        $(_this6._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);\n\n        _this6._element.style[dimension] = '';\n\n        _this6.setTransitioning(false);\n\n        $(_this6._element).trigger(Event.SHOWN);\n      };\n\n      if (!Util.supportsTransitionEnd()) {\n        complete();\n        return;\n      }\n\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = 'scroll' + capitalizedDimension;\n\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\n\n      this._element.style[dimension] = this._element[scrollSize] + 'px';\n    };\n\n    Collapse.prototype.hide = function hide() {\n      var _this7 = this;\n\n      if (this._isTransitioning) {\n        throw new Error('Collapse is transitioning');\n      }\n\n      if (!$(this._element).hasClass(ClassName.SHOW)) {\n        return;\n      }\n\n      var startEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      var dimension = this._getDimension();\n      var offsetDimension = dimension === Dimension.WIDTH ? 'offsetWidth' : 'offsetHeight';\n\n      this._element.style[dimension] = this._element[offsetDimension] + 'px';\n\n      Util.reflow(this._element);\n\n      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);\n\n      this._element.setAttribute('aria-expanded', false);\n\n      if (this._triggerArray.length) {\n        $(this._triggerArray).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        _this7.setTransitioning(false);\n        $(_this7._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\n      };\n\n      this._element.style[dimension] = '';\n\n      if (!Util.supportsTransitionEnd()) {\n        complete();\n        return;\n      }\n\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\n    };\n\n    Collapse.prototype.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n\n    Collapse.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    };\n\n    // private\n\n    Collapse.prototype._getConfig = function _getConfig(config) {\n      config = $.extend({}, Default, config);\n      config.toggle = Boolean(config.toggle); // coerce string values\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    Collapse.prototype._getDimension = function _getDimension() {\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\n    };\n\n    Collapse.prototype._getParent = function _getParent() {\n      var _this8 = this;\n\n      var parent = $(this._config.parent)[0];\n      var selector = '[data-toggle=\"collapse\"][data-parent=\"' + this._config.parent + '\"]';\n\n      $(parent).find(selector).each(function (i, element) {\n        _this8._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n\n      return parent;\n    };\n\n    Collapse.prototype._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      if (element) {\n        var isOpen = $(element).hasClass(ClassName.SHOW);\n        element.setAttribute('aria-expanded', isOpen);\n\n        if (triggerArray.length) {\n          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n        }\n      }\n    };\n\n    // static\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? $(selector)[0] : null;\n    };\n\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n        var _config = $.extend({}, Default, $this.data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\n\n        if (!data && _config.toggle && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n\n        if (!data) {\n          data = new Collapse(this, _config);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Collapse, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Collapse;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n\n    var target = Collapse._getTargetFromElement(this);\n    var data = $(target).data(DATA_KEY);\n    var config = data ? 'toggle' : $(this).data();\n\n    Collapse._jQueryInterface.call($(target), config);\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Collapse._jQueryInterface;\n  $.fn[NAME].Constructor = Collapse;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Collapse._jQueryInterface;\n  };\n\n  return Collapse;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Dropdown = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'dropdown';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.dropdown';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var Event = {\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    CLICK: 'click' + EVENT_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY,\n    FOCUSIN_DATA_API: 'focusin' + EVENT_KEY + DATA_API_KEY,\n    KEYDOWN_DATA_API: 'keydown' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    BACKDROP: 'dropdown-backdrop',\n    DISABLED: 'disabled',\n    SHOW: 'show'\n  };\n\n  var Selector = {\n    BACKDROP: '.dropdown-backdrop',\n    DATA_TOGGLE: '[data-toggle=\"dropdown\"]',\n    FORM_CHILD: '.dropdown form',\n    ROLE_MENU: '[role=\"menu\"]',\n    ROLE_LISTBOX: '[role=\"listbox\"]',\n    NAVBAR_NAV: '.navbar-nav',\n    VISIBLE_ITEMS: '[role=\"menu\"] li:not(.disabled) a, ' + '[role=\"listbox\"] li:not(.disabled) a'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Dropdown = function () {\n    function Dropdown(element) {\n      _classCallCheck(this, Dropdown);\n\n      this._element = element;\n\n      this._addEventListeners();\n    }\n\n    // getters\n\n    // public\n\n    Dropdown.prototype.toggle = function toggle() {\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\n        return false;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n      var isActive = $(parent).hasClass(ClassName.SHOW);\n\n      Dropdown._clearMenus();\n\n      if (isActive) {\n        return false;\n      }\n\n      if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {\n\n        // if mobile we use a backdrop because click events don't delegate\n        var dropdown = document.createElement('div');\n        dropdown.className = ClassName.BACKDROP;\n        $(dropdown).insertBefore(this);\n        $(dropdown).on('click', Dropdown._clearMenus);\n      }\n\n      var relatedTarget = {\n        relatedTarget: this\n      };\n      var showEvent = $.Event(Event.SHOW, relatedTarget);\n\n      $(parent).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return false;\n      }\n\n      this.focus();\n      this.setAttribute('aria-expanded', true);\n\n      $(parent).toggleClass(ClassName.SHOW);\n      $(parent).trigger($.Event(Event.SHOWN, relatedTarget));\n\n      return false;\n    };\n\n    Dropdown.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._element).off(EVENT_KEY);\n      this._element = null;\n    };\n\n    // private\n\n    Dropdown.prototype._addEventListeners = function _addEventListeners() {\n      $(this._element).on(Event.CLICK, this.toggle);\n    };\n\n    // static\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n\n        if (!data) {\n          data = new Dropdown(this);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config].call(this);\n        }\n      });\n    };\n\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && event.which === RIGHT_MOUSE_BUTTON_WHICH) {\n        return;\n      }\n\n      var backdrop = $(Selector.BACKDROP)[0];\n      if (backdrop) {\n        backdrop.parentNode.removeChild(backdrop);\n      }\n\n      var toggles = $.makeArray($(Selector.DATA_TOGGLE));\n\n      for (var i = 0; i < toggles.length; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n\n        if (!$(parent).hasClass(ClassName.SHOW)) {\n          continue;\n        }\n\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'focusin') && $.contains(parent, event.target)) {\n          continue;\n        }\n\n        var hideEvent = $.Event(Event.HIDE, relatedTarget);\n        $(parent).trigger(hideEvent);\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        }\n\n        toggles[i].setAttribute('aria-expanded', 'false');\n\n        $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));\n      }\n    };\n\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent = void 0;\n      var selector = Util.getSelectorFromElement(element);\n\n      if (selector) {\n        parent = $(selector)[0];\n      }\n\n      return parent || element.parentNode;\n    };\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      if (!/(38|40|27|32)/.test(event.which) || /input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n      var isActive = $(parent).hasClass(ClassName.SHOW);\n\n      if (!isActive && event.which !== ESCAPE_KEYCODE || isActive && event.which === ESCAPE_KEYCODE) {\n\n        if (event.which === ESCAPE_KEYCODE) {\n          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];\n          $(toggle).trigger('focus');\n        }\n\n        $(this).trigger('click');\n        return;\n      }\n\n      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();\n\n      if (!items.length) {\n        return;\n      }\n\n      var index = items.indexOf(event.target);\n\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // up\n        index--;\n      }\n\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // down\n        index++;\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      items[index].focus();\n    };\n\n    _createClass(Dropdown, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Dropdown;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_MENU, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.ROLE_LISTBOX, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + ' ' + Event.FOCUSIN_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, Dropdown.prototype.toggle).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Dropdown._jQueryInterface;\n  $.fn[NAME].Constructor = Dropdown;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Dropdown._jQueryInterface;\n  };\n\n  return Dropdown;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Modal = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'modal';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.modal';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 300;\n  var BACKDROP_TRANSITION_DURATION = 150;\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var Default = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n\n  var DefaultType = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n\n  var Event = {\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    FOCUSIN: 'focusin' + EVENT_KEY,\n    RESIZE: 'resize' + EVENT_KEY,\n    CLICK_DISMISS: 'click.dismiss' + EVENT_KEY,\n    KEYDOWN_DISMISS: 'keydown.dismiss' + EVENT_KEY,\n    MOUSEUP_DISMISS: 'mouseup.dismiss' + EVENT_KEY,\n    MOUSEDOWN_DISMISS: 'mousedown.dismiss' + EVENT_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n    BACKDROP: 'modal-backdrop',\n    OPEN: 'modal-open',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n\n  var Selector = {\n    DIALOG: '.modal-dialog',\n    DATA_TOGGLE: '[data-toggle=\"modal\"]',\n    DATA_DISMISS: '[data-dismiss=\"modal\"]',\n    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Modal = function () {\n    function Modal(element, config) {\n      _classCallCheck(this, Modal);\n\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = $(element).find(Selector.DIALOG)[0];\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._isTransitioning = false;\n      this._originalBodyPadding = 0;\n      this._scrollbarWidth = 0;\n    }\n\n    // getters\n\n    // public\n\n    Modal.prototype.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n\n    Modal.prototype.show = function show(relatedTarget) {\n      var _this9 = this;\n\n      if (this._isTransitioning) {\n        throw new Error('Modal is transitioning');\n      }\n\n      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\n        this._isTransitioning = true;\n      }\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: relatedTarget\n      });\n\n      $(this._element).trigger(showEvent);\n\n      if (this._isShown || showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._checkScrollbar();\n      this._setScrollbar();\n\n      $(document.body).addClass(ClassName.OPEN);\n\n      this._setEscapeEvent();\n      this._setResizeEvent();\n\n      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {\n        return _this9.hide(event);\n      });\n\n      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\n        $(_this9._element).one(Event.MOUSEUP_DISMISS, function (event) {\n          if ($(event.target).is(_this9._element)) {\n            _this9._ignoreBackdropClick = true;\n          }\n        });\n      });\n\n      this._showBackdrop(function () {\n        return _this9._showElement(relatedTarget);\n      });\n    };\n\n    Modal.prototype.hide = function hide(event) {\n      var _this10 = this;\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (this._isTransitioning) {\n        throw new Error('Modal is transitioning');\n      }\n\n      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);\n      if (transition) {\n        this._isTransitioning = true;\n      }\n\n      var hideEvent = $.Event(Event.HIDE);\n      $(this._element).trigger(hideEvent);\n\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = false;\n\n      this._setEscapeEvent();\n      this._setResizeEvent();\n\n      $(document).off(Event.FOCUSIN);\n\n      $(this._element).removeClass(ClassName.SHOW);\n\n      $(this._element).off(Event.CLICK_DISMISS);\n      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);\n\n      if (transition) {\n        $(this._element).one(Util.TRANSITION_END, function (event) {\n          return _this10._hideModal(event);\n        }).emulateTransitionEnd(TRANSITION_DURATION);\n      } else {\n        this._hideModal();\n      }\n    };\n\n    Modal.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n\n      $(window, document, this._element, this._backdrop).off(EVENT_KEY);\n\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._originalBodyPadding = null;\n      this._scrollbarWidth = null;\n    };\n\n    // private\n\n    Modal.prototype._getConfig = function _getConfig(config) {\n      config = $.extend({}, Default, config);\n      Util.typeCheckConfig(NAME, config, DefaultType);\n      return config;\n    };\n\n    Modal.prototype._showElement = function _showElement(relatedTarget) {\n      var _this11 = this;\n\n      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);\n\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // don't move modals dom position\n        document.body.appendChild(this._element);\n      }\n\n      this._element.style.display = 'block';\n      this._element.removeAttribute('aria-hidden');\n      this._element.scrollTop = 0;\n\n      if (transition) {\n        Util.reflow(this._element);\n      }\n\n      $(this._element).addClass(ClassName.SHOW);\n\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n\n      var shownEvent = $.Event(Event.SHOWN, {\n        relatedTarget: relatedTarget\n      });\n\n      var transitionComplete = function transitionComplete() {\n        if (_this11._config.focus) {\n          _this11._element.focus();\n        }\n        _this11._isTransitioning = false;\n        $(_this11._element).trigger(shownEvent);\n      };\n\n      if (transition) {\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);\n      } else {\n        transitionComplete();\n      }\n    };\n\n    Modal.prototype._enforceFocus = function _enforceFocus() {\n      var _this12 = this;\n\n      $(document).off(Event.FOCUSIN) // guard against infinite focus loop\n      .on(Event.FOCUSIN, function (event) {\n        if (document !== event.target && _this12._element !== event.target && !$(_this12._element).has(event.target).length) {\n          _this12._element.focus();\n        }\n      });\n    };\n\n    Modal.prototype._setEscapeEvent = function _setEscapeEvent() {\n      var _this13 = this;\n\n      if (this._isShown && this._config.keyboard) {\n        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\n          if (event.which === ESCAPE_KEYCODE) {\n            _this13.hide();\n          }\n        });\n      } else if (!this._isShown) {\n        $(this._element).off(Event.KEYDOWN_DISMISS);\n      }\n    };\n\n    Modal.prototype._setResizeEvent = function _setResizeEvent() {\n      var _this14 = this;\n\n      if (this._isShown) {\n        $(window).on(Event.RESIZE, function (event) {\n          return _this14._handleUpdate(event);\n        });\n      } else {\n        $(window).off(Event.RESIZE);\n      }\n    };\n\n    Modal.prototype._hideModal = function _hideModal() {\n      var _this15 = this;\n\n      this._element.style.display = 'none';\n      this._element.setAttribute('aria-hidden', 'true');\n      this._isTransitioning = false;\n      this._showBackdrop(function () {\n        $(document.body).removeClass(ClassName.OPEN);\n        _this15._resetAdjustments();\n        _this15._resetScrollbar();\n        $(_this15._element).trigger(Event.HIDDEN);\n      });\n    };\n\n    Modal.prototype._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $(this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n\n    Modal.prototype._showBackdrop = function _showBackdrop(callback) {\n      var _this16 = this;\n\n      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\n\n      if (this._isShown && this._config.backdrop) {\n        var doAnimate = Util.supportsTransitionEnd() && animate;\n\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = ClassName.BACKDROP;\n\n        if (animate) {\n          $(this._backdrop).addClass(animate);\n        }\n\n        $(this._backdrop).appendTo(document.body);\n\n        $(this._element).on(Event.CLICK_DISMISS, function (event) {\n          if (_this16._ignoreBackdropClick) {\n            _this16._ignoreBackdropClick = false;\n            return;\n          }\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n          if (_this16._config.backdrop === 'static') {\n            _this16._element.focus();\n          } else {\n            _this16.hide();\n          }\n        });\n\n        if (doAnimate) {\n          Util.reflow(this._backdrop);\n        }\n\n        $(this._backdrop).addClass(ClassName.SHOW);\n\n        if (!callback) {\n          return;\n        }\n\n        if (!doAnimate) {\n          callback();\n          return;\n        }\n\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\n      } else if (!this._isShown && this._backdrop) {\n        $(this._backdrop).removeClass(ClassName.SHOW);\n\n        var callbackRemove = function callbackRemove() {\n          _this16._removeBackdrop();\n          if (callback) {\n            callback();\n          }\n        };\n\n        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    };\n\n    // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n\n    Modal.prototype._handleUpdate = function _handleUpdate() {\n      this._adjustDialog();\n    };\n\n    Modal.prototype._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + 'px';\n      }\n\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + 'px';\n      }\n    };\n\n    Modal.prototype._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n\n    Modal.prototype._checkScrollbar = function _checkScrollbar() {\n      this._isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n\n    Modal.prototype._setScrollbar = function _setScrollbar() {\n      var bodyPadding = parseInt($(Selector.FIXED_CONTENT).css('padding-right') || 0, 10);\n\n      this._originalBodyPadding = document.body.style.paddingRight || '';\n\n      if (this._isBodyOverflowing) {\n        document.body.style.paddingRight = bodyPadding + this._scrollbarWidth + 'px';\n      }\n    };\n\n    Modal.prototype._resetScrollbar = function _resetScrollbar() {\n      document.body.style.paddingRight = this._originalBodyPadding;\n    };\n\n    Modal.prototype._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    };\n\n    // static\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n        var _config = $.extend({}, Modal.Default, $(this).data(), (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config);\n\n        if (!data) {\n          data = new Modal(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n\n    _createClass(Modal, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Modal;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    var _this17 = this;\n\n    var target = void 0;\n    var selector = Util.getSelectorFromElement(this);\n\n    if (selector) {\n      target = $(selector)[0];\n    }\n\n    var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());\n\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n\n    var $target = $(target).one(Event.SHOW, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      $target.one(Event.HIDDEN, function () {\n        if ($(_this17).is(':visible')) {\n          _this17.focus();\n        }\n      });\n    });\n\n    Modal._jQueryInterface.call($(target), config, this);\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Modal._jQueryInterface;\n  $.fn[NAME].Constructor = Modal;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Modal._jQueryInterface;\n  };\n\n  return Modal;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar ScrollSpy = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'scrollspy';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.scrollspy';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n\n  var Default = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n\n  var DefaultType = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n\n  var Event = {\n    ACTIVATE: 'activate' + EVENT_KEY,\n    SCROLL: 'scroll' + EVENT_KEY,\n    LOAD_DATA_API: 'load' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    DROPDOWN_ITEM: 'dropdown-item',\n    DROPDOWN_MENU: 'dropdown-menu',\n    NAV_LINK: 'nav-link',\n    NAV: 'nav',\n    ACTIVE: 'active'\n  };\n\n  var Selector = {\n    DATA_SPY: '[data-spy=\"scroll\"]',\n    ACTIVE: '.active',\n    LIST_ITEM: '.list-item',\n    LI: 'li',\n    LI_DROPDOWN: 'li.dropdown',\n    NAV_LINKS: '.nav-link',\n    DROPDOWN: '.dropdown',\n    DROPDOWN_ITEMS: '.dropdown-item',\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\n  };\n\n  var OffsetMethod = {\n    OFFSET: 'offset',\n    POSITION: 'position'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var ScrollSpy = function () {\n    function ScrollSpy(element, config) {\n      var _this18 = this;\n\n      _classCallCheck(this, ScrollSpy);\n\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + ' ' + Selector.NAV_LINKS + ',' + (this._config.target + ' ' + Selector.DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n\n      $(this._scrollElement).on(Event.SCROLL, function (event) {\n        return _this18._process(event);\n      });\n\n      this.refresh();\n      this._process();\n    }\n\n    // getters\n\n    // public\n\n    ScrollSpy.prototype.refresh = function refresh() {\n      var _this19 = this;\n\n      var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;\n\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\n\n      this._offsets = [];\n      this._targets = [];\n\n      this._scrollHeight = this._getScrollHeight();\n\n      var targets = $.makeArray($(this._selector));\n\n      targets.map(function (element) {\n        var target = void 0;\n        var targetSelector = Util.getSelectorFromElement(element);\n\n        if (targetSelector) {\n          target = $(targetSelector)[0];\n        }\n\n        if (target && (target.offsetWidth || target.offsetHeight)) {\n          // todo (fat): remove sketch reliance on jQuery position/offset\n          return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\n        }\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this19._offsets.push(item[0]);\n        _this19._targets.push(item[1]);\n      });\n    };\n\n    ScrollSpy.prototype.dispose = function dispose() {\n      $.removeData(this._element, DATA_KEY);\n      $(this._scrollElement).off(EVENT_KEY);\n\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    };\n\n    // private\n\n    ScrollSpy.prototype._getConfig = function _getConfig(config) {\n      config = $.extend({}, Default, config);\n\n      if (typeof config.target !== 'string') {\n        var id = $(config.target).attr('id');\n        if (!id) {\n          id = Util.getUID(NAME);\n          $(config.target).attr('id', id);\n        }\n        config.target = '#' + id;\n      }\n\n      Util.typeCheckConfig(NAME, config, DefaultType);\n\n      return config;\n    };\n\n    ScrollSpy.prototype._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n\n    ScrollSpy.prototype._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n\n    ScrollSpy.prototype._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.offsetHeight;\n    };\n\n    ScrollSpy.prototype._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n      var scrollHeight = this._getScrollHeight();\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n        return;\n      }\n\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n        this._clear();\n        return;\n      }\n\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (this._offsets[i + 1] === undefined || scrollTop < this._offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n\n    ScrollSpy.prototype._activate = function _activate(target) {\n      this._activeTarget = target;\n\n      this._clear();\n\n      var queries = this._selector.split(',');\n      queries = queries.map(function (selector) {\n        return selector + '[data-target=\"' + target + '\"],' + (selector + '[href=\"' + target + '\"]');\n      });\n\n      var $link = $(queries.join(','));\n\n      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {\n        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        $link.addClass(ClassName.ACTIVE);\n      } else {\n        // todo (fat) this is kinda sus...\n        // recursively add actives to tested nav-links\n        $link.parents(Selector.LI).find('> ' + Selector.NAV_LINKS).addClass(ClassName.ACTIVE);\n      }\n\n      $(this._scrollElement).trigger(Event.ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n\n    ScrollSpy.prototype._clear = function _clear() {\n      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);\n    };\n\n    // static\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;\n\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(ScrollSpy, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(window).on(Event.LOAD_DATA_API, function () {\n    var scrollSpys = $.makeArray($(Selector.DATA_SPY));\n\n    for (var i = scrollSpys.length; i--;) {\n      var $spy = $(scrollSpys[i]);\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = ScrollSpy._jQueryInterface;\n  $.fn[NAME].Constructor = ScrollSpy;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  return ScrollSpy;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Tab = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'tab';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.tab';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 150;\n\n  var Event = {\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    CLICK_DATA_API: 'click' + EVENT_KEY + DATA_API_KEY\n  };\n\n  var ClassName = {\n    DROPDOWN_MENU: 'dropdown-menu',\n    ACTIVE: 'active',\n    DISABLED: 'disabled',\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n\n  var Selector = {\n    A: 'a',\n    LI: 'li',\n    DROPDOWN: '.dropdown',\n    LIST: 'ul:not(.dropdown-menu), ol:not(.dropdown-menu), nav:not(.dropdown-menu)',\n    FADE_CHILD: '> .nav-item .fade, > .fade',\n    ACTIVE: '.active',\n    ACTIVE_CHILD: '> .nav-item > .active, > .active',\n    DATA_TOGGLE: '[data-toggle=\"tab\"], [data-toggle=\"pill\"]',\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tab = function () {\n    function Tab(element) {\n      _classCallCheck(this, Tab);\n\n      this._element = element;\n    }\n\n    // getters\n\n    // public\n\n    Tab.prototype.show = function show() {\n      var _this20 = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {\n        return;\n      }\n\n      var target = void 0;\n      var previous = void 0;\n      var listElement = $(this._element).closest(Selector.LIST)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        previous = $.makeArray($(listElement).find(Selector.ACTIVE));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $.Event(Event.HIDE, {\n        relatedTarget: this._element\n      });\n\n      var showEvent = $.Event(Event.SHOW, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $(previous).trigger(hideEvent);\n      }\n\n      $(this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = $(selector)[0];\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $.Event(Event.HIDDEN, {\n          relatedTarget: _this20._element\n        });\n\n        var shownEvent = $.Event(Event.SHOWN, {\n          relatedTarget: previous\n        });\n\n        $(previous).trigger(hiddenEvent);\n        $(_this20._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    Tab.prototype.dispose = function dispose() {\n      $.removeClass(this._element, DATA_KEY);\n      this._element = null;\n    };\n\n    // private\n\n    Tab.prototype._activate = function _activate(element, container, callback) {\n      var _this21 = this;\n\n      var active = $(container).find(Selector.ACTIVE_CHILD)[0];\n      var isTransitioning = callback && Util.supportsTransitionEnd() && (active && $(active).hasClass(ClassName.FADE) || Boolean($(container).find(Selector.FADE_CHILD)[0]));\n\n      var complete = function complete() {\n        return _this21._transitionComplete(element, active, isTransitioning, callback);\n      };\n\n      if (active && isTransitioning) {\n        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\n      } else {\n        complete();\n      }\n\n      if (active) {\n        $(active).removeClass(ClassName.SHOW);\n      }\n    };\n\n    Tab.prototype._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {\n      if (active) {\n        $(active).removeClass(ClassName.ACTIVE);\n\n        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $(dropdownChild).removeClass(ClassName.ACTIVE);\n        }\n\n        active.setAttribute('aria-expanded', false);\n      }\n\n      $(element).addClass(ClassName.ACTIVE);\n      element.setAttribute('aria-expanded', true);\n\n      if (isTransitioning) {\n        Util.reflow(element);\n        $(element).addClass(ClassName.SHOW);\n      } else {\n        $(element).removeClass(ClassName.FADE);\n      }\n\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\n\n        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];\n        if (dropdownElement) {\n          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);\n        }\n\n        element.setAttribute('aria-expanded', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    };\n\n    // static\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_KEY);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Tab;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\n    event.preventDefault();\n    Tab._jQueryInterface.call($(this), 'show');\n  });\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Tab._jQueryInterface;\n  $.fn[NAME].Constructor = Tab;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tab._jQueryInterface;\n  };\n\n  return Tab;\n}(jQuery);\n\n/* global Tether */\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Tooltip = function ($) {\n\n  /**\n   * Check for Tether dependency\n   * Tether - http://tether.io/\n   */\n  if (typeof Tether === 'undefined') {\n    throw new Error('Bootstrap tooltips require Tether (http://tether.io/)');\n  }\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'tooltip';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.tooltip';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n  var TRANSITION_DURATION = 150;\n  var CLASS_PREFIX = 'bs-tether';\n\n  var Default = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: '0 0',\n    constraints: [],\n    container: false\n  };\n\n  var DefaultType = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: 'string',\n    constraints: 'array',\n    container: '(string|element|boolean)'\n  };\n\n  var AttachmentMap = {\n    TOP: 'bottom center',\n    RIGHT: 'middle left',\n    BOTTOM: 'top center',\n    LEFT: 'middle right'\n  };\n\n  var HoverState = {\n    SHOW: 'show',\n    OUT: 'out'\n  };\n\n  var Event = {\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    INSERTED: 'inserted' + EVENT_KEY,\n    CLICK: 'click' + EVENT_KEY,\n    FOCUSIN: 'focusin' + EVENT_KEY,\n    FOCUSOUT: 'focusout' + EVENT_KEY,\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\n  };\n\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n\n  var Selector = {\n    TOOLTIP: '.tooltip',\n    TOOLTIP_INNER: '.tooltip-inner'\n  };\n\n  var TetherClass = {\n    element: false,\n    enabled: false\n  };\n\n  var Trigger = {\n    HOVER: 'hover',\n    FOCUS: 'focus',\n    CLICK: 'click',\n    MANUAL: 'manual'\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tooltip = function () {\n    function Tooltip(element, config) {\n      _classCallCheck(this, Tooltip);\n\n      // private\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._isTransitioning = false;\n      this._tether = null;\n\n      // protected\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    }\n\n    // getters\n\n    // public\n\n    Tooltip.prototype.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    Tooltip.prototype.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    Tooltip.prototype.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    Tooltip.prototype.toggle = function toggle(event) {\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $(event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $(event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n\n        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {\n          this._leave(null, this);\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    Tooltip.prototype.dispose = function dispose() {\n      clearTimeout(this._timeout);\n\n      this.cleanupTether();\n\n      $.removeData(this.element, this.constructor.DATA_KEY);\n\n      $(this.element).off(this.constructor.EVENT_KEY);\n      $(this.element).closest('.modal').off('hide.bs.modal');\n\n      if (this.tip) {\n        $(this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n      this._tether = null;\n\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    Tooltip.prototype.show = function show() {\n      var _this22 = this;\n\n      if ($(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $.Event(this.constructor.Event.SHOW);\n      if (this.isWithContent() && this._isEnabled) {\n        if (this._isTransitioning) {\n          throw new Error('Tooltip is transitioning');\n        }\n        $(this.element).trigger(showEvent);\n\n        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n\n        this.setContent();\n\n        if (this.config.animation) {\n          $(tip).addClass(ClassName.FADE);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        var container = this.config.container === false ? document.body : $(this.config.container);\n\n        $(tip).data(this.constructor.DATA_KEY, this).appendTo(container);\n\n        $(this.element).trigger(this.constructor.Event.INSERTED);\n\n        this._tether = new Tether({\n          attachment: attachment,\n          element: tip,\n          target: this.element,\n          classes: TetherClass,\n          classPrefix: CLASS_PREFIX,\n          offset: this.config.offset,\n          constraints: this.config.constraints,\n          addTargetClasses: false\n        });\n\n        Util.reflow(tip);\n        this._tether.position();\n\n        $(tip).addClass(ClassName.SHOW);\n\n        var complete = function complete() {\n          var prevHoverState = _this22._hoverState;\n          _this22._hoverState = null;\n          _this22._isTransitioning = false;\n\n          $(_this22.element).trigger(_this22.constructor.Event.SHOWN);\n\n          if (prevHoverState === HoverState.OUT) {\n            _this22._leave(null, _this22);\n          }\n        };\n\n        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\n          this._isTransitioning = true;\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);\n          return;\n        }\n\n        complete();\n      }\n    };\n\n    Tooltip.prototype.hide = function hide(callback) {\n      var _this23 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\n      if (this._isTransitioning) {\n        throw new Error('Tooltip is transitioning');\n      }\n      var complete = function complete() {\n        if (_this23._hoverState !== HoverState.SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this23.element.removeAttribute('aria-describedby');\n        $(_this23.element).trigger(_this23.constructor.Event.HIDDEN);\n        _this23._isTransitioning = false;\n        _this23.cleanupTether();\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $(this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $(tip).removeClass(ClassName.SHOW);\n\n      this._activeTrigger[Trigger.CLICK] = false;\n      this._activeTrigger[Trigger.FOCUS] = false;\n      this._activeTrigger[Trigger.HOVER] = false;\n\n      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {\n        this._isTransitioning = true;\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    // protected\n\n    Tooltip.prototype.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    Tooltip.prototype.getTipElement = function getTipElement() {\n      return this.tip = this.tip || $(this.config.template)[0];\n    };\n\n    Tooltip.prototype.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n\n      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());\n\n      $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);\n\n      this.cleanupTether();\n    };\n\n    Tooltip.prototype.setElementContent = function setElementContent($element, content) {\n      var html = this.config.html;\n      if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {\n        // content is a DOM node or a jQuery\n        if (html) {\n          if (!$(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($(content).text());\n        }\n      } else {\n        $element[html ? 'html' : 'text'](content);\n      }\n    };\n\n    Tooltip.prototype.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    };\n\n    Tooltip.prototype.cleanupTether = function cleanupTether() {\n      if (this._tether) {\n        this._tether.destroy();\n      }\n    };\n\n    // private\n\n    Tooltip.prototype._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    Tooltip.prototype._setListeners = function _setListeners() {\n      var _this24 = this;\n\n      var triggers = this.config.trigger.split(' ');\n\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $(_this24.element).on(_this24.constructor.Event.CLICK, _this24.config.selector, function (event) {\n            return _this24.toggle(event);\n          });\n        } else if (trigger !== Trigger.MANUAL) {\n          var eventIn = trigger === Trigger.HOVER ? _this24.constructor.Event.MOUSEENTER : _this24.constructor.Event.FOCUSIN;\n          var eventOut = trigger === Trigger.HOVER ? _this24.constructor.Event.MOUSELEAVE : _this24.constructor.Event.FOCUSOUT;\n\n          $(_this24.element).on(eventIn, _this24.config.selector, function (event) {\n            return _this24._enter(event);\n          }).on(eventOut, _this24.config.selector, function (event) {\n            return _this24._leave(event);\n          });\n        }\n\n        $(_this24.element).closest('.modal').on('hide.bs.modal', function () {\n          return _this24.hide();\n        });\n      });\n\n      if (this.config.selector) {\n        this.config = $.extend({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    Tooltip.prototype._fixTitle = function _fixTitle() {\n      var titleType = _typeof(this.element.getAttribute('data-original-title'));\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    Tooltip.prototype._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\n      }\n\n      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {\n        context._hoverState = HoverState.SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n\n      context._hoverState = HoverState.SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    Tooltip.prototype._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n\n      context = context || $(event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $(event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n\n      context._hoverState = HoverState.OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HoverState.OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    Tooltip.prototype._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    Tooltip.prototype._getConfig = function _getConfig(config) {\n      config = $.extend({}, this.constructor.Default, $(this.element).data(), config);\n\n      if (config.delay && typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n\n      return config;\n    };\n\n    Tooltip.prototype._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    // static\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: 'VERSION',\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: 'NAME',\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: 'DATA_KEY',\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: 'Event',\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: 'EVENT_KEY',\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: 'DefaultType',\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Tooltip._jQueryInterface;\n  $.fn[NAME].Constructor = Tooltip;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Tooltip._jQueryInterface;\n  };\n\n  return Tooltip;\n}(jQuery);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.0.0-alpha.6): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar Popover = function ($) {\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'popover';\n  var VERSION = '4.0.0-alpha.6';\n  var DATA_KEY = 'bs.popover';\n  var EVENT_KEY = '.' + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\n\n  var Default = $.extend({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<h3 class=\"popover-title\"></h3>' + '<div class=\"popover-content\"></div></div>'\n  });\n\n  var DefaultType = $.extend({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n\n  var ClassName = {\n    FADE: 'fade',\n    SHOW: 'show'\n  };\n\n  var Selector = {\n    TITLE: '.popover-title',\n    CONTENT: '.popover-content'\n  };\n\n  var Event = {\n    HIDE: 'hide' + EVENT_KEY,\n    HIDDEN: 'hidden' + EVENT_KEY,\n    SHOW: 'show' + EVENT_KEY,\n    SHOWN: 'shown' + EVENT_KEY,\n    INSERTED: 'inserted' + EVENT_KEY,\n    CLICK: 'click' + EVENT_KEY,\n    FOCUSIN: 'focusin' + EVENT_KEY,\n    FOCUSOUT: 'focusout' + EVENT_KEY,\n    MOUSEENTER: 'mouseenter' + EVENT_KEY,\n    MOUSELEAVE: 'mouseleave' + EVENT_KEY\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Popover = function (_Tooltip) {\n    _inherits(Popover, _Tooltip);\n\n    function Popover() {\n      _classCallCheck(this, Popover);\n\n      return _possibleConstructorReturn(this, _Tooltip.apply(this, arguments));\n    }\n\n    // overrides\n\n    Popover.prototype.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n\n    Popover.prototype.getTipElement = function getTipElement() {\n      return this.tip = this.tip || $(this.config.template)[0];\n    };\n\n    Popover.prototype.setContent = function setContent() {\n      var $tip = $(this.getTipElement());\n\n      // we use append for html objects to maintain js events\n      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());\n      this.setElementContent($tip.find(Selector.CONTENT), this._getContent());\n\n      $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);\n\n      this.cleanupTether();\n    };\n\n    // private\n\n    Popover.prototype._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);\n    };\n\n    // static\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $(this).data(DATA_KEY);\n        var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : null;\n\n        if (!data && /destroy|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Popover(this, _config);\n          $(this).data(DATA_KEY, data);\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined) {\n            throw new Error('No method named \"' + config + '\"');\n          }\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Popover, null, [{\n      key: 'VERSION',\n\n\n      // getters\n\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: 'Default',\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: 'NAME',\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: 'DATA_KEY',\n      get: function get() {\n        return DATA_KEY;\n      }\n    }, {\n      key: 'Event',\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: 'EVENT_KEY',\n      get: function get() {\n        return EVENT_KEY;\n      }\n    }, {\n      key: 'DefaultType',\n      get: function get() {\n        return DefaultType;\n      }\n    }]);\n\n    return Popover;\n  }(Tooltip);\n\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $.fn[NAME] = Popover._jQueryInterface;\n  $.fn[NAME].Constructor = Popover;\n  $.fn[NAME].noConflict = function () {\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\n    return Popover._jQueryInterface;\n  };\n\n  return Popover;\n}(jQuery);\n\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzPzQ5ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBCb290c3RyYXAgdjQuMC4wLWFscGhhLjYgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxuaWYgKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdC4nKVxufVxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgaWYgKCh2ZXJzaW9uWzBdIDwgMiAmJiB2ZXJzaW9uWzFdIDwgOSkgfHwgKHZlcnNpb25bMF0gPT0gMSAmJiB2ZXJzaW9uWzFdID09IDkgJiYgdmVyc2lvblsyXSA8IDEpIHx8ICh2ZXJzaW9uWzBdID49IDQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMCcpXG4gIH1cbn0oalF1ZXJ5KTtcblxuXG4rZnVuY3Rpb24gKCkge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYWxwaGEuNik6IHV0aWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBVdGlsID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFByaXZhdGUgVHJhbnNpdGlvbkVuZCBIZWxwZXJzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgdHJhbnNpdGlvbiA9IGZhbHNlO1xuXG4gIHZhciBNQVhfVUlEID0gMTAwMDAwMDtcblxuICB2YXIgVHJhbnNpdGlvbkVuZEV2ZW50ID0ge1xuICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICBNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gIH07XG5cbiAgLy8gc2hvdXRvdXQgQW5ndXNDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuICBmdW5jdGlvbiB0b1R5cGUob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiAob2JqWzBdIHx8IG9iaikubm9kZVR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBiaW5kVHlwZTogdHJhbnNpdGlvbi5lbmQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6IHRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzKSkge1xuICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRUZXN0KCkge1xuICAgIGlmICh3aW5kb3cuUVVuaXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gVHJhbnNpdGlvbkVuZEV2ZW50KSB7XG4gICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuZDogVHJhbnNpdGlvbkVuZEV2ZW50W25hbWVdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEVtdWxhdG9yKGR1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICQodGhpcykub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQoX3RoaXMpO1xuICAgICAgfVxuICAgIH0sIGR1cmF0aW9uKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKSB7XG4gICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmRUZXN0KCk7XG5cbiAgICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gdHJhbnNpdGlvbkVuZEVtdWxhdG9yO1xuXG4gICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpIHtcbiAgICAgICQuZXZlbnQuc3BlY2lhbFtVdGlsLlRSQU5TSVRJT05fRU5EXSA9IGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogUHVibGljIFV0aWwgQXBpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBVdGlsID0ge1xuXG4gICAgVFJBTlNJVElPTl9FTkQ6ICdic1RyYW5zaXRpb25FbmQnLFxuXG4gICAgZ2V0VUlEOiBmdW5jdGlvbiBnZXRVSUQocHJlZml4KSB7XG4gICAgICBkbyB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHByZWZpeCArPSB+fihNYXRoLnJhbmRvbSgpICogTUFYX1VJRCk7IC8vIFwifn5cIiBhY3RzIGxpa2UgYSBmYXN0ZXIgTWF0aC5mbG9vcigpIGhlcmVcbiAgICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9LFxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0Jyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuICAgICAgICBzZWxlY3RvciA9IC9eI1thLXpdL2kudGVzdChzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9LFxuICAgIHJlZmxvdzogZnVuY3Rpb24gcmVmbG93KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB9LFxuICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiB0cmlnZ2VyVHJhbnNpdGlvbkVuZChlbGVtZW50KSB7XG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIodHJhbnNpdGlvbi5lbmQpO1xuICAgIH0sXG4gICAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25FbmQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0cmFuc2l0aW9uKTtcbiAgICB9LFxuICAgIHR5cGVDaGVja0NvbmZpZzogZnVuY3Rpb24gdHlwZUNoZWNrQ29uZmlnKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XG4gICAgICAgIGlmIChjb25maWdUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wb25lbnROYW1lLnRvVXBwZXJDYXNlKCkgKyAnOiAnICsgKCdPcHRpb24gXCInICsgcHJvcGVydHkgKyAnXCIgcHJvdmlkZWQgdHlwZSBcIicgKyB2YWx1ZVR5cGUgKyAnXCIgJykgKyAoJ2J1dCBleHBlY3RlZCB0eXBlIFwiJyArIGV4cGVjdGVkVHlwZXMgKyAnXCIuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpO1xuXG4gIHJldHVybiBVdGlsO1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogYWxlcnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBBbGVydCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2FsZXJ0JztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYWxwaGEuNic7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5hbGVydCc7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbiAgdmFyIFRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTA7XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIENMT1NFOiAnY2xvc2UnICsgRVZFTlRfS0VZLFxuICAgIENMT1NFRDogJ2Nsb3NlZCcgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIEFMRVJUOiAnYWxlcnQnLFxuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBBbGVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbGVydChlbGVtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxlcnQpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQocm9vdEVsZW1lbnQpO1xuXG4gICAgICBpZiAoY3VzdG9tRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBBbGVydC5wcm90b3R5cGUuX2dldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHZhciBwYXJlbnQgPSBmYWxzZTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHBhcmVudCA9ICQoc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoJy4nICsgQ2xhc3NOYW1lLkFMRVJUKVswXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLl90cmlnZ2VyQ2xvc2VFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyQ2xvc2VFdmVudChlbGVtZW50KSB7XG4gICAgICB2YXIgY2xvc2VFdmVudCA9ICQuRXZlbnQoRXZlbnQuQ0xPU0UpO1xuXG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoY2xvc2VFdmVudCk7XG4gICAgICByZXR1cm4gY2xvc2VFdmVudDtcbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLl9yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICBpZiAoIVV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgfHwgISQoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQoZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9kZXN0cm95RWxlbWVudChlbGVtZW50LCBldmVudCk7XG4gICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICB9O1xuXG4gICAgQWxlcnQucHJvdG90eXBlLl9kZXN0cm95RWxlbWVudCA9IGZ1bmN0aW9uIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAkKGVsZW1lbnQpLmRldGFjaCgpLnRyaWdnZXIoRXZlbnQuQ0xPU0VEKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBBbGVydC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQWxlcnQuX2hhbmRsZURpc21pc3MgPSBmdW5jdGlvbiBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBhbGVydEluc3RhbmNlLmNsb3NlKHRoaXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEFsZXJ0LCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFsZXJ0O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRJU01JU1MsIEFsZXJ0Ll9oYW5kbGVEaXNtaXNzKG5ldyBBbGVydCgpKSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQWxlcnQ7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBBbGVydDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYWxwaGEuNik6IGJ1dHRvbi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2J1dHRvbic7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWFscGhhLjYnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuYnV0dG9uJztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICBCVVRUT046ICdidG4nLFxuICAgIEZPQ1VTOiAnZm9jdXMnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIERBVEFfVE9HR0xFX0NBUlJPVDogJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScsXG4gICAgSU5QVVQ6ICdpbnB1dCcsXG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgQlVUVE9OOiAnLmJ0bidcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVksXG4gICAgRk9DVVNfQkxVUl9EQVRBX0FQSTogJ2ZvY3VzJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSArICcgJyArICgnYmx1cicgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVkpXG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgLy8gcHVibGljXG5cbiAgICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlO1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yLkRBVEFfVE9HR0xFKVswXTtcblxuICAgICAgaWYgKHJvb3RFbGVtZW50KSB7XG4gICAgICAgIHZhciBpbnB1dCA9ICQodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5JTlBVVClbMF07XG5cbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9ICQocm9vdEVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFKVswXTtcblxuICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICQoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgICAkKGlucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCAhJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSk7XG5cbiAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQnV0dG9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBCdXR0b24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEJ1dHRvbiwgbnVsbCwgW3tcbiAgICAgIGtleTogJ1ZFUlNJT04nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBCdXR0b247XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICghJChidXR0b24pLmhhc0NsYXNzKENsYXNzTmFtZS5CVVRUT04pKSB7XG4gICAgICBidXR0b24gPSAkKGJ1dHRvbikuY2xvc2VzdChTZWxlY3Rvci5CVVRUT04pO1xuICAgIH1cblxuICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJyk7XG4gIH0pLm9uKEV2ZW50LkZPQ1VTX0JMVVJfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFX0NBUlJPVCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilbMF07XG4gICAgJChidXR0b24pLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5GT0NVUywgL15mb2N1cyhpbik/JC8udGVzdChldmVudC50eXBlKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gQnV0dG9uO1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2Nhcm91c2VsJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYWxwaGEuNic7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCc7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbiAgdmFyIFRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDA7XG4gIHZhciBBUlJPV19MRUZUX0tFWUNPREUgPSAzNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgbGVmdCBhcnJvdyBrZXlcbiAgdmFyIEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG5cbiAgdmFyIERlZmF1bHQgPSB7XG4gICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgc2xpZGU6IGZhbHNlLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWVcbiAgfTtcblxuICB2YXIgRGVmYXVsdFR5cGUgPSB7XG4gICAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICAgIHNsaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICB3cmFwOiAnYm9vbGVhbidcbiAgfTtcblxuICB2YXIgRGlyZWN0aW9uID0ge1xuICAgIE5FWFQ6ICduZXh0JyxcbiAgICBQUkVWOiAncHJldicsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIFNMSURFOiAnc2xpZGUnICsgRVZFTlRfS0VZLFxuICAgIFNMSUQ6ICdzbGlkJyArIEVWRU5UX0tFWSxcbiAgICBLRVlET1dOOiAna2V5ZG93bicgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VFTlRFUjogJ21vdXNlZW50ZXInICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFTEVBVkU6ICdtb3VzZWxlYXZlJyArIEVWRU5UX0tFWSxcbiAgICBMT0FEX0RBVEFfQVBJOiAnbG9hZCcgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIENBUk9VU0VMOiAnY2Fyb3VzZWwnLFxuICAgIEFDVElWRTogJ2FjdGl2ZScsXG4gICAgU0xJREU6ICdzbGlkZScsXG4gICAgUklHSFQ6ICdjYXJvdXNlbC1pdGVtLXJpZ2h0JyxcbiAgICBMRUZUOiAnY2Fyb3VzZWwtaXRlbS1sZWZ0JyxcbiAgICBORVhUOiAnY2Fyb3VzZWwtaXRlbS1uZXh0JyxcbiAgICBQUkVWOiAnY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgICBJVEVNOiAnY2Fyb3VzZWwtaXRlbSdcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgQUNUSVZFX0lURU06ICcuYWN0aXZlLmNhcm91c2VsLWl0ZW0nLFxuICAgIElURU06ICcuY2Fyb3VzZWwtaXRlbScsXG4gICAgTkVYVF9QUkVWOiAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldicsXG4gICAgSU5ESUNBVE9SUzogJy5jYXJvdXNlbC1pbmRpY2F0b3JzJyxcbiAgICBEQVRBX1NMSURFOiAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nLFxuICAgIERBVEFfUklERTogJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXSdcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9ICQoZWxlbWVudClbMF07XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5JTkRJQ0FUT1JTKVswXTtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXJvdXNlbCBpcyBzbGlkaW5nJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zbGlkZShEaXJlY3Rpb24uTkVYVCk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5uZXh0V2hlblZpc2libGUgPSBmdW5jdGlvbiBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXG4gICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhcm91c2VsIGlzIHNsaWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NsaWRlKERpcmVjdGlvbi5QUkVWSU9VUyk7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGV2ZW50KSB7XG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCQodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5ORVhUX1BSRVYpWzBdICYmIFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpIHtcbiAgICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgdGhpcy5jeWNsZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5jeWNsZSA9IGZ1bmN0aW9uIGN5Y2xlKGV2ZW50KSB7XG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZCh0aGlzKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gdG8oaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRV9JVEVNKVswXTtcblxuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICBpZiAoaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoRXZlbnQuU0xJRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMudG8oaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbmRleCA+IGFjdGl2ZUluZGV4ID8gRGlyZWN0aW9uLk5FWFQgOiBEaXJlY3Rpb24uUFJFVklPVVM7XG5cbiAgICAgIHRoaXMuX3NsaWRlKGRpcmVjdGlvbiwgdGhpcy5faXRlbXNbaW5kZXhdKTtcbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZKTtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG5cbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV04sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuX2tleWRvd24oZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJyAmJiAhKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5NT1VTRUVOVEVSLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnBhdXNlKGV2ZW50KTtcbiAgICAgICAgfSkub24oRXZlbnQuTU9VU0VMRUFWRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5jeWNsZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2tleWRvd24gPSBmdW5jdGlvbiBfa2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgICBjYXNlIEFSUk9XX0xFRlRfS0VZQ09ERTpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucHJldigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFSUk9XX1JJR0hUX0tFWUNPREU6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9pdGVtcyA9ICQubWFrZUFycmF5KCQoZWxlbWVudCkucGFyZW50KCkuZmluZChTZWxlY3Rvci5JVEVNKSk7XG4gICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRJdGVtQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0SXRlbUJ5RGlyZWN0aW9uKGRpcmVjdGlvbiwgYWN0aXZlRWxlbWVudCkge1xuICAgICAgdmFyIGlzTmV4dERpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5FWFQ7XG4gICAgICB2YXIgaXNQcmV2RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFVklPVVM7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XG4gICAgICB2YXIgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaXNHb2luZ1RvV3JhcCA9IGlzUHJldkRpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fCBpc05leHREaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXg7XG5cbiAgICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFVklPVVMgPyAtMSA6IDE7XG4gICAgICB2YXIgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy5faXRlbXMubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gaXRlbUluZGV4ID09PSAtMSA/IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdIDogdGhpcy5faXRlbXNbaXRlbUluZGV4XTtcbiAgICB9O1xuXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl90cmlnZ2VyU2xpZGVFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyU2xpZGVFdmVudChyZWxhdGVkVGFyZ2V0LCBldmVudERpcmVjdGlvbk5hbWUpIHtcbiAgICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5TTElERSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZVxuICAgICAgfSk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkZUV2ZW50KTtcblxuICAgICAgcmV0dXJuIHNsaWRlRXZlbnQ7XG4gICAgfTtcblxuICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCA9IGZ1bmN0aW9uIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgICAkKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG5cbiAgICAgICAgdmFyIG5leHRJbmRpY2F0b3IgPSB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5jaGlsZHJlblt0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudCldO1xuXG4gICAgICAgIGlmIChuZXh0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgJChuZXh0SW5kaWNhdG9yKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3NsaWRlID0gZnVuY3Rpb24gX3NsaWRlKGRpcmVjdGlvbiwgZWxlbWVudCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRV9JVEVNKVswXTtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgYWN0aXZlRWxlbWVudCAmJiB0aGlzLl9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KTtcblxuICAgICAgdmFyIGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgb3JkZXJDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgZXZlbnREaXJlY3Rpb25OYW1lID0gdm9pZCAwO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVCkge1xuICAgICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENsYXNzTmFtZS5MRUZUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5ORVhUO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uTEVGVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUO1xuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5QUkVWO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uUklHSFQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0RWxlbWVudCAmJiAkKG5leHRFbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xuICAgICAgaWYgKHNsaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAgIC8vIHNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcblxuICAgICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0xJRCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TTElERSkpIHtcblxuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhvcmRlckNsYXNzTmFtZSk7XG5cbiAgICAgICAgVXRpbC5yZWZsb3cobmV4dEVsZW1lbnQpO1xuXG4gICAgICAgICQoYWN0aXZlRWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgJChhY3RpdmVFbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQobmV4dEVsZW1lbnQpLnJlbW92ZUNsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lICsgJyAnICsgb3JkZXJDbGFzc05hbWUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFICsgJyAnICsgb3JkZXJDbGFzc05hbWUgKyAnICcgKyBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgICAgICBfdGhpczUuX2lzU2xpZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJChfdGhpczUuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcblxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIF9jb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgJCh0aGlzKS5kYXRhKCkpO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbmZpZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZmlnKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgJC5leHRlbmQoX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBhY3Rpb24gKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVthY3Rpb25dKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCkge1xuICAgICAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgICAgICBkYXRhLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG5cbiAgICAgIGlmICghdGFyZ2V0IHx8ICEkKHRhcmdldCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkNBUk9VU0VMKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgJCh0YXJnZXQpLmRhdGEoKSwgJCh0aGlzKS5kYXRhKCkpO1xuICAgICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpO1xuXG4gICAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKTtcblxuICAgICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICAgJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpLnRvKHNsaWRlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpO1xuXG4gICQod2luZG93KS5vbihFdmVudC5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XG4gICAgJChTZWxlY3Rvci5EQVRBX1JJREUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRjYXJvdXNlbCA9ICQodGhpcyk7XG4gICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQuZm5bTkFNRV0gPSBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ2Fyb3VzZWw7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIHJldHVybiBDYXJvdXNlbDtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYWxwaGEuNik6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdjb2xsYXBzZSc7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWFscGhhLjYnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG4gIHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAwO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICBwYXJlbnQ6ICcnXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nLFxuICAgIHBhcmVudDogJ3N0cmluZydcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgQ09MTEFQU0U6ICdjb2xsYXBzZScsXG4gICAgQ09MTEFQU0lORzogJ2NvbGxhcHNpbmcnLFxuICAgIENPTExBUFNFRDogJ2NvbGxhcHNlZCdcbiAgfTtcblxuICB2YXIgRGltZW5zaW9uID0ge1xuICAgIFdJRFRIOiAnd2lkdGgnLFxuICAgIEhFSUdIVDogJ2hlaWdodCdcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgQUNUSVZFUzogJy5jYXJkID4gLnNob3csIC5jYXJkID4gLmNvbGxhcHNpbmcnLFxuICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGFwc2UoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGFwc2UpO1xuXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSAkLm1ha2VBcnJheSgkKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwnICsgKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnICsgZWxlbWVudC5pZCArICdcIl0nKSkpO1xuXG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3RyaWdnZXJBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgLy8gcHVibGljXG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sbGFwc2UgaXMgdHJhbnNpdGlvbmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aXZlcyA9IHZvaWQgMDtcbiAgICAgIHZhciBhY3RpdmVzRGF0YSA9IHZvaWQgMDtcblxuICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICBhY3RpdmVzID0gJC5tYWtlQXJyYXkoJCh0aGlzLl9wYXJlbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFUykpO1xuICAgICAgICBpZiAoIWFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWN0aXZlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgICAgYWN0aXZlc0RhdGEgPSAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVyk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudCk7XG4gICAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKGFjdGl2ZXMpLCAnaGlkZScpO1xuICAgICAgICBpZiAoIWFjdGl2ZXNEYXRhKSB7XG4gICAgICAgICAgJChhY3RpdmVzKS5kYXRhKERBVEFfS0VZLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAkKHRoaXMuX3RyaWdnZXJBcnJheSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcodHJ1ZSk7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAkKF90aGlzNi5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIF90aGlzNi5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgICAgX3RoaXM2LnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xuXG4gICAgICAgICQoX3RoaXM2Ll9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LlNIT1dOKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xuICAgICAgdmFyIHNjcm9sbFNpemUgPSAnc2Nyb2xsJyArIGNhcGl0YWxpemVkRGltZW5zaW9uO1xuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVFJBTlNJVElPTl9EVVJBVElPTik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IHRoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV0gKyAncHgnO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxhcHNlIGlzIHRyYW5zaXRpb25pbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgICAgdmFyIG9mZnNldERpbWVuc2lvbiA9IGRpbWVuc2lvbiA9PT0gRGltZW5zaW9uLldJRFRIID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50W29mZnNldERpbWVuc2lvbl0gKyAncHgnO1xuXG4gICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORykucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuXG4gICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAkKHRoaXMuX3RyaWdnZXJBcnJheSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgX3RoaXM3LnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xuICAgICAgICAkKF90aGlzNy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgIGlmICghVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICB9O1xuXG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnNldFRyYW5zaXRpb25pbmcgPSBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nO1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIGNvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHZhciBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKTtcbiAgICAgIHJldHVybiBoYXNXaWR0aCA/IERpbWVuc2lvbi5XSURUSCA6IERpbWVuc2lvbi5IRUlHSFQ7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLnByb3RvdHlwZS5fZ2V0UGFyZW50ID0gZnVuY3Rpb24gX2dldFBhcmVudCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyZW50ID0gJCh0aGlzLl9jb25maWcucGFyZW50KVswXTtcbiAgICAgIHZhciBzZWxlY3RvciA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLl9jb25maWcucGFyZW50ICsgJ1wiXSc7XG5cbiAgICAgICQocGFyZW50KS5maW5kKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIF90aGlzOC5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSwgW2VsZW1lbnRdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcblxuICAgICAgICBpZiAodHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICQodHJpZ2dlckFycmF5KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VELCAhaXNPcGVuKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyAkKHNlbGVjdG9yKVswXSA6IG51bGw7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJHRoaXMuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gJC5leHRlbmQoe30sIERlZmF1bHQsICR0aGlzLmRhdGEoKSwgKHR5cGVvZiBjb25maWcgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbmZpZykpID09PSAnb2JqZWN0JyAmJiBjb25maWcpO1xuXG4gICAgICAgIGlmICghZGF0YSAmJiBfY29uZmlnLnRvZ2dsZSAmJiAvc2hvd3xoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkdGhpcy5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKENvbGxhcHNlLCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbGxhcHNlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIHRhcmdldCA9IENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudCh0aGlzKTtcbiAgICB2YXIgZGF0YSA9ICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKTtcbiAgICB2YXIgY29uZmlnID0gZGF0YSA/ICd0b2dnbGUnIDogJCh0aGlzKS5kYXRhKCk7XG5cbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCh0YXJnZXQpLCBjb25maWcpO1xuICB9KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZTtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIENvbGxhcHNlO1xufShqUXVlcnkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjAuMC1hbHBoYS42KTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ2Ryb3Bkb3duJztcbiAgdmFyIFZFUlNJT04gPSAnNC4wLjAtYWxwaGEuNic7XG4gIHZhciBEQVRBX0tFWSA9ICdicy5kcm9wZG93bic7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbiAgdmFyIEVTQ0FQRV9LRVlDT0RFID0gMjc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcbiAgdmFyIEFSUk9XX1VQX0tFWUNPREUgPSAzODsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XG4gIHZhciBBUlJPV19ET1dOX0tFWUNPREUgPSA0MDsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgZG93biBhcnJvdyBrZXlcbiAgdmFyIFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCA9IDM7IC8vIE1vdXNlRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRoZSByaWdodCBidXR0b24gKGFzc3VtaW5nIGEgcmlnaHQtaGFuZGVkIG1vdXNlKVxuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0s6ICdjbGljaycgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVksXG4gICAgRk9DVVNJTl9EQVRBX0FQSTogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZLFxuICAgIEtFWURPV05fREFUQV9BUEk6ICdrZXlkb3duJyArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICB9O1xuXG4gIHZhciBDbGFzc05hbWUgPSB7XG4gICAgQkFDS0RST1A6ICdkcm9wZG93bi1iYWNrZHJvcCcsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0hPVzogJ3Nob3cnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIEJBQ0tEUk9QOiAnLmRyb3Bkb3duLWJhY2tkcm9wJyxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJyxcbiAgICBGT1JNX0NISUxEOiAnLmRyb3Bkb3duIGZvcm0nLFxuICAgIFJPTEVfTUVOVTogJ1tyb2xlPVwibWVudVwiXScsXG4gICAgUk9MRV9MSVNUQk9YOiAnW3JvbGU9XCJsaXN0Ym94XCJdJyxcbiAgICBOQVZCQVJfTkFWOiAnLm5hdmJhci1uYXYnLFxuICAgIFZJU0lCTEVfSVRFTVM6ICdbcm9sZT1cIm1lbnVcIl0gbGk6bm90KC5kaXNhYmxlZCkgYSwgJyArICdbcm9sZT1cImxpc3Rib3hcIl0gbGk6bm90KC5kaXNhYmxlZCkgYSdcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wZG93bihlbGVtZW50KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgRHJvcGRvd24uX2NsZWFyTWVudXMoKTtcblxuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhJChwYXJlbnQpLmNsb3Nlc3QoU2VsZWN0b3IuTkFWQkFSX05BVikubGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgIHZhciBkcm9wZG93biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkcm9wZG93bi5jbGFzc05hbWUgPSBDbGFzc05hbWUuQkFDS0RST1A7XG4gICAgICAgICQoZHJvcGRvd24pLmluc2VydEJlZm9yZSh0aGlzKTtcbiAgICAgICAgJChkcm9wZG93bikub24oJ2NsaWNrJywgRHJvcGRvd24uX2NsZWFyTWVudXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpc1xuICAgICAgfTtcbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgICAkKHBhcmVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcblxuICAgICAgJChwYXJlbnQpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgICQocGFyZW50KS50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuU0hPV04sIHJlbGF0ZWRUYXJnZXQpKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5DTElDSywgdGhpcy50b2dnbGUpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIERyb3Bkb3duLl9jbGVhck1lbnVzID0gZnVuY3Rpb24gX2NsZWFyTWVudXMoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCAmJiBldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhY2tkcm9wID0gJChTZWxlY3Rvci5CQUNLRFJPUClbMF07XG4gICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgYmFja2Ryb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2dnbGVzID0gJC5tYWtlQXJyYXkoJChTZWxlY3Rvci5EQVRBX1RPR0dMRSkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvZ2dsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogdG9nZ2xlc1tpXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IGV2ZW50LnR5cGUgPT09ICdmb2N1c2luJykgJiYgJC5jb250YWlucyhwYXJlbnQsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAkKHBhcmVudCkudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICQocGFyZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVykudHJpZ2dlcigkLkV2ZW50KEV2ZW50LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHBhcmVudCA9ICQoc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGlmICghLygzOHw0MHwyN3wzMikvLnRlc3QoZXZlbnQud2hpY2gpIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuICAgICAgdmFyIGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC53aGljaCAhPT0gRVNDQVBFX0tFWUNPREUgfHwgaXNBY3RpdmUgJiYgZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgIHZhciB0b2dnbGUgPSAkKHBhcmVudCkuZmluZChTZWxlY3Rvci5EQVRBX1RPR0dMRSlbMF07XG4gICAgICAgICAgJCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1zID0gJChwYXJlbnQpLmZpbmQoU2VsZWN0b3IuVklTSUJMRV9JVEVNUykuZ2V0KCk7XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpO1xuXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX1VQX0tFWUNPREUgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgIC8vIHVwXG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBkb3duXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICBpdGVtc1tpbmRleF0uZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duLCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERyb3Bkb3duO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLlJPTEVfTUVOVSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuUk9MRV9MSVNUQk9YLCBEcm9wZG93bi5fZGF0YUFwaUtleWRvd25IYW5kbGVyKS5vbihFdmVudC5DTElDS19EQVRBX0FQSSArICcgJyArIEV2ZW50LkZPQ1VTSU5fREFUQV9BUEksIERyb3Bkb3duLl9jbGVhck1lbnVzKS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5GT1JNX0NISUxELCBmdW5jdGlvbiAoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZTtcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IERyb3Bkb3duO1xuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICByZXR1cm4gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gRHJvcGRvd247XG59KGpRdWVyeSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIE1vZGFsID0gZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUgPSAnbW9kYWwnO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1hbHBoYS42JztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLm1vZGFsJztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgVFJBTlNJVElPTl9EVVJBVElPTiA9IDMwMDtcbiAgdmFyIEJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTA7XG4gIHZhciBFU0NBUEVfS0VZQ09ERSA9IDI3OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XG5cbiAgdmFyIERlZmF1bHQgPSB7XG4gICAgYmFja2Ryb3A6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgZm9jdXM6IHRydWUsXG4gICAgc2hvdzogdHJ1ZVxuICB9O1xuXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgZm9jdXM6ICdib29sZWFuJyxcbiAgICBzaG93OiAnYm9vbGVhbidcbiAgfTtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgSElERTogJ2hpZGUnICsgRVZFTlRfS0VZLFxuICAgIEhJRERFTjogJ2hpZGRlbicgKyBFVkVOVF9LRVksXG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIEZPQ1VTSU46ICdmb2N1c2luJyArIEVWRU5UX0tFWSxcbiAgICBSRVNJWkU6ICdyZXNpemUnICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RJU01JU1M6ICdjbGljay5kaXNtaXNzJyArIEVWRU5UX0tFWSxcbiAgICBLRVlET1dOX0RJU01JU1M6ICdrZXlkb3duLmRpc21pc3MnICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFVVBfRElTTUlTUzogJ21vdXNldXAuZGlzbWlzcycgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VET1dOX0RJU01JU1M6ICdtb3VzZWRvd24uZGlzbWlzcycgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0tfREFUQV9BUEk6ICdjbGljaycgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIFNDUk9MTEJBUl9NRUFTVVJFUjogJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJyxcbiAgICBCQUNLRFJPUDogJ21vZGFsLWJhY2tkcm9wJyxcbiAgICBPUEVOOiAnbW9kYWwtb3BlbicsXG4gICAgRkFERTogJ2ZhZGUnLFxuICAgIFNIT1c6ICdzaG93J1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBESUFMT0c6ICcubW9kYWwtZGlhbG9nJyxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyxcbiAgICBEQVRBX0RJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLFxuICAgIEZJWEVEX0NPTlRFTlQ6ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJ1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGFsKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsKTtcblxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX2RpYWxvZyA9ICQoZWxlbWVudCkuZmluZChTZWxlY3Rvci5ESUFMT0cpWzBdO1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fb3JpZ2luYWxCb2R5UGFkZGluZyA9IDA7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVyc1xuXG4gICAgLy8gcHVibGljXG5cbiAgICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGFsIGlzIHRyYW5zaXRpb25pbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCBzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKENsYXNzTmFtZS5PUEVOKTtcblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgU2VsZWN0b3IuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOS5oaWRlKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICAkKHRoaXMuX2RpYWxvZykub24oRXZlbnQuTU9VU0VET1dOX0RJU01JU1MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJChfdGhpczkuX2VsZW1lbnQpLm9uZShFdmVudC5NT1VTRVVQX0RJU01JU1MsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXMoX3RoaXM5Ll9lbGVtZW50KSkge1xuICAgICAgICAgICAgX3RoaXM5Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczkuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGFsIGlzIHRyYW5zaXRpb25pbmcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb24gPSBVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XG5cbiAgICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKTtcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LkNMSUNLX0RJU01JU1MpO1xuICAgICAgJCh0aGlzLl9kaWFsb2cpLm9mZihFdmVudC5NT1VTRURPV05fRElTTUlTUyk7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczEwLl9oaWRlTW9kYWwoZXZlbnQpO1xuICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGVNb2RhbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuXG4gICAgICAkKHdpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2JhY2tkcm9wKS5vZmYoRVZFTlRfS0VZKTtcblxuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fZGlhbG9nID0gbnVsbDtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBudWxsO1xuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgTW9kYWwucHJvdG90eXBlLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gJC5leHRlbmQoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvd0VsZW1lbnQgPSBmdW5jdGlvbiBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSk7XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiB0cmFuc2l0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChfdGhpczExLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICBfdGhpczExLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMxMS5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgICQoX3RoaXMxMS5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICQodGhpcy5fZGlhbG9nKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChUUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2VuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbihFdmVudC5GT0NVU0lOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgX3RoaXMxMi5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICEkKF90aGlzMTIuX2VsZW1lbnQpLmhhcyhldmVudC50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzMTIuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0RXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICAgX3RoaXMxMy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRXZlbnQuS0VZRE9XTl9ESVNNSVNTKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLl9zZXRSZXNpemVFdmVudCA9IGZ1bmN0aW9uIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKEV2ZW50LlJFU0laRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTQuX2hhbmRsZVVwZGF0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2hpZGVNb2RhbCA9IGZ1bmN0aW9uIF9oaWRlTW9kYWwoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLk9QRU4pO1xuICAgICAgICBfdGhpczE1Ll9yZXNldEFkanVzdG1lbnRzKCk7XG4gICAgICAgIF90aGlzMTUuX3Jlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgICQoX3RoaXMxNS5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fcmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgICBpZiAodGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLl9zaG93QmFja2Ryb3AgPSBmdW5jdGlvbiBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgIHZhciBhbmltYXRlID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkgPyBDbGFzc05hbWUuRkFERSA6ICcnO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgICAgdmFyIGRvQW5pbWF0ZSA9IFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgYW5pbWF0ZTtcblxuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWUgPSBDbGFzc05hbWUuQkFDS0RST1A7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hZGRDbGFzcyhhbmltYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMTYuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICAgIF90aGlzMTYuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMxNi5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgX3RoaXMxNi5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczE2LmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb0FuaW1hdGUpIHtcbiAgICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9iYWNrZHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZG9BbmltYXRlKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93biAmJiB0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gY2FsbGJhY2tSZW1vdmUoKSB7XG4gICAgICAgICAgX3RoaXMxNi5fcmVtb3ZlQmFja2Ryb3AoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChVdGlsLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrUmVtb3ZlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChCQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFja1JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgIC8vIHRvZG8gKGZhdCk6IHRoZXNlIHNob3VsZCBwcm9iYWJseSBiZSByZWZhY3RvcmVkIG91dCBvZiBtb2RhbC5qc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIE1vZGFsLnByb3RvdHlwZS5faGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gX2hhbmRsZVVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2FkanVzdERpYWxvZyA9IGZ1bmN0aW9uIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuX3Njcm9sbGJhcldpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgTW9kYWwucHJvdG90eXBlLl9yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgfTtcblxuICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3NldFNjcm9sbGJhcigpIHtcbiAgICAgIHZhciBib2R5UGFkZGluZyA9IHBhcnNlSW50KCQoU2VsZWN0b3IuRklYRURfQ09OVEVOVCkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJyc7XG5cbiAgICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IGJvZHlQYWRkaW5nICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX3Jlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3Jlc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSB0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nO1xuICAgIH07XG5cbiAgICBNb2RhbC5wcm90b3R5cGUuX2dldFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gX2dldFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgLy8gdGh4IGQud2Fsc2hcbiAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSBDbGFzc05hbWUuU0NST0xMQkFSX01FQVNVUkVSO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIE1vZGFsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIF9jb25maWcgPSAkLmV4dGVuZCh7fSwgTW9kYWwuRGVmYXVsdCwgJCh0aGlzKS5kYXRhKCksICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnKTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IE1vZGFsKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5zaG93KSB7XG4gICAgICAgICAgZGF0YS5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKE1vZGFsLCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1vZGFsO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF07XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZyA9ICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKSA/ICd0b2dnbGUnIDogJC5leHRlbmQoe30sICQodGFyZ2V0KS5kYXRhKCksICQodGhpcykuZGF0YSgpKTtcblxuICAgIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgJHRhcmdldCA9ICQodGFyZ2V0KS5vbmUoRXZlbnQuU0hPVywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJHRhcmdldC5vbmUoRXZlbnQuSElEREVOLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgkKF90aGlzMTcpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgX3RoaXMxNy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIE1vZGFsLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRhcmdldCksIGNvbmZpZywgdGhpcyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gTW9kYWwuX2pRdWVyeUludGVyZmFjZTtcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IE1vZGFsO1xuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICByZXR1cm4gTW9kYWwuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gTW9kYWw7XG59KGpRdWVyeSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBTY3JvbGxTcHkgPSBmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdzY3JvbGxzcHknO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1hbHBoYS42JztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLnNjcm9sbHNweSc7XG4gIHZhciBFVkVOVF9LRVkgPSAnLicgKyBEQVRBX0tFWTtcbiAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcblxuICB2YXIgRGVmYXVsdCA9IHtcbiAgICBvZmZzZXQ6IDEwLFxuICAgIG1ldGhvZDogJ2F1dG8nLFxuICAgIHRhcmdldDogJydcbiAgfTtcblxuICB2YXIgRGVmYXVsdFR5cGUgPSB7XG4gICAgb2Zmc2V0OiAnbnVtYmVyJyxcbiAgICBtZXRob2Q6ICdzdHJpbmcnLFxuICAgIHRhcmdldDogJyhzdHJpbmd8ZWxlbWVudCknXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIEFDVElWQVRFOiAnYWN0aXZhdGUnICsgRVZFTlRfS0VZLFxuICAgIFNDUk9MTDogJ3Njcm9sbCcgKyBFVkVOVF9LRVksXG4gICAgTE9BRF9EQVRBX0FQSTogJ2xvYWQnICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBEUk9QRE9XTl9JVEVNOiAnZHJvcGRvd24taXRlbScsXG4gICAgRFJPUERPV05fTUVOVTogJ2Ryb3Bkb3duLW1lbnUnLFxuICAgIE5BVl9MSU5LOiAnbmF2LWxpbmsnLFxuICAgIE5BVjogJ25hdicsXG4gICAgQUNUSVZFOiAnYWN0aXZlJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBEQVRBX1NQWTogJ1tkYXRhLXNweT1cInNjcm9sbFwiXScsXG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgTElTVF9JVEVNOiAnLmxpc3QtaXRlbScsXG4gICAgTEk6ICdsaScsXG4gICAgTElfRFJPUERPV046ICdsaS5kcm9wZG93bicsXG4gICAgTkFWX0xJTktTOiAnLm5hdi1saW5rJyxcbiAgICBEUk9QRE9XTjogJy5kcm9wZG93bicsXG4gICAgRFJPUERPV05fSVRFTVM6ICcuZHJvcGRvd24taXRlbScsXG4gICAgRFJPUERPV05fVE9HR0xFOiAnLmRyb3Bkb3duLXRvZ2dsZSdcbiAgfTtcblxuICB2YXIgT2Zmc2V0TWV0aG9kID0ge1xuICAgIE9GRlNFVDogJ29mZnNldCcsXG4gICAgUE9TSVRJT046ICdwb3NpdGlvbidcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBTY3JvbGxTcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsU3B5KGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdmFyIF90aGlzMTggPSB0aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsU3B5KTtcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gZWxlbWVudC50YWdOYW1lID09PSAnQk9EWScgPyB3aW5kb3cgOiBlbGVtZW50O1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9zZWxlY3RvciA9IHRoaXMuX2NvbmZpZy50YXJnZXQgKyAnICcgKyBTZWxlY3Rvci5OQVZfTElOS1MgKyAnLCcgKyAodGhpcy5fY29uZmlnLnRhcmdldCArICcgJyArIFNlbGVjdG9yLkRST1BET1dOX0lURU1TKTtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xuXG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEV2ZW50LlNDUk9MTCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczE4Ll9wcm9jZXNzKGV2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMxOSA9IHRoaXM7XG5cbiAgICAgIHZhciBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCAhPT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBPZmZzZXRNZXRob2QuUE9TSVRJT04gOiBPZmZzZXRNZXRob2QuT0ZGU0VUO1xuXG4gICAgICB2YXIgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XG5cbiAgICAgIHZhciBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBPZmZzZXRNZXRob2QuUE9TSVRJT04gPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG5cbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcblxuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG5cbiAgICAgIHZhciB0YXJnZXRzID0gJC5tYWtlQXJyYXkoJCh0aGlzLl9zZWxlY3RvcikpO1xuXG4gICAgICB0YXJnZXRzLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gJCh0YXJnZXRTZWxlY3RvcilbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQub2Zmc2V0V2lkdGggfHwgdGFyZ2V0Lm9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgICAvLyB0b2RvIChmYXQpOiByZW1vdmUgc2tldGNoIHJlbGlhbmNlIG9uIGpRdWVyeSBwb3NpdGlvbi9vZmZzZXRcbiAgICAgICAgICByZXR1cm4gWyQodGFyZ2V0KVtvZmZzZXRNZXRob2RdKCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIF90aGlzMTkuX29mZnNldHMucHVzaChpdGVtWzBdKTtcbiAgICAgICAgX3RoaXMxOS5fdGFyZ2V0cy5wdXNoKGl0ZW1bMV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKTtcblxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLl9zZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9vZmZzZXRzID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2dldENvbmZpZyA9IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgRGVmYXVsdCwgY29uZmlnKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaWQgPSAkKGNvbmZpZy50YXJnZXQpLmF0dHIoJ2lkJyk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICBpZCA9IFV0aWwuZ2V0VUlEKE5BTUUpO1xuICAgICAgICAgICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLnRhcmdldCA9ICcjJyArIGlkO1xuICAgICAgfVxuXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfTtcblxuICAgIFNjcm9sbFNweS5wcm90b3R5cGUuX2dldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpO1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9nZXRPZmZzZXRIZWlnaHQgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gX3Byb2Nlc3MoKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgKyB0aGlzLl9jb25maWcub2Zmc2V0O1xuICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xuICAgICAgdmFyIG1heFNjcm9sbCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcblxuICAgICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIGlzQWN0aXZlVGFyZ2V0ID0gdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW2ldICYmIHNjcm9sbFRvcCA+PSB0aGlzLl9vZmZzZXRzW2ldICYmICh0aGlzLl9vZmZzZXRzW2kgKyAxXSA9PT0gdW5kZWZpbmVkIHx8IHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbaSArIDFdKTtcblxuICAgICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBTY3JvbGxTcHkucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZSh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcblxuICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgdmFyIHF1ZXJpZXMgPSB0aGlzLl9zZWxlY3Rvci5zcGxpdCgnLCcpO1xuICAgICAgcXVlcmllcyA9IHF1ZXJpZXMubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IgKyAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArIChzZWxlY3RvciArICdbaHJlZj1cIicgKyB0YXJnZXQgKyAnXCJdJyk7XG4gICAgICB9KTtcblxuICAgICAgdmFyICRsaW5rID0gJChxdWVyaWVzLmpvaW4oJywnKSk7XG5cbiAgICAgIGlmICgkbGluay5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fSVRFTSkpIHtcbiAgICAgICAgJGxpbmsuY2xvc2VzdChTZWxlY3Rvci5EUk9QRE9XTikuZmluZChTZWxlY3Rvci5EUk9QRE9XTl9UT0dHTEUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRvZG8gKGZhdCkgdGhpcyBpcyBraW5kYSBzdXMuLi5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYWRkIGFjdGl2ZXMgdG8gdGVzdGVkIG5hdi1saW5rc1xuICAgICAgICAkbGluay5wYXJlbnRzKFNlbGVjdG9yLkxJKS5maW5kKCc+ICcgKyBTZWxlY3Rvci5OQVZfTElOS1MpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLnRyaWdnZXIoRXZlbnQuQUNUSVZBVEUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2Nyb2xsU3B5LnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbiBfY2xlYXIoKSB7XG4gICAgICAkKHRoaXMuX3NlbGVjdG9yKS5maWx0ZXIoU2VsZWN0b3IuQUNUSVZFKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhTY3JvbGxTcHksIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2Nyb2xsU3B5O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJCh3aW5kb3cpLm9uKEV2ZW50LkxPQURfREFUQV9BUEksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsU3B5cyA9ICQubWFrZUFycmF5KCQoU2VsZWN0b3IuREFUQV9TUFkpKTtcblxuICAgIGZvciAodmFyIGkgPSBzY3JvbGxTcHlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyICRzcHkgPSAkKHNjcm9sbFNweXNbaV0pO1xuICAgICAgU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5O1xuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICByZXR1cm4gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFNjcm9sbFNweTtcbn0oalF1ZXJ5KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4wLjAtYWxwaGEuNik6IHRhYi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIFRhYiA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3RhYic7XG4gIHZhciBWRVJTSU9OID0gJzQuMC4wLWFscGhhLjYnO1xuICB2YXIgREFUQV9LRVkgPSAnYnMudGFiJztcbiAgdmFyIEVWRU5UX0tFWSA9ICcuJyArIERBVEFfS0VZO1xuICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcblxuICB2YXIgRXZlbnQgPSB7XG4gICAgSElERTogJ2hpZGUnICsgRVZFTlRfS0VZLFxuICAgIEhJRERFTjogJ2hpZGRlbicgKyBFVkVOVF9LRVksXG4gICAgU0hPVzogJ3Nob3cnICsgRVZFTlRfS0VZLFxuICAgIFNIT1dOOiAnc2hvd24nICsgRVZFTlRfS0VZLFxuICAgIENMSUNLX0RBVEFfQVBJOiAnY2xpY2snICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gIH07XG5cbiAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICBEUk9QRE9XTl9NRU5VOiAnZHJvcGRvd24tbWVudScsXG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBGQURFOiAnZmFkZScsXG4gICAgU0hPVzogJ3Nob3cnXG4gIH07XG5cbiAgdmFyIFNlbGVjdG9yID0ge1xuICAgIEE6ICdhJyxcbiAgICBMSTogJ2xpJyxcbiAgICBEUk9QRE9XTjogJy5kcm9wZG93bicsXG4gICAgTElTVDogJ3VsOm5vdCguZHJvcGRvd24tbWVudSksIG9sOm5vdCguZHJvcGRvd24tbWVudSksIG5hdjpub3QoLmRyb3Bkb3duLW1lbnUpJyxcbiAgICBGQURFX0NISUxEOiAnPiAubmF2LWl0ZW0gLmZhZGUsID4gLmZhZGUnLFxuICAgIEFDVElWRTogJy5hY3RpdmUnLFxuICAgIEFDVElWRV9DSElMRDogJz4gLm5hdi1pdGVtID4gLmFjdGl2ZSwgPiAuYWN0aXZlJyxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsXG4gICAgRFJPUERPV05fVE9HR0xFOiAnLmRyb3Bkb3duLXRvZ2dsZScsXG4gICAgRFJPUERPV05fQUNUSVZFX0NISUxEOiAnPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWIoZWxlbWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGdldHRlcnNcblxuICAgIC8vIHB1YmxpY1xuXG4gICAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczIwID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91cyA9IHZvaWQgMDtcbiAgICAgIHZhciBsaXN0RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5MSVNUKVswXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICAgIHByZXZpb3VzID0gJC5tYWtlQXJyYXkoJChsaXN0RWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkUpKTtcbiAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91c1twcmV2aW91cy5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGVFdmVudCk7XG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICB0YXJnZXQgPSAkKHNlbGVjdG9yKVswXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIGhpZGRlbkV2ZW50ID0gJC5FdmVudChFdmVudC5ISURERU4sIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBfdGhpczIwLl9lbGVtZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzaG93bkV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XTiwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHByZXZpb3VzXG4gICAgICAgIH0pO1xuXG4gICAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZGVuRXZlbnQpO1xuICAgICAgICAkKF90aGlzMjAuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd25FdmVudCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldCwgdGFyZ2V0LnBhcmVudE5vZGUsIGNvbXBsZXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRhYi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlXG5cbiAgICBUYWIucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZShlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyMSA9IHRoaXM7XG5cbiAgICAgIHZhciBhY3RpdmUgPSAkKGNvbnRhaW5lcikuZmluZChTZWxlY3Rvci5BQ1RJVkVfQ0hJTEQpWzBdO1xuICAgICAgdmFyIGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgKGFjdGl2ZSAmJiAkKGFjdGl2ZSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpIHx8IEJvb2xlYW4oJChjb250YWluZXIpLmZpbmQoU2VsZWN0b3IuRkFERV9DSElMRClbMF0pKTtcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIxLl90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBpc1RyYW5zaXRpb25pbmcsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICQoYWN0aXZlKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAkKGFjdGl2ZSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUYWIucHJvdG90eXBlLl90cmFuc2l0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgaXNUcmFuc2l0aW9uaW5nLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAkKGFjdGl2ZSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG5cbiAgICAgICAgdmFyIGRyb3Bkb3duQ2hpbGQgPSAkKGFjdGl2ZS5wYXJlbnROb2RlKS5maW5kKFNlbGVjdG9yLkRST1BET1dOX0FDVElWRV9DSElMRClbMF07XG5cbiAgICAgICAgaWYgKGRyb3Bkb3duQ2hpbGQpIHtcbiAgICAgICAgICAkKGRyb3Bkb3duQ2hpbGQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGlmIChpc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgVXRpbC5yZWZsb3coZWxlbWVudCk7XG4gICAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgJChlbGVtZW50LnBhcmVudE5vZGUpLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QRE9XTl9NRU5VKSkge1xuXG4gICAgICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoU2VsZWN0b3IuRFJPUERPV04pWzBdO1xuICAgICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgICAgJChkcm9wZG93bkVsZW1lbnQpLmZpbmQoU2VsZWN0b3IuRFJPUERPV05fVE9HR0xFKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIFRhYi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVGFiKHRoaXMpO1xuICAgICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicgKyBjb25maWcgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGFiLCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRhYjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICdzaG93Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gVGFiLl9qUXVlcnlJbnRlcmZhY2U7XG4gICQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBUYWI7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBUYWIuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gVGFiO1xufShqUXVlcnkpO1xuXG4vKiBnbG9iYWwgVGV0aGVyICovXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBUZXRoZXIgZGVwZW5kZW5jeVxuICAgKiBUZXRoZXIgLSBodHRwOi8vdGV0aGVyLmlvL1xuICAgKi9cbiAgaWYgKHR5cGVvZiBUZXRoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXAgdG9vbHRpcHMgcmVxdWlyZSBUZXRoZXIgKGh0dHA6Ly90ZXRoZXIuaW8vKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3Rvb2x0aXAnO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1hbHBoYS42JztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuICB2YXIgVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MDtcbiAgdmFyIENMQVNTX1BSRUZJWCA9ICdicy10ZXRoZXInO1xuXG4gIHZhciBEZWZhdWx0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBkZWxheTogMCxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBzZWxlY3RvcjogZmFsc2UsXG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBvZmZzZXQ6ICcwIDAnLFxuICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICBjb250YWluZXI6IGZhbHNlXG4gIH07XG5cbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxuICAgIHRyaWdnZXI6ICdzdHJpbmcnLFxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgICBodG1sOiAnYm9vbGVhbicsXG4gICAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgb2Zmc2V0OiAnc3RyaW5nJyxcbiAgICBjb25zdHJhaW50czogJ2FycmF5JyxcbiAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknXG4gIH07XG5cbiAgdmFyIEF0dGFjaG1lbnRNYXAgPSB7XG4gICAgVE9QOiAnYm90dG9tIGNlbnRlcicsXG4gICAgUklHSFQ6ICdtaWRkbGUgbGVmdCcsXG4gICAgQk9UVE9NOiAndG9wIGNlbnRlcicsXG4gICAgTEVGVDogJ21pZGRsZSByaWdodCdcbiAgfTtcblxuICB2YXIgSG92ZXJTdGF0ZSA9IHtcbiAgICBTSE9XOiAnc2hvdycsXG4gICAgT1VUOiAnb3V0J1xuICB9O1xuXG4gIHZhciBFdmVudCA9IHtcbiAgICBISURFOiAnaGlkZScgKyBFVkVOVF9LRVksXG4gICAgSElEREVOOiAnaGlkZGVuJyArIEVWRU5UX0tFWSxcbiAgICBTSE9XOiAnc2hvdycgKyBFVkVOVF9LRVksXG4gICAgU0hPV046ICdzaG93bicgKyBFVkVOVF9LRVksXG4gICAgSU5TRVJURUQ6ICdpbnNlcnRlZCcgKyBFVkVOVF9LRVksXG4gICAgQ0xJQ0s6ICdjbGljaycgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNJTjogJ2ZvY3VzaW4nICsgRVZFTlRfS0VZLFxuICAgIEZPQ1VTT1VUOiAnZm9jdXNvdXQnICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFRU5URVI6ICdtb3VzZWVudGVyJyArIEVWRU5UX0tFWSxcbiAgICBNT1VTRUxFQVZFOiAnbW91c2VsZWF2ZScgKyBFVkVOVF9LRVlcbiAgfTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgVE9PTFRJUDogJy50b29sdGlwJyxcbiAgICBUT09MVElQX0lOTkVSOiAnLnRvb2x0aXAtaW5uZXInXG4gIH07XG5cbiAgdmFyIFRldGhlckNsYXNzID0ge1xuICAgIGVsZW1lbnQ6IGZhbHNlLFxuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH07XG5cbiAgdmFyIFRyaWdnZXIgPSB7XG4gICAgSE9WRVI6ICdob3ZlcicsXG4gICAgRk9DVVM6ICdmb2N1cycsXG4gICAgQ0xJQ0s6ICdjbGljaycsXG4gICAgTUFOVUFMOiAnbWFudWFsJ1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgICAgLy8gcHJpdmF0ZVxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9O1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90ZXRoZXIgPSBudWxsO1xuXG4gICAgICAvLyBwcm90ZWN0ZWRcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBnZXR0ZXJzXG5cbiAgICAvLyBwdWJsaWNcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgICB2YXIgY29udGV4dCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuXG4gICAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXG4gICAgICB0aGlzLmNsZWFudXBUZXRoZXIoKTtcblxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSk7XG5cbiAgICAgICQodGhpcy5lbGVtZW50KS5vZmYodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9mZignaGlkZS5icy5tb2RhbCcpO1xuXG4gICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgJCh0aGlzLnRpcCkucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGw7XG4gICAgICB0aGlzLl90ZXRoZXIgPSBudWxsO1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczIyID0gdGhpcztcblxuICAgICAgaWYgKCQodGhpcy5lbGVtZW50KS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKTtcbiAgICAgIGlmICh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbHRpcCBpcyB0cmFuc2l0aW9uaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgICB2YXIgaXNJblRoZURvbSA9ICQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgICAgIHZhciB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XG5cbiAgICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZCk7XG5cbiAgICAgICAgdGhpcy5zZXRDb250ZW50KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICAgICQodGlwKS5hZGRDbGFzcyhDbGFzc05hbWUuRkFERSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLnBsYWNlbWVudDtcblxuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KTtcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XG5cbiAgICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcykuYXBwZW5kVG8oY29udGFpbmVyKTtcblxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcblxuICAgICAgICB0aGlzLl90ZXRoZXIgPSBuZXcgVGV0aGVyKHtcbiAgICAgICAgICBhdHRhY2htZW50OiBhdHRhY2htZW50LFxuICAgICAgICAgIGVsZW1lbnQ6IHRpcCxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICBjbGFzc2VzOiBUZXRoZXJDbGFzcyxcbiAgICAgICAgICBjbGFzc1ByZWZpeDogQ0xBU1NfUFJFRklYLFxuICAgICAgICAgIG9mZnNldDogdGhpcy5jb25maWcub2Zmc2V0LFxuICAgICAgICAgIGNvbnN0cmFpbnRzOiB0aGlzLmNvbmZpZy5jb25zdHJhaW50cyxcbiAgICAgICAgICBhZGRUYXJnZXRDbGFzc2VzOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBVdGlsLnJlZmxvdyh0aXApO1xuICAgICAgICB0aGlzLl90ZXRoZXIucG9zaXRpb24oKTtcblxuICAgICAgICAkKHRpcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IF90aGlzMjIuX2hvdmVyU3RhdGU7XG4gICAgICAgICAgX3RoaXMyMi5faG92ZXJTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgX3RoaXMyMi5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAkKF90aGlzMjIuZWxlbWVudCkudHJpZ2dlcihfdGhpczIyLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKTtcblxuICAgICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgIF90aGlzMjIuX2xlYXZlKG51bGwsIF90aGlzMjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoVXRpbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSAmJiAkKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgICAgICQodGhpcy50aXApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5fVFJBTlNJVElPTl9EVVJBVElPTik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIzID0gdGhpcztcblxuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKTtcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sdGlwIGlzIHRyYW5zaXRpb25pbmcnKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoX3RoaXMyMy5faG92ZXJTdGF0ZSAhPT0gSG92ZXJTdGF0ZS5TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMjMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgICAgJChfdGhpczIzLmVsZW1lbnQpLnRyaWdnZXIoX3RoaXMyMy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pO1xuICAgICAgICBfdGhpczIzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMyMy5jbGVhbnVwVGV0aGVyKCk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5DTElDS10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5GT0NVU10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5IT1ZFUl0gPSBmYWxzZTtcblxuICAgICAgaWYgKFV0aWwuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkgJiYgJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICAgICQodGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRSQU5TSVRJT05fRFVSQVRJT04pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWRcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoKSB7XG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5UT09MVElQX0lOTkVSKSwgdGhpcy5nZXRUaXRsZSgpKTtcblxuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgdGhpcy5jbGVhbnVwVGV0aGVyKCk7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNldEVsZW1lbnRDb250ZW50ID0gZnVuY3Rpb24gc2V0RWxlbWVudENvbnRlbnQoJGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICAgIHZhciBodG1sID0gdGhpcy5jb25maWcuaHRtbDtcbiAgICAgIGlmICgodHlwZW9mIGNvbnRlbnQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbnRlbnQpKSA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAgIC8vIGNvbnRlbnQgaXMgYSBET00gbm9kZSBvciBhIGpRdWVyeVxuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsZW1lbnRbaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10oY29udGVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG5cbiAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgdGl0bGUgPSB0eXBlb2YgdGhpcy5jb25maWcudGl0bGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy50aXRsZS5jYWxsKHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy50aXRsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5jbGVhbnVwVGV0aGVyID0gZnVuY3Rpb24gY2xlYW51cFRldGhlcigpIHtcbiAgICAgIGlmICh0aGlzLl90ZXRoZXIpIHtcbiAgICAgICAgdGhpcy5fdGV0aGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZVxuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2dldEF0dGFjaG1lbnQgPSBmdW5jdGlvbiBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyNCA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmlnZ2VycyA9IHRoaXMuY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcblxuICAgICAgdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICQoX3RoaXMyNC5lbGVtZW50KS5vbihfdGhpczI0LmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLCBfdGhpczI0LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyNC50b2dnbGUoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRyaWdnZXIuTUFOVUFMKSB7XG4gICAgICAgICAgdmFyIGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID8gX3RoaXMyNC5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogX3RoaXMyNC5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOO1xuICAgICAgICAgIHZhciBldmVudE91dCA9IHRyaWdnZXIgPT09IFRyaWdnZXIuSE9WRVIgPyBfdGhpczI0LmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiBfdGhpczI0LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuXG4gICAgICAgICAgJChfdGhpczI0LmVsZW1lbnQpLm9uKGV2ZW50SW4sIF90aGlzMjQuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczI0Ll9lbnRlcihldmVudCk7XG4gICAgICAgICAgfSkub24oZXZlbnRPdXQsIF90aGlzMjQuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczI0Ll9sZWF2ZShldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkKF90aGlzMjQuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub24oJ2hpZGUuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMjQuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5jb25maWcsIHtcbiAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5fZml4VGl0bGUgPSBmdW5jdGlvbiBfZml4VGl0bGUoKSB7XG4gICAgICB2YXIgdGl0bGVUeXBlID0gX3R5cGVvZih0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgdGl0bGVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5fZW50ZXIgPSBmdW5jdGlvbiBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcbiAgICAgIHZhciBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTtcblxuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpO1xuXG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRyaWdnZXIuRk9DVVMgOiBUcmlnZ2VyLkhPVkVSXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgkKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5TSE9XKSB7XG4gICAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLlNIT1c7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuXG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XO1xuXG4gICAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KSB7XG4gICAgICAgIGNvbnRleHQuc2hvdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgICAgIGNvbnRleHQuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2xlYXZlID0gZnVuY3Rpb24gX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG5cbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJdID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dCk7XG5cbiAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLk9VVDtcblxuICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICBjb250ZXh0LmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLk9VVCkge1xuICAgICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIgPSBmdW5jdGlvbiBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIGZvciAodmFyIHRyaWdnZXIgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcikge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0cmlnZ2VyXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2dldENvbmZpZyA9IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkKHRoaXMuZWxlbWVudCkuZGF0YSgpLCBjb25maWcpO1xuXG4gICAgICBpZiAoY29uZmlnLmRlbGF5ICYmIHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLl9nZXREZWxlZ2F0ZUNvbmZpZyA9IGZ1bmN0aW9uIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWNcblxuICAgIFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9ICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnO1xuXG4gICAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInICsgY29uZmlnICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIG51bGwsIFt7XG4gICAgICBrZXk6ICdWRVJTSU9OJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdOQU1FJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gTkFNRTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEQVRBX0tFWScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERBVEFfS0VZO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0V2ZW50JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRXZlbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRVZFTlRfS0VZJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRVZFTlRfS0VZO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0RlZmF1bHRUeXBlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRvb2x0aXA7XG4gIH0oKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJC5mbltOQU1FXSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiAgJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvb2x0aXA7XG4gICQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBUb29sdGlwLl9qUXVlcnlJbnRlcmZhY2U7XG4gIH07XG5cbiAgcmV0dXJuIFRvb2x0aXA7XG59KGpRdWVyeSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMC4wLWFscGhhLjYpOiBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgUG9wb3ZlciA9IGZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDb25zdGFudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBOQU1FID0gJ3BvcG92ZXInO1xuICB2YXIgVkVSU0lPTiA9ICc0LjAuMC1hbHBoYS42JztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLnBvcG92ZXInO1xuICB2YXIgRVZFTlRfS0VZID0gJy4nICsgREFUQV9LRVk7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xuXG4gIHZhciBEZWZhdWx0ID0gJC5leHRlbmQoe30sIFRvb2x0aXAuRGVmYXVsdCwge1xuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J1xuICB9KTtcblxuICB2YXIgRGVmYXVsdFR5cGUgPSAkLmV4dGVuZCh7fSwgVG9vbHRpcC5EZWZhdWx0VHlwZSwge1xuICAgIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xuICB9KTtcblxuICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgIEZBREU6ICdmYWRlJyxcbiAgICBTSE9XOiAnc2hvdydcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgVElUTEU6ICcucG9wb3Zlci10aXRsZScsXG4gICAgQ09OVEVOVDogJy5wb3BvdmVyLWNvbnRlbnQnXG4gIH07XG5cbiAgdmFyIEV2ZW50ID0ge1xuICAgIEhJREU6ICdoaWRlJyArIEVWRU5UX0tFWSxcbiAgICBISURERU46ICdoaWRkZW4nICsgRVZFTlRfS0VZLFxuICAgIFNIT1c6ICdzaG93JyArIEVWRU5UX0tFWSxcbiAgICBTSE9XTjogJ3Nob3duJyArIEVWRU5UX0tFWSxcbiAgICBJTlNFUlRFRDogJ2luc2VydGVkJyArIEVWRU5UX0tFWSxcbiAgICBDTElDSzogJ2NsaWNrJyArIEVWRU5UX0tFWSxcbiAgICBGT0NVU0lOOiAnZm9jdXNpbicgKyBFVkVOVF9LRVksXG4gICAgRk9DVVNPVVQ6ICdmb2N1c291dCcgKyBFVkVOVF9LRVksXG4gICAgTU9VU0VFTlRFUjogJ21vdXNlZW50ZXInICsgRVZFTlRfS0VZLFxuICAgIE1PVVNFTEVBVkU6ICdtb3VzZWxlYXZlJyArIEVWRU5UX0tFWVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX1Rvb2x0aXApIHtcbiAgICBfaW5oZXJpdHMoUG9wb3ZlciwgX1Rvb2x0aXApO1xuXG4gICAgZnVuY3Rpb24gUG9wb3ZlcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BvdmVyKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Ub29sdGlwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlc1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaXNXaXRoQ29udGVudCA9IGZ1bmN0aW9uIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICB9O1xuXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoKSB7XG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuXG4gICAgICAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5DT05URU5UKSwgdGhpcy5fZ2V0Q29udGVudCgpKTtcblxuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArICcgJyArIENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgdGhpcy5jbGVhbnVwVGV0aGVyKCk7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGVcblxuICAgIFBvcG92ZXIucHJvdG90eXBlLl9nZXRDb250ZW50ID0gZnVuY3Rpb24gX2dldENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50JykgfHwgKHR5cGVvZiB0aGlzLmNvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcuY29udGVudC5jYWxsKHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy5jb250ZW50KTtcbiAgICB9O1xuXG4gICAgLy8gc3RhdGljXG5cbiAgICBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgdmFyIF9jb25maWcgPSAodHlwZW9mIGNvbmZpZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uZmlnKSkgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbDtcblxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJyArIGNvbmZpZyArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhQb3BvdmVyLCBudWxsLCBbe1xuICAgICAga2V5OiAnVkVSU0lPTicsXG5cblxuICAgICAgLy8gZ2V0dGVyc1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnRGVmYXVsdCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnTkFNRScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnREFUQV9LRVknLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEQVRBX0tFWTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdFdmVudCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ0VWRU5UX0tFWScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEVWRU5UX0tFWTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdEZWZhdWx0VHlwZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQb3BvdmVyO1xuICB9KFRvb2x0aXApO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkLmZuW05BTUVdID0gUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlO1xuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gUG9wb3ZlcjtcbiAgJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICByZXR1cm4gUG9wb3Zlcjtcbn0oalF1ZXJ5KTtcblxufSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/hello.js\nconst hello = greeting => {\n  console.log(greeting);\n};\n\n\n// CONCATENATED MODULE: ./src/graphs.js\nvar g = new Dygraph(document.getElementById('graph'), [[1, null, 3], [2, 2, null], [3, null, 7], [4, 5, null], [5, null, 5], [6, 3, null]], {\n  labels: ['x', 'A', 'B'],\n  connectSeparatedPoints: true,\n  drawPoints: true\n});\n\n// EXTERNAL MODULE: ./src/styles/main.scss\nvar main = __webpack_require__(25);\n\n// EXTERNAL MODULE: ./node_modules/bootstrap/dist/js/bootstrap.js\nvar bootstrap = __webpack_require__(30);\n\n// EXTERNAL MODULE: ./node_modules/dygraphs/src/dygraph.js\nvar dygraph = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/dygraphs/index.js\n\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\nconsole.log(hello('Hi again'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVsbG8uanM/MDI3OCIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JhcGhzLmpzP2U2MTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2R5Z3JhcGhzL2luZGV4LmpzPzExZjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaGVsbG8gPSAoZ3JlZXRpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZyhncmVldGluZylcbn1cblxuZXhwb3J0IHsgaGVsbG8gfSIsInZhciBnID0gbmV3IER5Z3JhcGgoXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dyYXBoJyksXG4gICAgW1xuICAgICAgICBbMSwgbnVsbCwgM10sXG4gICAgICAgIFsyLCAyLCBudWxsXSxcbiAgICAgICAgWzMsIG51bGwsIDddLFxuICAgICAgICBbNCwgNSwgbnVsbF0sXG4gICAgICAgIFs1LCBudWxsLCA1XSxcbiAgICAgICAgWzYsIDMsIG51bGxdXG4gICAgXSxcbiAgICB7XG4gICAgICAgIGxhYmVsczogWyd4JywgJ0EnLCAnQiddLFxuICAgICAgICBjb25uZWN0U2VwYXJhdGVkUG9pbnRzOiB0cnVlLFxuICAgICAgICBkcmF3UG9pbnRzOiB0cnVlXG4gICAgfVxuKTtcblxuZXhwb3J0IHsgZyB9IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vc3JjL2R5Z3JhcGgnO1xuIiwiaW1wb3J0IHsgaGVsbG8gfSBmcm9tICcuL2hlbGxvJztcbmltcG9ydCB7IGcgfSBmcm9tICcuL2dyYXBocy5qcyc7XG5pbXBvcnQgJy4vc3R5bGVzL21haW4uc2Nzcyc7XG5pbXBvcnQgJ2Jvb3RzdHJhcCc7XG5pbXBvcnQgJ2R5Z3JhcGhzJztcblxuY29uc29sZS5sb2coaGVsbG8oJ0hpIGFnYWluJykpOyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBV0E7QUFDQTtBQUNBO0FBSEE7Ozs7Ozs7Ozs7OztBQ1ZBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n")}]);